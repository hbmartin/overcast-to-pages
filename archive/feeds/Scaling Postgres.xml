<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:podcast="https://podcastindex.org/namespace/1.0"
    xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/"
    xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
    xmlns:itunes="http://www.itunes.com/dtds/podcast-1.0.dtd" xmlns:spotify="http://www.spotify.com/ns/rss">
    <channel>
        <title>Scaling Postgres</title>
        <generator>Castos</generator>
        <atom:link href="https://feeds.castos.com/r30m3" rel="self" type="application/rss+xml" />
        <link>https://www.scalingpostgres.com</link>
        <description>Learn how to get the best performance and scale your PostgreSQL database with our weekly shows. Receive the best content curated from around the web. We have a special focus on content for developers since your architecture and usage is the key to getting the most performance out of PostgreSQL.</description>
        <lastBuildDate>Sun, 08 Jun 2025 21:00:00 +0000</lastBuildDate>
        <language>en</language>
        <copyright>© 2023</copyright>
        
        <spotify:limit recentCount="500" />
        
        <spotify:countryOfOrigin>
              
        </spotify:countryOfOrigin>
                    <image>
                <url>https://episodes.castos.com/64f928bed21987-09216453/images/95e21c9bbf50bac1c4694a7df7e66b63-1694096438-itunes.jpg</url>
                <title>Scaling Postgres</title>
                <link>https://www.scalingpostgres.com</link>
            </image>
                <itunes:subtitle>Learn how to get the best performance and scale your PostgreSQL database with our weekly shows. Receive the best content curated from around the web. We have a special focus on content for developers since your architecture and usage is the key to getting the most performance out of PostgreSQL.</itunes:subtitle>
        <itunes:author>Creston Jamison</itunes:author>
        <itunes:type>episodic</itunes:type>
        <itunes:summary>Learn how to get the best performance and scale your PostgreSQL database with our weekly shows. Receive the best content curated from around the web. We have a special focus on content for developers since your architecture and usage is the key to getting the most performance out of PostgreSQL.</itunes:summary>
        <itunes:owner>
            <itunes:name>creston.jamison@rubytreesoftware.com (Ruby Tree Software Inc)</itunes:name>
            <itunes:email>creston.jamison@rubytreesoftware.com</itunes:email>
        </itunes:owner>
        <itunes:explicit>false</itunes:explicit>
                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/95e21c9bbf50bac1c4694a7df7e66b63-1694096438-itunes.jpg"></itunes:image>
        
                                    <itunes:category text="Technology" />
                    
                    <itunes:new-feed-url>https://feeds.castos.com/r30m3</itunes:new-feed-url>
                
        
        <podcast:locked>yes</podcast:locked>
                                    <item>
                <title>
                    <![CDATA[Move Off Of RDS? | Scaling Postgres 369]]>
                </title>
                <pubDate>Sun, 08 Jun 2025 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/2059728</guid>
                                    <link>https://www.scalingpostgres.com/episodes/369-move-off-of-rds/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss why and how you could move off of AWS RDS, Snowflake acquires Crunchy Data, reducing your SQL queries and a novel way to migrate to partition tables.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/369-move-off-of-rds/">https://www.scalingpostgres.com/episodes/369-move-off-of-rds/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss why and how you could move off of AWS RDS, Snowflake acquires Crunchy Data, reducing your SQL queries and a novel way to migrate to partition tables.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/369-move-off-of-rds/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Move Off Of RDS? | Scaling Postgres 369]]>
                </itunes:title>
                                    <itunes:episode>369</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss why and how you could move off of AWS RDS, Snowflake acquires Crunchy Data, reducing your SQL queries and a novel way to migrate to partition tables.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/369-move-off-of-rds/">https://www.scalingpostgres.com/episodes/369-move-off-of-rds/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/2059728/c1e-xr51nc9pj05ckj7q1-z328mopmt585-gh4gbp.mp3" length="34599497"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss why and how you could move off of AWS RDS, Snowflake acquires Crunchy Data, reducing your SQL queries and a novel way to migrate to partition tables.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/369-move-off-of-rds/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:18:01</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[4 Times Faster UUID Primary Keys | Scaling Postgres 368]]>
                </title>
                <pubDate>Sun, 01 Jun 2025 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/2055792</guid>
                                    <link>https://www.scalingpostgres.com/episodes/368-4-times-faster-uuid-primary-keys/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the benefits of using time-based UUIDv7 vs UUIDv4 for primary keys, how OpenAI uses Postgres, handling locks and methods to migrate to partition tables with low downtime.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/368-4-times-faster-uuid-primary-keys/">https://www.scalingpostgres.com/episodes/368-4-times-faster-uuid-primary-keys/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the benefits of using time-based UUIDv7 vs UUIDv4 for primary keys, how OpenAI uses Postgres, handling locks and methods to migrate to partition tables with low downtime.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/368-4-times-faster-uuid-primary-keys/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[4 Times Faster UUID Primary Keys | Scaling Postgres 368]]>
                </itunes:title>
                                    <itunes:episode>368</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the benefits of using time-based UUIDv7 vs UUIDv4 for primary keys, how OpenAI uses Postgres, handling locks and methods to migrate to partition tables with low downtime.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/368-4-times-faster-uuid-primary-keys/">https://www.scalingpostgres.com/episodes/368-4-times-faster-uuid-primary-keys/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/2055792/c1e-9vpz8cdovw9sw3vgk-jpdz0z22s2gg-06lw9g.mp3" length="36803813"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the benefits of using time-based UUIDv7 vs UUIDv4 for primary keys, how OpenAI uses Postgres, handling locks and methods to migrate to partition tables with low downtime.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/368-4-times-faster-uuid-primary-keys/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:19:10</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[How Often Does That Query Run? | Scaling Postgres 367]]>
                </title>
                <pubDate>Sun, 25 May 2025 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/2045558</guid>
                                    <link>https://www.scalingpostgres.com/episodes/367-how-often-does-that-query-run/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss a Postgres VS code extension, service definition files, undead tuples and the benefits of finding out how often a query is run.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/367-how-often-does-that-query-run/">https://www.scalingpostgres.com/episodes/367-how-often-does-that-query-run/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a Postgres VS code extension, service definition files, undead tuples and the benefits of finding out how often a query is run.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/367-how-often-does-that-query-run/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[How Often Does That Query Run? | Scaling Postgres 367]]>
                </itunes:title>
                                    <itunes:episode>367</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss a Postgres VS code extension, service definition files, undead tuples and the benefits of finding out how often a query is run.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/367-how-often-does-that-query-run/">https://www.scalingpostgres.com/episodes/367-how-often-does-that-query-run/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/2045558/c1e-qg23kidp579cjpv5o-pk45022mbdm8-reoovl.mp3" length="25282351"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a Postgres VS code extension, service definition files, undead tuples and the benefits of finding out how often a query is run.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/367-how-often-does-that-query-run/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:13:10</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[20,000 Times Faster Order By Limit | Scaling Postgres 366]]>
                </title>
                <pubDate>Sun, 18 May 2025 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/2041622</guid>
                                    <link>https://www.scalingpostgres.com/episodes/366-20k-faster-order-by-limit/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss a top ten dangerous Postgres issues list, importing and exporting statistics, more Postgres 18 beta features and a 20,000 times faster query by fixing an order by limit issue.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/366-20k-faster-order-by-limit/">https://www.scalingpostgres.com/episodes/366-20k-faster-order-by-limit/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a top ten dangerous Postgres issues list, importing and exporting statistics, more Postgres 18 beta features and a 20,000 times faster query by fixing an order by limit issue.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/366-20k-faster-order-by-limit/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[20,000 Times Faster Order By Limit | Scaling Postgres 366]]>
                </itunes:title>
                                    <itunes:episode>366</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss a top ten dangerous Postgres issues list, importing and exporting statistics, more Postgres 18 beta features and a 20,000 times faster query by fixing an order by limit issue.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/366-20k-faster-order-by-limit/">https://www.scalingpostgres.com/episodes/366-20k-faster-order-by-limit/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/2041622/c1e-w9520c3zgx1c8kg13-dmzvq75ws75n-95m0vb.mp3" length="28373577"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a top ten dangerous Postgres issues list, importing and exporting statistics, more Postgres 18 beta features and a 20,000 times faster query by fixing an order by limit issue.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/366-20k-faster-order-by-limit/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:14:46</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Here Comes Async I/O! | Scaling Postgres 365]]>
                </title>
                <pubDate>Sun, 11 May 2025 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/2037657</guid>
                                    <link>https://www.scalingpostgres.com/episodes/365-here-comes-async-io/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss async I/O introduced in PG 18 Beta 1, new Postgres releases, PgDog performance and innovative ways to optimize queries.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/365-here-comes-async-io/">https://www.scalingpostgres.com/episodes/365-here-comes-async-io/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss async I/O introduced in PG 18 Beta 1, new Postgres releases, PgDog performance and innovative ways to optimize queries.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/365-here-comes-async-io/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Here Comes Async I/O! | Scaling Postgres 365]]>
                </itunes:title>
                                    <itunes:episode>365</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss async I/O introduced in PG 18 Beta 1, new Postgres releases, PgDog performance and innovative ways to optimize queries.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/365-here-comes-async-io/">https://www.scalingpostgres.com/episodes/365-here-comes-async-io/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/2037657/c1e-xr51nc98vqvtkj7q1-qdmdx4m2s2p-owprab.mp3" length="38434690"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss async I/O introduced in PG 18 Beta 1, new Postgres releases, PgDog performance and innovative ways to optimize queries.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/365-here-comes-async-io/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:20:01</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Scaling For High Volume | Scaling Postgres 364]]>
                </title>
                <pubDate>Sun, 04 May 2025 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/2024065</guid>
                                    <link>https://www.scalingpostgres.com/episodes/364-scaling-for-high-volume/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss scaling for high volume, why workflows should be Postgres rows, a planner gotcha and ways to resolve planner issues.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/364-scaling-for-high-volume/">https://www.scalingpostgres.com/episodes/364-scaling-for-high-volume/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss scaling for high volume, why workflows should be Postgres rows, a planner gotcha and ways to resolve planner issues.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/364-scaling-for-high-volume/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Scaling For High Volume | Scaling Postgres 364]]>
                </itunes:title>
                                    <itunes:episode>364</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss scaling for high volume, why workflows should be Postgres rows, a planner gotcha and ways to resolve planner issues.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/364-scaling-for-high-volume/">https://www.scalingpostgres.com/episodes/364-scaling-for-high-volume/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/2024065/c1e-542nmf1zdrnhq6xwk-okm0jq18u1zj-twb6zm.mp3" length="39662654"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss scaling for high volume, why workflows should be Postgres rows, a planner gotcha and ways to resolve planner issues.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/364-scaling-for-high-volume/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:20:39</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Top Ten Postgres Dos & Don'ts | Scaling Postgres 363]]>
                </title>
                <pubDate>Sun, 27 Apr 2025 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/2019583</guid>
                                    <link>https://www.scalingpostgres.com/episodes/363-top-ten-postgres-dos-and-donts/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss a top ten dos and don't for Postgres, understanding statistics and extended statistics, aligning columns to reduce padding and how to handle disaster recovery.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/363-top-ten-postgres-dos-and-donts/">https://www.scalingpostgres.com/episodes/363-top-ten-postgres-dos-and-donts/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a top ten dos and don't for Postgres, understanding statistics and extended statistics, aligning columns to reduce padding and how to handle disaster recovery.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/363-top-ten-postgres-dos-and-donts/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Top Ten Postgres Dos & Don'ts | Scaling Postgres 363]]>
                </itunes:title>
                                    <itunes:episode>363</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss a top ten dos and don't for Postgres, understanding statistics and extended statistics, aligning columns to reduce padding and how to handle disaster recovery.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/363-top-ten-postgres-dos-and-donts/">https://www.scalingpostgres.com/episodes/363-top-ten-postgres-dos-and-donts/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/2019583/c1e-01qo3skwwj7t6dmx0-dmzxz0xztonz-fdusdd.mp3" length="25995389"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a top ten dos and don't for Postgres, understanding statistics and extended statistics, aligning columns to reduce padding and how to handle disaster recovery.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/363-top-ten-postgres-dos-and-donts/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:13:32</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Optimizing For Time-Series Data | Scaling Postgres 362]]>
                </title>
                <pubDate>Sun, 20 Apr 2025 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/2015943</guid>
                                    <link>https://www.scalingpostgres.com/episodes/362-optimizing-for-time-series-data/</link>
                                <description>
                                            <![CDATA[<p>In this episode, we discuss optimizing for time-series data, indexing vectors, Postgres APT extension packaging and how to optimize queries involving low cardinality data columns.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/362-optimizing-for-time-series-data/">https://www.scalingpostgres.com/episodes/362-optimizing-for-time-series-data/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode, we discuss optimizing for time-series data, indexing vectors, Postgres APT extension packaging and how to optimize queries involving low cardinality data columns.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/362-optimizing-for-time-series-data/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Optimizing For Time-Series Data | Scaling Postgres 362]]>
                </itunes:title>
                                    <itunes:episode>362</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode, we discuss optimizing for time-series data, indexing vectors, Postgres APT extension packaging and how to optimize queries involving low cardinality data columns.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/362-optimizing-for-time-series-data/">https://www.scalingpostgres.com/episodes/362-optimizing-for-time-series-data/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/2015943/c1e-ondx5a2wd81hdwnqp-8drr3895h92q-8xt94t.mp3" length="23752620"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode, we discuss optimizing for time-series data, indexing vectors, Postgres APT extension packaging and how to optimize queries involving low cardinality data columns.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/362-optimizing-for-time-series-data/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:12:22</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[A Roadmap To Scaling Postgres | Scaling Postgres 361]]>
                </title>
                <pubDate>Sun, 13 Apr 2025 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/2012198</guid>
                                    <link>https://www.scalingpostgres.com/episodes/361-roadmap-to-scaling-postgres/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss a roadmap to scaling Postgres, life altering Postgres patterns, making Postgres better with OrioleDB, performance cliffs and efficient use of foreign keys.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/361-roadmap-to-scaling-postgres/">https://www.scalingpostgres.com/episodes/361-roadmap-to-scaling-postgres/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a roadmap to scaling Postgres, life altering Postgres patterns, making Postgres better with OrioleDB, performance cliffs and efficient use of foreign keys.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/361-roadmap-to-scaling-postgres/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[A Roadmap To Scaling Postgres | Scaling Postgres 361]]>
                </itunes:title>
                                    <itunes:episode>361</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss a roadmap to scaling Postgres, life altering Postgres patterns, making Postgres better with OrioleDB, performance cliffs and efficient use of foreign keys.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/361-roadmap-to-scaling-postgres/">https://www.scalingpostgres.com/episodes/361-roadmap-to-scaling-postgres/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/2012198/c1e-dn309amrnj2hw9d7z-v6dzn6n3cqrg-sizypf.mp3" length="33557107"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a roadmap to scaling Postgres, life altering Postgres patterns, making Postgres better with OrioleDB, performance cliffs and efficient use of foreign keys.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/361-roadmap-to-scaling-postgres/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:17:28</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Handle One Million Connections? | Scaling Postgres 360]]>
                </title>
                <pubDate>Sun, 06 Apr 2025 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/2006972</guid>
                                    <link>https://www.scalingpostgres.com/episodes/360-handle-one-million-connections/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how a new tool pgDog might allow one million client connections to Postgres, novel use cases for pgvector other than semantic search, don't expose port 5432 and Postgres on Kubernetes.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/360-handle-one-million-connections/">https://www.scalingpostgres.com/episodes/360-handle-one-million-connections/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how a new tool pgDog might allow one million client connections to Postgres, novel use cases for pgvector other than semantic search, don't expose port 5432 and Postgres on Kubernetes.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/360-handle-one-million-connections/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Handle One Million Connections? | Scaling Postgres 360]]>
                </itunes:title>
                                    <itunes:episode>360</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how a new tool pgDog might allow one million client connections to Postgres, novel use cases for pgvector other than semantic search, don't expose port 5432 and Postgres on Kubernetes.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/360-handle-one-million-connections/">https://www.scalingpostgres.com/episodes/360-handle-one-million-connections/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/2006972/c1e-542nmf1nk74fq6xwk-kpwmmnqnux5n-g1mhhr.mp3" length="31295111"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how a new tool pgDog might allow one million client connections to Postgres, novel use cases for pgvector other than semantic search, don't expose port 5432 and Postgres on Kubernetes.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/360-handle-one-million-connections/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:16:17</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Trillions of Rows & Metrics | Scaling Postgres 359]]>
                </title>
                <pubDate>Sun, 30 Mar 2025 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/2001678</guid>
                                    <link>https://www.scalingpostgres.com/episodes/359-trillions-of-rows-and-metrics/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we talk about indexes being added to Timescale's column store, processing 1 trillion metrics in Timescale, processing 1 trillion rows in Citus and partitions for deletion use cases.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/359-trillions-of-rows-and-metrics/">https://www.scalingpostgres.com/episodes/359-trillions-of-rows-and-metrics/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we talk about indexes being added to Timescale's column store, processing 1 trillion metrics in Timescale, processing 1 trillion rows in Citus and partitions for deletion use cases.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/359-trillions-of-rows-and-metrics/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Trillions of Rows & Metrics | Scaling Postgres 359]]>
                </itunes:title>
                                    <itunes:episode>359</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we talk about indexes being added to Timescale's column store, processing 1 trillion metrics in Timescale, processing 1 trillion rows in Citus and partitions for deletion use cases.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/359-trillions-of-rows-and-metrics/">https://www.scalingpostgres.com/episodes/359-trillions-of-rows-and-metrics/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/2001678/c1e-ondx5a2rd02udwnqp-okwgrkq3sg16-pqftjr.mp3" length="35448790"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we talk about indexes being added to Timescale's column store, processing 1 trillion metrics in Timescale, processing 1 trillion rows in Citus and partitions for deletion use cases.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/359-trillions-of-rows-and-metrics/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:18:27</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres Conference 2025 | Scaling Postgres 358]]>
                </title>
                <pubDate>Sun, 23 Mar 2025 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1997683</guid>
                                    <link>https://www.scalingpostgres.com/episodes/358-postgres-conference-2025/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, I discuss my experience attending Postgres Conference 2025 and cover some of the highlights of the conference. Interestingly, at least from my perspective, the most well attended talks seemed to cover pg_vector, analytics involving duckdb and partitioning.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/358-postgres-conference-2025/">https://www.scalingpostgres.com/episodes/358-postgres-conference-2025/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, I discuss my experience attending Postgres Conference 2025 and cover some of the highlights of the conference. Interestingly, at least from my perspective, the most well attended talks seemed to cover pg_vector, analytics involving duckdb and partitioning.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/358-postgres-conference-2025/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres Conference 2025 | Scaling Postgres 358]]>
                </itunes:title>
                                    <itunes:episode>358</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, I discuss my experience attending Postgres Conference 2025 and cover some of the highlights of the conference. Interestingly, at least from my perspective, the most well attended talks seemed to cover pg_vector, analytics involving duckdb and partitioning.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/358-postgres-conference-2025/">https://www.scalingpostgres.com/episodes/358-postgres-conference-2025/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1997683/c1e-dn309amw4k5sw9d7z-34n13006h0q-0k8tsz.mp3" length="45347735"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, I discuss my experience attending Postgres Conference 2025 and cover some of the highlights of the conference. Interestingly, at least from my perspective, the most well attended talks seemed to cover pg_vector, analytics involving duckdb and partitioning.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/358-postgres-conference-2025/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:23:37</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres Best Practices? | Scaling Postgres 357]]>
                </title>
                <pubDate>Sun, 16 Mar 2025 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1992818</guid>
                                    <link>https://www.scalingpostgres.com/episodes/357-postgres-best-practices/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss best practices, caching monitoring statistics, a new vector extension called VectorChord and the importance of monitoring wait events.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/357-postgres-best-practices/">https://www.scalingpostgres.com/episodes/357-postgres-best-practices/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss best practices, caching monitoring statistics, a new vector extension called VectorChord and the importance of monitoring wait events.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/357-postgres-best-practices/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres Best Practices? | Scaling Postgres 357]]>
                </itunes:title>
                                    <itunes:episode>357</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss best practices, caching monitoring statistics, a new vector extension called VectorChord and the importance of monitoring wait events.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/357-postgres-best-practices/">https://www.scalingpostgres.com/episodes/357-postgres-best-practices/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1992818/c1e-01qo3sk3oxws6dmx0-ww61jm6ws4xq-7n0cyc.mp3" length="19145038"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss best practices, caching monitoring statistics, a new vector extension called VectorChord and the importance of monitoring wait events.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/357-postgres-best-practices/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:09:58</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Is the Future Immutable? | Scaling Postgres 356]]>
                </title>
                <pubDate>Sun, 09 Mar 2025 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1987988</guid>
                                    <link>https://www.scalingpostgres.com/episodes/356-is-the-future-immutable/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss immutability and Postgres, the upcoming Postgres Conference in Orlando, extended statistics and usage of default partitions.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/356-is-the-future-immutable/">https://www.scalingpostgres.com/episodes/356-is-the-future-immutable/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss immutability and Postgres, the upcoming Postgres Conference in Orlando, extended statistics and usage of default partitions.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/356-is-the-future-immutable/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Is the Future Immutable? | Scaling Postgres 356]]>
                </itunes:title>
                                    <itunes:episode>356</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss immutability and Postgres, the upcoming Postgres Conference in Orlando, extended statistics and usage of default partitions.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/356-is-the-future-immutable/">https://www.scalingpostgres.com/episodes/356-is-the-future-immutable/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1987988/c1e-qg23ki25qrgbjpv5o-1p43w987f80d-koirmb.mp3" length="29491200"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss immutability and Postgres, the upcoming Postgres Conference in Orlando, extended statistics and usage of default partitions.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/356-is-the-future-immutable/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:15:21</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Top Ten Analytics with pg_mooncake | Scaling Postgres 355]]>
                </title>
                <pubDate>Sun, 02 Mar 2025 22:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1984140</guid>
                                    <link>https://www.scalingpostgres.com/episodes/355-top-ten-analytics-with-pg_mooncake/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how Postgres &amp; pg_mooncake achieves top ten Clickbench results, a comparison of Oracle and Postgres transactions, sharding to scale and connection counts.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/355-top-ten-analytics-with-pg_mooncake/">https://www.scalingpostgres.com/episodes/355-top-ten-analytics-with-pg_mooncake/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how Postgres & pg_mooncake achieves top ten Clickbench results, a comparison of Oracle and Postgres transactions, sharding to scale and connection counts.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/355-top-ten-analytics-with-pg_mooncake/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Top Ten Analytics with pg_mooncake | Scaling Postgres 355]]>
                </itunes:title>
                                    <itunes:episode>355</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how Postgres &amp; pg_mooncake achieves top ten Clickbench results, a comparison of Oracle and Postgres transactions, sharding to scale and connection counts.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/355-top-ten-analytics-with-pg_mooncake/">https://www.scalingpostgres.com/episodes/355-top-ten-analytics-with-pg_mooncake/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1984140/c1e-pm5o7t57qjqiq8o3n-z3d0d8x3u2gp-us4bxa.mp3" length="30713312"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how Postgres & pg_mooncake achieves top ten Clickbench results, a comparison of Oracle and Postgres transactions, sharding to scale and connection counts.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/355-top-ten-analytics-with-pg_mooncake/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:15:59</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres & The US Treasury Attack | Scaling Postgres 354]]>
                </title>
                <pubDate>Sun, 23 Feb 2025 22:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1979715</guid>
                                    <link>https://www.scalingpostgres.com/episodes/354-postgres-us-treasury-attack/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the role of Postgres in the US Treasury online attack, new releases of Postgres, optimizing application of streaming changes and a query that filled a databases disks.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/354-postgres-us-treasury-attack/">https://www.scalingpostgres.com/episodes/354-postgres-us-treasury-attack/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the role of Postgres in the US Treasury online attack, new releases of Postgres, optimizing application of streaming changes and a query that filled a databases disks.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/354-postgres-us-treasury-attack/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres & The US Treasury Attack | Scaling Postgres 354]]>
                </itunes:title>
                                    <itunes:episode>354</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the role of Postgres in the US Treasury online attack, new releases of Postgres, optimizing application of streaming changes and a query that filled a databases disks.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/354-postgres-us-treasury-attack/">https://www.scalingpostgres.com/episodes/354-postgres-us-treasury-attack/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1979715/c1e-9vpz8cnkn9quw3vgk-ndokw0rrfz3z-6sabt4.mp3" length="30205074"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the role of Postgres in the US Treasury online attack, new releases of Postgres, optimizing application of streaming changes and a query that filled a databases disks.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/354-postgres-us-treasury-attack/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:15:43</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[OLTP To Parquet For Analytics | Scaling Postgres 353]]>
                </title>
                <pubDate>Sun, 16 Feb 2025 22:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1974802</guid>
                                    <link>https://www.scalingpostgres.com/episodes/353-oltp-to-parquet-for-analytics/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how data can flow from your OLTP to parquet files for analytics, parallel queries, view inlining and partitioning advice.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/353-oltp-to-parquet-for-analytics/">https://www.scalingpostgres.com/episodes/353-oltp-to-parquet-for-analytics/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how data can flow from your OLTP to parquet files for analytics, parallel queries, view inlining and partitioning advice.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/353-oltp-to-parquet-for-analytics/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[OLTP To Parquet For Analytics | Scaling Postgres 353]]>
                </itunes:title>
                                    <itunes:episode>353</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how data can flow from your OLTP to parquet files for analytics, parallel queries, view inlining and partitioning advice.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/353-oltp-to-parquet-for-analytics/">https://www.scalingpostgres.com/episodes/353-oltp-to-parquet-for-analytics/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1974802/c1e-7vwg1c4o0w8f5z6j9-0v51p4p5hq5-ltbdup.mp3" length="30704117"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how data can flow from your OLTP to parquet files for analytics, parallel queries, view inlining and partitioning advice.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/353-oltp-to-parquet-for-analytics/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:15:59</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[You Can Always Optimize More | Scaling Postgres 352]]>
                </title>
                <pubDate>Sun, 09 Feb 2025 22:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1968707</guid>
                                    <link>https://www.scalingpostgres.com/episodes/352-you-can-always-optimize-more/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how you can always optimize more, avoiding deadlocks, casting &amp; indexes and pg_hint_plan best practices.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/352-you-can-always-optimize-more/">https://www.scalingpostgres.com/episodes/352-you-can-always-optimize-more/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how you can always optimize more, avoiding deadlocks, casting & indexes and pg_hint_plan best practices.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/352-you-can-always-optimize-more/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[You Can Always Optimize More | Scaling Postgres 352]]>
                </itunes:title>
                                    <itunes:episode>352</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how you can always optimize more, avoiding deadlocks, casting &amp; indexes and pg_hint_plan best practices.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/352-you-can-always-optimize-more/">https://www.scalingpostgres.com/episodes/352-you-can-always-optimize-more/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1968707/c1e-r159xsjg91kc7zkrx-xxwxkpz8f356-twy13c.mp3" length="27921345"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how you can always optimize more, avoiding deadlocks, casting & indexes and pg_hint_plan best practices.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/352-you-can-always-optimize-more/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:14:32</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Features To Avoid? | Scaling Postgres 351]]>
                </title>
                <pubDate>Sun, 02 Feb 2025 22:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1956305</guid>
                                    <link>https://www.scalingpostgres.com/episodes/351-features-to-avoid/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we talk about some features you may want to avoid like commit_delay, index_cleanup off, &amp; logon triggers, a way to detect a table rewrite and a zero downtime upgrade.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/351-features-to-avoid/">https://www.scalingpostgres.com/episodes/351-features-to-avoid/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we talk about some features you may want to avoid like commit_delay, index_cleanup off, & logon triggers, a way to detect a table rewrite and a zero downtime upgrade.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/351-features-to-avoid/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Features To Avoid? | Scaling Postgres 351]]>
                </itunes:title>
                                    <itunes:episode>351</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we talk about some features you may want to avoid like commit_delay, index_cleanup off, &amp; logon triggers, a way to detect a table rewrite and a zero downtime upgrade.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/351-features-to-avoid/">https://www.scalingpostgres.com/episodes/351-features-to-avoid/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1956305/c1e-ondx5av85nqtdwnqp-mkx9d28of6pm-kpj1mr.mp3" length="32486295"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we talk about some features you may want to avoid like commit_delay, index_cleanup off, & logon triggers, a way to detect a table rewrite and a zero downtime upgrade.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/351-features-to-avoid/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:16:55</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Seven Years of Scaling Postgres | Scaling Postgres 350]]>
                </title>
                <pubDate>Sun, 26 Jan 2025 22:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1949239</guid>
                                    <link>https://www.scalingpostgres.com/episodes/350-seven-years-of-scaling-postgres/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss our seven year anniversary, better pg_search performance, reducing table locks, not valid constraints and better group by statistics.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/350-seven-years-of-scaling-postgres/">https://www.scalingpostgres.com/episodes/350-seven-years-of-scaling-postgres/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss our seven year anniversary, better pg_search performance, reducing table locks, not valid constraints and better group by statistics.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/350-seven-years-of-scaling-postgres/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Seven Years of Scaling Postgres | Scaling Postgres 350]]>
                </itunes:title>
                                    <itunes:episode>350</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss our seven year anniversary, better pg_search performance, reducing table locks, not valid constraints and better group by statistics.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/350-seven-years-of-scaling-postgres/">https://www.scalingpostgres.com/episodes/350-seven-years-of-scaling-postgres/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1949239/c1e-01qo3sj43w7s6dmx0-dm4x39r9a9r-ud5m2z.mp3" length="36796290"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss our seven year anniversary, better pg_search performance, reducing table locks, not valid constraints and better group by statistics.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/350-seven-years-of-scaling-postgres/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:19:09</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[The Dangers of Temporary Tables | Scaling Postgres 349]]>
                </title>
                <pubDate>Sun, 19 Jan 2025 22:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1945591</guid>
                                    <link>https://www.scalingpostgres.com/episodes/349-the-dangers-of-temporary-tables/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the dangers of temporary tables, better transparent data encryption, pig the extension wizard, and table level lock considerations.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/349-the-dangers-of-temporary-tables/">https://www.scalingpostgres.com/episodes/349-the-dangers-of-temporary-tables/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the dangers of temporary tables, better transparent data encryption, pig the extension wizard, and table level lock considerations.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/349-the-dangers-of-temporary-tables/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[The Dangers of Temporary Tables | Scaling Postgres 349]]>
                </itunes:title>
                                    <itunes:episode>349</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the dangers of temporary tables, better transparent data encryption, pig the extension wizard, and table level lock considerations.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/349-the-dangers-of-temporary-tables/">https://www.scalingpostgres.com/episodes/349-the-dangers-of-temporary-tables/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1945591/c1e-dn309a6qzdouw9d7z-1p45p9kgcq29-0kluj1.mp3" length="29570612"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the dangers of temporary tables, better transparent data encryption, pig the extension wizard, and table level lock considerations.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/349-the-dangers-of-temporary-tables/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:15:24</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[The Future Is Containers? | Scaling Postgres 348]]>
                </title>
                <pubDate>Sun, 12 Jan 2025 22:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1938118</guid>
                                    <link>https://www.scalingpostgres.com/episodes/348-the-future-is-containers/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss whether the future of containers and Postgres, UUIDv7 commit, and a pg_duckdb interview.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/348-the-future-is-containers/">https://www.scalingpostgres.com/episodes/348-the-future-is-containers/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss whether the future of containers and Postgres, UUIDv7 commit, and a pg_duckdb interview.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/348-the-future-is-containers/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[The Future Is Containers? | Scaling Postgres 348]]>
                </itunes:title>
                                    <itunes:episode>348</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss whether the future of containers and Postgres, UUIDv7 commit, and a pg_duckdb interview.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/348-the-future-is-containers/">https://www.scalingpostgres.com/episodes/348-the-future-is-containers/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1938118/c1e-qg23ki2g4m1ajpv5o-0v52g2p8fr9k-alsvbt.mp3" length="23953240"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss whether the future of containers and Postgres, UUIDv7 commit, and a pg_duckdb interview.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/348-the-future-is-containers/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:12:28</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Easy Incremental Data Processing? | Scaling Postgres 347]]>
                </title>
                <pubDate>Sun, 22 Dec 2024 22:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1924245</guid>
                                    <link>https://www.scalingpostgres.com/episodes/347-easy-incremental-data-processing/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the new pg_incremental extension for processing data pipelines, a set of Postgres monitoring queries, handling alter table retries and large object dump performance.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/347-easy-incremental-data-processing/">https://www.scalingpostgres.com/episodes/347-easy-incremental-data-processing/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the new pg_incremental extension for processing data pipelines, a set of Postgres monitoring queries, handling alter table retries and large object dump performance.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/347-easy-incremental-data-processing/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Easy Incremental Data Processing? | Scaling Postgres 347]]>
                </itunes:title>
                                    <itunes:episode>347</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the new pg_incremental extension for processing data pipelines, a set of Postgres monitoring queries, handling alter table retries and large object dump performance.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/347-easy-incremental-data-processing/">https://www.scalingpostgres.com/episodes/347-easy-incremental-data-processing/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1924245/c1e-8vp1zc96xd1tr7d0v-qd48d5rkcvrg-tql6jh.mp3" length="28411193"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the new pg_incremental extension for processing data pipelines, a set of Postgres monitoring queries, handling alter table retries and large object dump performance.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/347-easy-incremental-data-processing/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:14:47</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Things I Don't Do In Postgres | Scaling Postgres 346]]>
                </title>
                <pubDate>Sun, 15 Dec 2024 22:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1920594</guid>
                                    <link>https://www.scalingpostgres.com/episodes/346-things-i-do-not-do-in-postgres/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss things I do not do such as use default partitions, play column Tetris, ELT using special data types or create 7+ millions tables in a database.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/346-things-i-do-not-do-in-postgres/">https://www.scalingpostgres.com/episodes/346-things-i-do-not-do-in-postgres/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss things I do not do such as use default partitions, play column Tetris, ELT using special data types or create 7+ millions tables in a database.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/346-things-i-do-not-do-in-postgres/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Things I Don't Do In Postgres | Scaling Postgres 346]]>
                </itunes:title>
                                    <itunes:episode>346</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss things I do not do such as use default partitions, play column Tetris, ELT using special data types or create 7+ millions tables in a database.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/346-things-i-do-not-do-in-postgres/">https://www.scalingpostgres.com/episodes/346-things-i-do-not-do-in-postgres/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1920594/c1e-674mgh2krqkikmdr2-v6zggkdrbjoo-qcadk5.mp3" length="30319595"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss things I do not do such as use default partitions, play column Tetris, ELT using special data types or create 7+ millions tables in a database.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/346-things-i-do-not-do-in-postgres/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:15:47</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Over 5X Faster Postgres? | Scaling Postgres 345]]>
                </title>
                <pubDate>Sun, 08 Dec 2024 22:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1915470</guid>
                                    <link>https://www.scalingpostgres.com/episodes/345-over-5x-faster-postgres/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss OrioleDB getting Postgres over 5 times faster, historical OLAP performance, efficient queries and whether you should us track_planning.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/345-over-5x-faster-postgres/">https://www.scalingpostgres.com/episodes/345-over-5x-faster-postgres/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss OrioleDB getting Postgres over 5 times faster, historical OLAP performance, efficient queries and whether you should us track_planning.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/345-over-5x-faster-postgres/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Over 5X Faster Postgres? | Scaling Postgres 345]]>
                </itunes:title>
                                    <itunes:episode>345</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss OrioleDB getting Postgres over 5 times faster, historical OLAP performance, efficient queries and whether you should us track_planning.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/345-over-5x-faster-postgres/">https://www.scalingpostgres.com/episodes/345-over-5x-faster-postgres/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1915470/c1e-qg23ki2m6xdujpv5o-ok3xrpr6ux03-ey9frv.mp3" length="32709485"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss OrioleDB getting Postgres over 5 times faster, historical OLAP performance, efficient queries and whether you should us track_planning.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/345-over-5x-faster-postgres/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:17:02</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Performance & Hard Things | Scaling Postgres 344]]>
                </title>
                <pubDate>Sun, 01 Dec 2024 22:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1911176</guid>
                                    <link>https://www.scalingpostgres.com/episodes/344-performance-hard-things/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss new releases, collation speed, ZFS performance, insert benchmarking and pglz vs. lz4 performance.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/344-performance-hard-things/">https://www.scalingpostgres.com/episodes/344-performance-hard-things/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss new releases, collation speed, ZFS performance, insert benchmarking and pglz vs. lz4 performance.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/344-performance-hard-things/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Performance & Hard Things | Scaling Postgres 344]]>
                </itunes:title>
                                    <itunes:episode>344</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss new releases, collation speed, ZFS performance, insert benchmarking and pglz vs. lz4 performance.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/344-performance-hard-things/">https://www.scalingpostgres.com/episodes/344-performance-hard-things/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1911176/c1e-jog81sqz5w8b5v18o-mk16xokkf8d-igrrhe.mp3" length="33857201"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss new releases, collation speed, ZFS performance, insert benchmarking and pglz vs. lz4 performance.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/344-performance-hard-things/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:17:38</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres Release Warning! | Scaling Postgres 343]]>
                </title>
                <pubDate>Sun, 24 Nov 2024 22:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1903997</guid>
                                    <link>https://www.scalingpostgres.com/episodes/343-postgres-release-warning/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss new Postgres releases and an out-of-band release to address issues, increasing insert performance by 2X, pg_search benchmarks and fast OpenStreetMap loading.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/343-postgres-release-warning/">https://www.scalingpostgres.com/episodes/343-postgres-release-warning/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss new Postgres releases and an out-of-band release to address issues, increasing insert performance by 2X, pg_search benchmarks and fast OpenStreetMap loading.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/343-postgres-release-warning/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres Release Warning! | Scaling Postgres 343]]>
                </itunes:title>
                                    <itunes:episode>343</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss new Postgres releases and an out-of-band release to address issues, increasing insert performance by 2X, pg_search benchmarks and fast OpenStreetMap loading.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/343-postgres-release-warning/">https://www.scalingpostgres.com/episodes/343-postgres-release-warning/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1903997/c1e-8vp1zc9gg09fr7d0v-wwmr60okhz42-uzdtap.mp3" length="36181054"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss new Postgres releases and an out-of-band release to address issues, increasing insert performance by 2X, pg_search benchmarks and fast OpenStreetMap loading.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/343-postgres-release-warning/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:18:50</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Faster Writes With ZFS? | Scaling Postgres 342]]>
                </title>
                <pubDate>Sun, 17 Nov 2024 22:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1891420</guid>
                                    <link>https://www.scalingpostgres.com/episodes/342-faster-writes-with-zfs/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the read and write performance of Postgres on ZFS, handling URL text identifiers in the database, denormalization and a new pgvector release.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/342-faster-writes-with-zfs/">https://www.scalingpostgres.com/episodes/342-faster-writes-with-zfs/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the read and write performance of Postgres on ZFS, handling URL text identifiers in the database, denormalization and a new pgvector release.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/342-faster-writes-with-zfs/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Faster Writes With ZFS? | Scaling Postgres 342]]>
                </itunes:title>
                                    <itunes:episode>342</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the read and write performance of Postgres on ZFS, handling URL text identifiers in the database, denormalization and a new pgvector release.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/342-faster-writes-with-zfs/">https://www.scalingpostgres.com/episodes/342-faster-writes-with-zfs/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1891420/c1e-8vp1zc9d6gxfr7d0v-pkjmk8kma0qg-fxl6an.mp3" length="25574922"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the read and write performance of Postgres on ZFS, handling URL text identifiers in the database, denormalization and a new pgvector release.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/342-faster-writes-with-zfs/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:13:19</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[The Future of Postgres Upgrades | Scaling Postgres 341]]>
                </title>
                <pubDate>Sun, 10 Nov 2024 22:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1878401</guid>
                                    <link>https://www.scalingpostgres.com/episodes/341-the-future-of-postgres-upgrades/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the future of Postgres upgrades, the usefulness of pg_dump, partitioning with minimal downtime and limitless Aurora.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/341-the-future-of-postgres-upgrades/">https://www.scalingpostgres.com/episodes/341-the-future-of-postgres-upgrades/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the future of Postgres upgrades, the usefulness of pg_dump, partitioning with minimal downtime and limitless Aurora.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/341-the-future-of-postgres-upgrades/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[The Future of Postgres Upgrades | Scaling Postgres 341]]>
                </itunes:title>
                                    <itunes:episode>341</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the future of Postgres upgrades, the usefulness of pg_dump, partitioning with minimal downtime and limitless Aurora.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/341-the-future-of-postgres-upgrades/">https://www.scalingpostgres.com/episodes/341-the-future-of-postgres-upgrades/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1878401/c1e-k31vzsj09rkag04q3-qd4dqkv5c81n-6krtzl.mp3" length="27388865"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the future of Postgres upgrades, the usefulness of pg_dump, partitioning with minimal downtime and limitless Aurora.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/341-the-future-of-postgres-upgrades/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:14:15</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Do You Need A Vectorizer? | Scaling Postgres 340]]>
                </title>
                <pubDate>Sun, 03 Nov 2024 22:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1872436</guid>
                                    <link>https://www.scalingpostgres.com/episodes/340-do-you-need-a-vectorizer/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss whether you need a vectorizer, different ways to bin or bucket timestamps, addressing a bad plan and advanced psql.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/340-do-you-need-a-vectorizer/">https://www.scalingpostgres.com/episodes/340-do-you-need-a-vectorizer/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss whether you need a vectorizer, different ways to bin or bucket timestamps, addressing a bad plan and advanced psql.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/340-do-you-need-a-vectorizer/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Do You Need A Vectorizer? | Scaling Postgres 340]]>
                </itunes:title>
                                    <itunes:episode>340</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss whether you need a vectorizer, different ways to bin or bucket timestamps, addressing a bad plan and advanced psql.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/340-do-you-need-a-vectorizer/">https://www.scalingpostgres.com/episodes/340-do-you-need-a-vectorizer/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1872436/c1e-7vwg1c46813a5z6j9-qd4p51pxtzxj-myvwet.mp3" length="31999791"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss whether you need a vectorizer, different ways to bin or bucket timestamps, addressing a bad plan and advanced psql.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/340-do-you-need-a-vectorizer/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:16:39</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres Goes Parquet | Scaling Postgres 339]]>
                </title>
                <pubDate>Sun, 27 Oct 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1867448</guid>
                                    <link>https://www.scalingpostgres.com/episodes/339-postgres-goes-parquet/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss pg_parquet allowing Postgres to read and write parquet files, other useful extensions, open source bounties, and Postgres gotchas.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/339-postgres-goes-parquet/">https://www.scalingpostgres.com/episodes/339-postgres-goes-parquet/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss pg_parquet allowing Postgres to read and write parquet files, other useful extensions, open source bounties, and Postgres gotchas.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/339-postgres-goes-parquet/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres Goes Parquet | Scaling Postgres 339]]>
                </itunes:title>
                                    <itunes:episode>339</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss pg_parquet allowing Postgres to read and write parquet files, other useful extensions, open source bounties, and Postgres gotchas.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/339-postgres-goes-parquet/">https://www.scalingpostgres.com/episodes/339-postgres-goes-parquet/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1867448/c1e-xr51ncmoddkakj7q1-8d9o6468imvm-cg7gd1.mp3" length="22144313"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss pg_parquet allowing Postgres to read and write parquet files, other useful extensions, open source bounties, and Postgres gotchas.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/339-postgres-goes-parquet/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:11:32</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[JSON Goodies In Postgres 17 | Scaling Postgres 338]]>
                </title>
                <pubDate>Sun, 20 Oct 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1861207</guid>
                                    <link>https://www.scalingpostgres.com/episodes/338-json-goodies-in-postgres-17/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the JSON goodies in Postgres 17, trigger recursion, pg_dump as backup and pg_timeseries columnar performance.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/338-json-goodies-in-postgres-17/">https://www.scalingpostgres.com/episodes/338-json-goodies-in-postgres-17/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the JSON goodies in Postgres 17, trigger recursion, pg_dump as backup and pg_timeseries columnar performance.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/338-json-goodies-in-postgres-17/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[JSON Goodies In Postgres 17 | Scaling Postgres 338]]>
                </itunes:title>
                                    <itunes:episode>338</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the JSON goodies in Postgres 17, trigger recursion, pg_dump as backup and pg_timeseries columnar performance.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/338-json-goodies-in-postgres-17/">https://www.scalingpostgres.com/episodes/338-json-goodies-in-postgres-17/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1861207/c1e-w9520cr163vs8kg13-mk1j4q23u68q-yefp6s.mp3" length="32740414"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the JSON goodies in Postgres 17, trigger recursion, pg_dump as backup and pg_timeseries columnar performance.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/338-json-goodies-in-postgres-17/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:17:03</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[77 Times Faster In Postgres 17 | Scaling Postgres 337]]>
                </title>
                <pubDate>Sun, 13 Oct 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1856873</guid>
                                    <link>https://www.scalingpostgres.com/episodes/337-77-times-faster-in-postgres-17/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how one query runs 77 times faster in Postgres 17, a detailed Postgres 17 performance webinar, using logical replication fail over slots and a discussion on Patroni.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/337-77-times-faster-in-postgres-17/">https://www.scalingpostgres.com/episodes/337-77-times-faster-in-postgres-17/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how one query runs 77 times faster in Postgres 17, a detailed Postgres 17 performance webinar, using logical replication fail over slots and a discussion on Patroni.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/337-77-times-faster-in-postgres-17/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[77 Times Faster In Postgres 17 | Scaling Postgres 337]]>
                </itunes:title>
                                    <itunes:episode>337</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how one query runs 77 times faster in Postgres 17, a detailed Postgres 17 performance webinar, using logical replication fail over slots and a discussion on Patroni.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/337-77-times-faster-in-postgres-17/">https://www.scalingpostgres.com/episodes/337-77-times-faster-in-postgres-17/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1856873/c1e-n0572b5xzppsqmzx0-0v250g5mbm5z-4v9rxa.mp3" length="27490847"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how one query runs 77 times faster in Postgres 17, a detailed Postgres 17 performance webinar, using logical replication fail over slots and a discussion on Patroni.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/337-77-times-faster-in-postgres-17/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:14:19</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[More Postgres 17 Highlights | Scaling Postgres 336]]>
                </title>
                <pubDate>Sun, 06 Oct 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1851768</guid>
                                    <link>https://www.scalingpostgres.com/episodes/336-more-postgres-17-highlights/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss more about the features released with Postgres 17, an example of performance improvements, things to watch out for, and the start of Postgres 18.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/336-more-postgres-17-highlights/">https://www.scalingpostgres.com/episodes/336-more-postgres-17-highlights/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss more about the features released with Postgres 17, an example of performance improvements, things to watch out for, and the start of Postgres 18.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/336-more-postgres-17-highlights/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[More Postgres 17 Highlights | Scaling Postgres 336]]>
                </itunes:title>
                                    <itunes:episode>336</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss more about the features released with Postgres 17, an example of performance improvements, things to watch out for, and the start of Postgres 18.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><a href="https://www.scalingpostgres.com/episodes/336-more-postgres-17-highlights/">https://www.scalingpostgres.com/episodes/336-more-postgres-17-highlights/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1851768/c1e-2qp9rs8d53riqx7d9-jpj473jwbo6j-iieayz.mp3" length="24789159"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss more about the features released with Postgres 17, an example of performance improvements, things to watch out for, and the start of Postgres 18.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/336-more-postgres-17-highlights/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:12:54</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres 17 Released! | Scaling Postgres 335]]>
                </title>
                <pubDate>Sun, 29 Sep 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1844292</guid>
                                    <link>https://www.scalingpostgres.com/episodes/335-postgres-17-released/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the release of Postgres 17, b-tree performance gains, logical replication enhancements and different levels of performance tuning.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <a href="https://www.scalingpostgres.com/episodes/335-postgres-17-released/">https://www.scalingpostgres.com/episodes/335-postgres-17-released/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the release of Postgres 17, b-tree performance gains, logical replication enhancements and different levels of performance tuning.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/335-postgres-17-released/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres 17 Released! | Scaling Postgres 335]]>
                </itunes:title>
                                    <itunes:episode>335</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the release of Postgres 17, b-tree performance gains, logical replication enhancements and different levels of performance tuning.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <a href="https://www.scalingpostgres.com/episodes/335-postgres-17-released/">https://www.scalingpostgres.com/episodes/335-postgres-17-released/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1844292/c1e-w9520cr8k2qt8kg13-ndw99785c5g-noe3xm.mp3" length="35609286"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the release of Postgres 17, b-tree performance gains, logical replication enhancements and different levels of performance tuning.
To get the show notes as well as get notified of new episodes, visit: https://www.scalingpostgres.com/episodes/335-postgres-17-released/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:18:32</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Optimizing For Analytics | Scaling Postgres 334]]>
                </title>
                <pubDate>Sun, 22 Sep 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1839311</guid>
                                    <link>https://www.scalingpostgres.com/episodes/334-optimizing-for-analytics/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to optimize your database for analytics, how to speed up counts, improvements to TimescaleDB and why you should stop using serial.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/334-optimizing-for-analytics/">https://www.scalingpostgres.com/episodes/334-optimizing-for-analytics/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to optimize your database for analytics, how to speed up counts, improvements to TimescaleDB and why you should stop using serial.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/334-optimizing-for-analytics/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Optimizing For Analytics | Scaling Postgres 334]]>
                </itunes:title>
                                    <itunes:episode>334</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to optimize your database for analytics, how to speed up counts, improvements to TimescaleDB and why you should stop using serial.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/334-optimizing-for-analytics/">https://www.scalingpostgres.com/episodes/334-optimizing-for-analytics/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1839311/c1e-pm5o7t5dp57bq8o3n-gp2oon9ptoxg-3byr2u.mp3" length="42111895"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to optimize your database for analytics, how to speed up counts, improvements to TimescaleDB and why you should stop using serial.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/334-optimizing-for-analytics/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:21:55</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[When Select Writes! | Scaling Postgres 333]]>
                </title>
                <pubDate>Sun, 15 Sep 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1834380</guid>
                                    <link>https://www.scalingpostgres.com/episodes/333-when-select-writes/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss when select can write, Postgres RC1 is released, Tetris in SQL and copy, swap, drop.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/333-when-select-writes/">https://www.scalingpostgres.com/episodes/333-when-select-writes/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss when select can write, Postgres RC1 is released, Tetris in SQL and copy, swap, drop.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/333-when-select-writes/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[When Select Writes! | Scaling Postgres 333]]>
                </itunes:title>
                                    <itunes:episode>333</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss when select can write, Postgres RC1 is released, Tetris in SQL and copy, swap, drop.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/333-when-select-writes/">https://www.scalingpostgres.com/episodes/333-when-select-writes/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1834380/c1e-mr25vcn8pp8hg2qrv-kp2g26zwhj0-b9plom.mp3" length="26179291"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss when select can write, Postgres RC1 is released, Tetris in SQL and copy, swap, drop.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/333-when-select-writes/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:13:38</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Sometimes It Is Slow? | Scaling Postgres 332]]>
                </title>
                <pubDate>Sun, 08 Sep 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1830298</guid>
                                    <link>https://www.scalingpostgres.com/episodes/332-sometimes-it-is-slow/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss what can happen when queries get slow, backup best practices, Postgres emergencies and the state of Postgres survey.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/332-sometimes-it-is-slow/">https://www.scalingpostgres.com/episodes/332-sometimes-it-is-slow/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss what can happen when queries get slow, backup best practices, Postgres emergencies and the state of Postgres survey.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/332-sometimes-it-is-slow/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Sometimes It Is Slow? | Scaling Postgres 332]]>
                </itunes:title>
                                    <itunes:episode>332</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss what can happen when queries get slow, backup best practices, Postgres emergencies and the state of Postgres survey.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/332-sometimes-it-is-slow/">https://www.scalingpostgres.com/episodes/332-sometimes-it-is-slow/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1830298/c1e-qg23ki2jk9vtjpv5o-rk0x3vw6b923-8m4zvh.mp3" length="29121724"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss what can happen when queries get slow, backup best practices, Postgres emergencies and the state of Postgres survey.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/332-sometimes-it-is-slow/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:15:10</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Is pg_dump A Backup Tool? | Scaling Postgres 331]]>
                </title>
                <pubDate>Sun, 01 Sep 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1826421</guid>
                                    <link>https://www.scalingpostgres.com/episodes/331-is-pg_dump-a-backup-tool/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss whether pg_dump is a backup tool, the pgMonitor extension, Postgres malware, and application uses for the merge command.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/331-is-pg_dump-a-backup-tool/">https://www.scalingpostgres.com/episodes/331-is-pg_dump-a-backup-tool/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss whether pg_dump is a backup tool, the pgMonitor extension, Postgres malware, and application uses for the merge command.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/331-is-pg_dump-a-backup-tool/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Is pg_dump A Backup Tool? | Scaling Postgres 331]]>
                </itunes:title>
                                    <itunes:episode>331</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss whether pg_dump is a backup tool, the pgMonitor extension, Postgres malware, and application uses for the merge command.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/331-is-pg_dump-a-backup-tool/">https://www.scalingpostgres.com/episodes/331-is-pg_dump-a-backup-tool/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1826421/c1e-9vpz8cnmwx8iw3vgk-wwz3w79nboj5-q9eq5o.mp3" length="33637355"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss whether pg_dump is a backup tool, the pgMonitor extension, Postgres malware, and application uses for the merge command.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/331-is-pg_dump-a-backup-tool/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:17:31</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Splicing Elephant & Duck DNA | Scaling Postgres 330]]>
                </title>
                <pubDate>Sun, 25 Aug 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1819227</guid>
                                    <link>https://www.scalingpostgres.com/episodes/330-splicing-elephant-and-duck-dna/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the merging of Postgres and DuckDB via the pg_duckdb extension, how this can help the analytics story for Postgres, some ways to improve PG analytics and building a search engine.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/330-splicing-elephant-and-duck-dna/">https://www.scalingpostgres.com/episodes/330-splicing-elephant-and-duck-dna/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the merging of Postgres and DuckDB via the pg_duckdb extension, how this can help the analytics story for Postgres, some ways to improve PG analytics and building a search engine.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/330-splicing-elephant-and-duck-dna/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Splicing Elephant & Duck DNA | Scaling Postgres 330]]>
                </itunes:title>
                                    <itunes:episode>330</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the merging of Postgres and DuckDB via the pg_duckdb extension, how this can help the analytics story for Postgres, some ways to improve PG analytics and building a search engine.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/330-splicing-elephant-and-duck-dna/">https://www.scalingpostgres.com/episodes/330-splicing-elephant-and-duck-dna/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1819227/c1e-r159xsjkr9mf7zkrx-34ko41x2fmn6-pytwpl.mp3" length="28766458"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the merging of Postgres and DuckDB via the pg_duckdb extension, how this can help the analytics story for Postgres, some ways to improve PG analytics and building a search engine.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/330-splicing-elephant-and-duck-dna/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:14:58</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[PGlite: Embeddable Postgres & postgres.new | Scaling Postgres 329]]>
                </title>
                <pubDate>Sun, 18 Aug 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1813008</guid>
                                    <link>https://www.scalingpostgres.com/episodes/329-pglite-embeddable-postgres/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss PGlite, an embeddable Postgres, postgres.new which adds AI features, new Postgres releases and the performance of synchronous replication.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/329-pglite-embeddable-postgres/">https://www.scalingpostgres.com/episodes/329-pglite-embeddable-postgres/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss PGlite, an embeddable Postgres, postgres.new which adds AI features, new Postgres releases and the performance of synchronous replication.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/329-pglite-embeddable-postgres/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[PGlite: Embeddable Postgres & postgres.new | Scaling Postgres 329]]>
                </itunes:title>
                                    <itunes:episode>329</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss PGlite, an embeddable Postgres, postgres.new which adds AI features, new Postgres releases and the performance of synchronous replication.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/329-pglite-embeddable-postgres/">https://www.scalingpostgres.com/episodes/329-pglite-embeddable-postgres/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1813008/c1e-2qp9rs8v0zriqx7d9-25dq64rzcz1m-nlnzgd.mp3" length="36532140"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss PGlite, an embeddable Postgres, postgres.new which adds AI features, new Postgres releases and the performance of synchronous replication.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/329-pglite-embeddable-postgres/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:19:01</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Implement Get Or Create | Scaling Postgres 328]]>
                </title>
                <pubDate>Sun, 11 Aug 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1804819</guid>
                                    <link>https://www.scalingpostgres.com/episodes/328-implement-get-or-create/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss different get or create implementations, a new pgBouncer version, alter default privileges, and six degrees of separation with Postgres.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/328-implement-get-or-create/">https://www.scalingpostgres.com/episodes/328-implement-get-or-create/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss different get or create implementations, a new pgBouncer version, alter default privileges, and six degrees of separation with Postgres.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/328-implement-get-or-create/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Implement Get Or Create | Scaling Postgres 328]]>
                </itunes:title>
                                    <itunes:episode>328</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss different get or create implementations, a new pgBouncer version, alter default privileges, and six degrees of separation with Postgres.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/328-implement-get-or-create/">https://www.scalingpostgres.com/episodes/328-implement-get-or-create/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1804819/c1e-7vwg1c48xrpt5z6j9-wwzj87rotg0w-zgjd7k.mp3" length="31061890"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss different get or create implementations, a new pgBouncer version, alter default privileges, and six degrees of separation with Postgres.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/328-implement-get-or-create/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:16:10</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres Graph Queries | Scaling Postgres 327]]>
                </title>
                <pubDate>Sun, 04 Aug 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1797840</guid>
                                    <link>https://www.scalingpostgres.com/episodes/327-postgres-graph-queries/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss using Postgres for graph queries, the fastest way to copy data from one table to another, dealing with linux memory overcommit and compression.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/327-postgres-graph-queries/">https://www.scalingpostgres.com/episodes/327-postgres-graph-queries/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss using Postgres for graph queries, the fastest way to copy data from one table to another, dealing with linux memory overcommit and compression.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/327-postgres-graph-queries/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres Graph Queries | Scaling Postgres 327]]>
                </itunes:title>
                                    <itunes:episode>327</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss using Postgres for graph queries, the fastest way to copy data from one table to another, dealing with linux memory overcommit and compression.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/327-postgres-graph-queries/">https://www.scalingpostgres.com/episodes/327-postgres-graph-queries/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1797840/c1e-01qo3sjdrk3b6dmx0-gp2d3298ajnw-gevnoo.mp3" length="31683813"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss using Postgres for graph queries, the fastest way to copy data from one table to another, dealing with linux memory overcommit and compression.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/327-postgres-graph-queries/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:16:30</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Faster Index Creation | Scaling Postgres 326]]>
                </title>
                <pubDate>Sun, 28 Jul 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1793200</guid>
                                    <link>https://www.scalingpostgres.com/episodes/326-faster-index-creation/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we talk about speeding up index creation, extensions to track wait events, a row pattern recognition feature and savepoints.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/326-faster-index-creation/">https://www.scalingpostgres.com/episodes/326-faster-index-creation/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we talk about speeding up index creation, extensions to track wait events, a row pattern recognition feature and savepoints.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/326-faster-index-creation/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Faster Index Creation | Scaling Postgres 326]]>
                </itunes:title>
                                    <itunes:episode>326</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we talk about speeding up index creation, extensions to track wait events, a row pattern recognition feature and savepoints.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/326-faster-index-creation/">https://www.scalingpostgres.com/episodes/326-faster-index-creation/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1793200/c1e-8vp1zc9zgxdcr7d0v-34kxq1r3bwdj-xeqtr9.mp3" length="39315748"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we talk about speeding up index creation, extensions to track wait events, a row pattern recognition feature and savepoints.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/326-faster-index-creation/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:20:28</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Faster Paging? | Scaling Postgres 325]]>
                </title>
                <pubDate>Sun, 21 Jul 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1789354</guid>
                                    <link>https://www.scalingpostgres.com/episodes/325-faster-paging/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss more ways to keep the superior performance of keyset pagination, how to implement UUIDv7 in SQL functions, how expensive extended statistics are and the benefits of range columns.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/325-faster-paging/">https://www.scalingpostgres.com/episodes/325-faster-paging/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss more ways to keep the superior performance of keyset pagination, how to implement UUIDv7 in SQL functions, how expensive extended statistics are and the benefits of range columns.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/325-faster-paging/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Faster Paging? | Scaling Postgres 325]]>
                </itunes:title>
                                    <itunes:episode>325</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss more ways to keep the superior performance of keyset pagination, how to implement UUIDv7 in SQL functions, how expensive extended statistics are and the benefits of range columns.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/325-faster-paging/">https://www.scalingpostgres.com/episodes/325-faster-paging/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1789354/c1e-9vpz8cn6jmjaw3vgk-0vdpo634bjw-ehzmjl.mp3" length="38652865"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss more ways to keep the superior performance of keyset pagination, how to implement UUIDv7 in SQL functions, how expensive extended statistics are and the benefits of range columns.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/325-faster-paging/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:20:07</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Four Million TPS | Scaling Postgres 324]]>
                </title>
                <pubDate>Sun, 14 Jul 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1785672</guid>
                                    <link>https://www.scalingpostgres.com/episodes/324-four-million-tps/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss experiments to achieve four million transaction per second, the importance of extended statistics, parallelism in Postgres and an introduction to window functions.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/324-four-million-tps/">https://www.scalingpostgres.com/episodes/324-four-million-tps/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss experiments to achieve four million transaction per second, the importance of extended statistics, parallelism in Postgres and an introduction to window functions.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/324-four-million-tps/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Four Million TPS | Scaling Postgres 324]]>
                </itunes:title>
                                    <itunes:episode>324</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss experiments to achieve four million transaction per second, the importance of extended statistics, parallelism in Postgres and an introduction to window functions.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/324-four-million-tps/">https://www.scalingpostgres.com/episodes/324-four-million-tps/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1785672/c1e-zn68gamd85wh1xkz2-dm64q47vf165-q866zc.mp3" length="31657900"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss experiments to achieve four million transaction per second, the importance of extended statistics, parallelism in Postgres and an introduction to window functions.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/324-four-million-tps/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:16:29</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[PgBouncer Breaking Change | Scaling Postgres 323]]>
                </title>
                <pubDate>Sun, 07 Jul 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1780910</guid>
                                    <link>https://www.scalingpostgres.com/episodes/323-pgbouncer-breaking-change/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss a breaking change in the new version of PgBouncer, PostgreSQL 17 Beta 2 is released, examination of the new built-in collation provider in PG 17 and Notion's data lake.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/323-pgbouncer-breaking-change/">https://www.scalingpostgres.com/episodes/323-pgbouncer-breaking-change/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a breaking change in the new version of PgBouncer, PostgreSQL 17 Beta 2 is released, examination of the new built-in collation provider in PG 17 and Notion's data lake.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/323-pgbouncer-breaking-change/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[PgBouncer Breaking Change | Scaling Postgres 323]]>
                </itunes:title>
                                    <itunes:episode>323</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss a breaking change in the new version of PgBouncer, PostgreSQL 17 Beta 2 is released, examination of the new built-in collation provider in PG 17 and Notion's data lake.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/323-pgbouncer-breaking-change/">https://www.scalingpostgres.com/episodes/323-pgbouncer-breaking-change/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1780910/c1e-jog81sq8x3vs5v18o-jp449mdxi6ov-uoqcul.mp3" length="45682938"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a breaking change in the new version of PgBouncer, PostgreSQL 17 Beta 2 is released, examination of the new built-in collation provider in PG 17 and Notion's data lake.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/323-pgbouncer-breaking-change/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:23:47</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres Sort Instability? | Scaling Postgres 322]]>
                </title>
                <pubDate>Sun, 30 Jun 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1773881</guid>
                                    <link>https://www.scalingpostgres.com/episodes/322-postgres-sort-instability/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss an incremental sort instability issue with the Postgres planner, whether we should use foreign keys, how the visibility map works and how to vacuum the template0 database.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/322-postgres-sort-instability/">https://www.scalingpostgres.com/episodes/322-postgres-sort-instability/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss an incremental sort instability issue with the Postgres planner, whether we should use foreign keys, how the visibility map works and how to vacuum the template0 database.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/322-postgres-sort-instability/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres Sort Instability? | Scaling Postgres 322]]>
                </itunes:title>
                                    <itunes:episode>322</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss an incremental sort instability issue with the Postgres planner, whether we should use foreign keys, how the visibility map works and how to vacuum the template0 database.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/322-postgres-sort-instability/">https://www.scalingpostgres.com/episodes/322-postgres-sort-instability/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1773881/c1e-mr25vcnd4m2sg2qrv-wnggzqq8cx1z-krxcnx.mp3" length="38047660"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss an incremental sort instability issue with the Postgres planner, whether we should use foreign keys, how the visibility map works and how to vacuum the template0 database.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/322-postgres-sort-instability/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:19:48</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Ottertune Is Dead! | Scaling Postgres 321]]>
                </title>
                <pubDate>Sun, 23 Jun 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1767930</guid>
                                    <link>https://www.scalingpostgres.com/episodes/321-ottertune-is-dead/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the shutdown of Ottertune, how schema changes cause locks and how to avoid them, the benefits of on conflic do nothing, and pgvectorscale.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/321-ottertune-is-dead/">https://www.scalingpostgres.com/episodes/321-ottertune-is-dead/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the shutdown of Ottertune, how schema changes cause locks and how to avoid them, the benefits of on conflic do nothing, and pgvectorscale.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/321-ottertune-is-dead/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Ottertune Is Dead! | Scaling Postgres 321]]>
                </itunes:title>
                                    <itunes:episode>321</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the shutdown of Ottertune, how schema changes cause locks and how to avoid them, the benefits of on conflic do nothing, and pgvectorscale.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/321-ottertune-is-dead/">https://www.scalingpostgres.com/episodes/321-ottertune-is-dead/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1767930/c1e-7vwg1c4vjv1i5z6j9-60k53p8dhw9m-eff37y.mp3" length="21203905"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the shutdown of Ottertune, how schema changes cause locks and how to avoid them, the benefits of on conflic do nothing, and pgvectorscale.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/321-ottertune-is-dead/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:11:02</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[100 TB and Beyond! | Scaling Postgres 320]]>
                </title>
                <pubDate>Sun, 16 Jun 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1762818</guid>
                                    <link>https://www.scalingpostgres.com/episodes/320-100tb-and-beyond/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss three organizations scaling their databases to 100 TB and beyond, collation speed, configuring memory and new AI extensions</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/320-100tb-and-beyond/">https://www.scalingpostgres.com/episodes/320-100tb-and-beyond/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>
<p> </p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss three organizations scaling their databases to 100 TB and beyond, collation speed, configuring memory and new AI extensions
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/320-100tb-and-beyond/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/
 
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[100 TB and Beyond! | Scaling Postgres 320]]>
                </itunes:title>
                                    <itunes:episode>320</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss three organizations scaling their databases to 100 TB and beyond, collation speed, configuring memory and new AI extensions</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/320-100tb-and-beyond/">https://www.scalingpostgres.com/episodes/320-100tb-and-beyond/</a></p>
<p>Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: <a href="https://www.scalingpostgres.com/courses/postgres-performance-demystified/">https://www.scalingpostgres.com/courses/postgres-performance-demystified/</a></p>
<p> </p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1762818/c1e-n0572b5zqowhqmzx0-7nq68pn0fvp1-shu0yi.mp3" length="33693361"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss three organizations scaling their databases to 100 TB and beyond, collation speed, configuring memory and new AI extensions
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/320-100tb-and-beyond/
Want to learn more about Postgres performance? Join my FREE training called Postgres Performance Demystified here: https://www.scalingpostgres.com/courses/postgres-performance-demystified/
 
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:17:32</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[When Postgres Development Stopped! | Scaling Postgres 319]]>
                </title>
                <pubDate>Sun, 09 Jun 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1758467</guid>
                                    <link>https://www.scalingpostgres.com/episodes/319-when-postgres-development-stoppped/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss a time when Postgres development stopped, two new extensions pg_lakehouse &amp; pg_compare and the upcoming event Posette.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/319-when-postgres-development-stoppped/">https://www.scalingpostgres.com/episodes/319-when-postgres-development-stoppped/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a time when Postgres development stopped, two new extensions pg_lakehouse & pg_compare and the upcoming event Posette.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/319-when-postgres-development-stoppped/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[When Postgres Development Stopped! | Scaling Postgres 319]]>
                </itunes:title>
                                    <itunes:episode>319</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss a time when Postgres development stopped, two new extensions pg_lakehouse &amp; pg_compare and the upcoming event Posette.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/319-when-postgres-development-stoppped/">https://www.scalingpostgres.com/episodes/319-when-postgres-development-stoppped/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1758467/c1e-4qp0ns48gv5h82pd0-9248pp3jf2xz-du8jpv.mp3" length="23218468"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a time when Postgres development stopped, two new extensions pg_lakehouse & pg_compare and the upcoming event Posette.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/319-when-postgres-development-stoppped/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:12:05</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres 17 Beta 1 Released | Scaling Postgres 318]]>
                </title>
                <pubDate>Sun, 02 Jun 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1753896</guid>
                                    <link>https://www.scalingpostgres.com/episodes/318-postgres-17-beta-1-released/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss all the new features in Postgres 17 Beta 1, some features that did not make it, database collations &amp; sorting and causes of slow commits.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/318-postgres-17-beta-1-released/">https://www.scalingpostgres.com/episodes/318-postgres-17-beta-1-released/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss all the new features in Postgres 17 Beta 1, some features that did not make it, database collations & sorting and causes of slow commits.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/318-postgres-17-beta-1-released/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres 17 Beta 1 Released | Scaling Postgres 318]]>
                </itunes:title>
                                    <itunes:episode>318</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss all the new features in Postgres 17 Beta 1, some features that did not make it, database collations &amp; sorting and causes of slow commits.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/318-postgres-17-beta-1-released/">https://www.scalingpostgres.com/episodes/318-postgres-17-beta-1-released/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1753896/c1e-674mgh2o4mghkmdr2-qxj637r8sdd2-cwlus5.mp3" length="34387173"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss all the new features in Postgres 17 Beta 1, some features that did not make it, database collations & sorting and causes of slow commits.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/318-postgres-17-beta-1-released/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:17:54</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Time-Series Open Source Extension | Scaling Postgres 317]]>
                </title>
                <pubDate>Sun, 26 May 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1748929</guid>
                                    <link>https://www.scalingpostgres.com/episodes/317-time-series-open-source-extension/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss a new time-series open source extension called pg_timeseries, Postgres ignoring indexes, JSONB selectivity issues, and geographically distributed multi-tenant applications.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/317-time-series-open-source-extension/">https://www.scalingpostgres.com/episodes/317-time-series-open-source-extension/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a new time-series open source extension called pg_timeseries, Postgres ignoring indexes, JSONB selectivity issues, and geographically distributed multi-tenant applications.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/317-time-series-open-source-extension/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Time-Series Open Source Extension | Scaling Postgres 317]]>
                </itunes:title>
                                    <itunes:episode>317</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss a new time-series open source extension called pg_timeseries, Postgres ignoring indexes, JSONB selectivity issues, and geographically distributed multi-tenant applications.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/317-time-series-open-source-extension/">https://www.scalingpostgres.com/episodes/317-time-series-open-source-extension/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1748929/c1e-3vqr0c5kpn3fwgqox-rowjvxx1smxn-tn4ejc.mp3" length="28695405"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a new time-series open source extension called pg_timeseries, Postgres ignoring indexes, JSONB selectivity issues, and geographically distributed multi-tenant applications.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/317-time-series-open-source-extension/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:14:56</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[New Releases & 1,000 Times Faster Query | Scaling Postgres 316]]>
                </title>
                <pubDate>Sun, 19 May 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1744406</guid>
                                    <link>https://www.scalingpostgres.com/episodes/316-new-releases-1000-times-faster-query/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss new Postgres releases, optimizing a query to be 1,000 times faster, custom vs. generic plans and the pgtt extension.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/316-new-releases-1000-times-faster-query/">https://www.scalingpostgres.com/episodes/316-new-releases-1000-times-faster-query/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss new Postgres releases, optimizing a query to be 1,000 times faster, custom vs. generic plans and the pgtt extension.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/316-new-releases-1000-times-faster-query/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[New Releases & 1,000 Times Faster Query | Scaling Postgres 316]]>
                </itunes:title>
                                    <itunes:episode>316</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss new Postgres releases, optimizing a query to be 1,000 times faster, custom vs. generic plans and the pgtt extension.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/316-new-releases-1000-times-faster-query/">https://www.scalingpostgres.com/episodes/316-new-releases-1000-times-faster-query/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1744406/c1e-xr51ncm9p4qbkj7q1-k5m1dd8guq9j-fg96vd.mp3" length="27990726"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss new Postgres releases, optimizing a query to be 1,000 times faster, custom vs. generic plans and the pgtt extension.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/316-new-releases-1000-times-faster-query/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:14:34</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Hacking On Postgres is Hard! | Scaling Postgres 315]]>
                </title>
                <pubDate>Sun, 12 May 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1739609</guid>
                                    <link>https://www.scalingpostgres.com/episodes/315-hacking-on-postgres-is-hard/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how hacking on Postgres is hard, a notifier pattern for using Listen/Notify, using histograms for metrics and saturated arithmetic.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/315-hacking-on-postgres-is-hard/">https://www.scalingpostgres.com/episodes/315-hacking-on-postgres-is-hard/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how hacking on Postgres is hard, a notifier pattern for using Listen/Notify, using histograms for metrics and saturated arithmetic.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/315-hacking-on-postgres-is-hard/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Hacking On Postgres is Hard! | Scaling Postgres 315]]>
                </itunes:title>
                                    <itunes:episode>315</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how hacking on Postgres is hard, a notifier pattern for using Listen/Notify, using histograms for metrics and saturated arithmetic.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/315-hacking-on-postgres-is-hard/">https://www.scalingpostgres.com/episodes/315-hacking-on-postgres-is-hard/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1739609/c1e-9vpz8cnnxqvbw3vgk-rownxgv8hk1r-x45eo3.mp3" length="37474220"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how hacking on Postgres is hard, a notifier pattern for using Listen/Notify, using histograms for metrics and saturated arithmetic.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/315-hacking-on-postgres-is-hard/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:19:31</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[150 Times Faster pgvector? | Scaling Postgres 314]]>
                </title>
                <pubDate>Sun, 05 May 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1733162</guid>
                                    <link>https://www.scalingpostgres.com/episodes/314-150-times-faster-pgvector/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss performance improvements for pgvector 0.7.0, a guide to vector embeddings, building a Retrieval Augmented Generation app and only allow logins to replicas.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/314-150-times-faster-pgvector/">https://www.scalingpostgres.com/episodes/314-150-times-faster-pgvector/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss performance improvements for pgvector 0.7.0, a guide to vector embeddings, building a Retrieval Augmented Generation app and only allow logins to replicas.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/314-150-times-faster-pgvector/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[150 Times Faster pgvector? | Scaling Postgres 314]]>
                </itunes:title>
                                    <itunes:episode>314</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss performance improvements for pgvector 0.7.0, a guide to vector embeddings, building a Retrieval Augmented Generation app and only allow logins to replicas.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/314-150-times-faster-pgvector/">https://www.scalingpostgres.com/episodes/314-150-times-faster-pgvector/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1733162/c1e-7vwg1c44rdqi5z6j9-33z34ppwskmz-plqdub.mp3" length="31687993"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss performance improvements for pgvector 0.7.0, a guide to vector embeddings, building a Retrieval Augmented Generation app and only allow logins to replicas.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/314-150-times-faster-pgvector/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:16:30</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[The Future of MySQL is Postgres? | Scaling Postgres 313]]>
                </title>
                <pubDate>Sun, 28 Apr 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1728742</guid>
                                    <link>https://www.scalingpostgres.com/episodes/313-the-future-of-mysql-is-postgres/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss whether the future of MySQL is Postgres, how to use recursive CTEs, work on OrioleDB, and PG17 performance improvements.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/313-the-future-of-mysql-is-postgres/">https://www.scalingpostgres.com/episodes/313-the-future-of-mysql-is-postgres/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss whether the future of MySQL is Postgres, how to use recursive CTEs, work on OrioleDB, and PG17 performance improvements.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/313-the-future-of-mysql-is-postgres/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[The Future of MySQL is Postgres? | Scaling Postgres 313]]>
                </itunes:title>
                                    <itunes:episode>313</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss whether the future of MySQL is Postgres, how to use recursive CTEs, work on OrioleDB, and PG17 performance improvements.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/313-the-future-of-mysql-is-postgres/">https://www.scalingpostgres.com/episodes/313-the-future-of-mysql-is-postgres/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1728742/c1e-7vwg1c44g9oc5z6j9-2og0xx4nu0p4-y6wotk.mp3" length="29876558"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss whether the future of MySQL is Postgres, how to use recursive CTEs, work on OrioleDB, and PG17 performance improvements.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/313-the-future-of-mysql-is-postgres/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:15:33</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres 17 Commit-orama | Scaling Postgres 312]]>
                </title>
                <pubDate>Sun, 21 Apr 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1724534</guid>
                                    <link>https://www.scalingpostgres.com/episodes/312-postgres-17-commit-orama/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we cover potential features in Postgres 17 such as explain serialize, verbose copy, pg_buffer_cache_evict, as well as many others.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/312-postgres-17-commit-orama/">https://www.scalingpostgres.com/episodes/312-postgres-17-commit-orama/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we cover potential features in Postgres 17 such as explain serialize, verbose copy, pg_buffer_cache_evict, as well as many others.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/312-postgres-17-commit-orama/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres 17 Commit-orama | Scaling Postgres 312]]>
                </itunes:title>
                                    <itunes:episode>312</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we cover potential features in Postgres 17 such as explain serialize, verbose copy, pg_buffer_cache_evict, as well as many others.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/312-postgres-17-commit-orama/">https://www.scalingpostgres.com/episodes/312-postgres-17-commit-orama/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1724534/c1e-ondx5av9q6ohdwnqp-924q87kxb5nr-yofkgo.mp3" length="24895320"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we cover potential features in Postgres 17 such as explain serialize, verbose copy, pg_buffer_cache_evict, as well as many others.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/312-postgres-17-commit-orama/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:12:57</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[1,400 Times Faster Max & Group By Performance | Scaling Postgres 311]]>
                </title>
                <pubDate>Sun, 14 Apr 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1719490</guid>
                                    <link>https://www.scalingpostgres.com/episodes/311-max-group-by-performance/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss a 1,400 times faster max and group by implementation, new quantization capabilities in pgvector, adaptive radix trees and splitting &amp; merging partitions in PG17.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/311-max-group-by-performance/">https://www.scalingpostgres.com/episodes/311-max-group-by-performance/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a 1,400 times faster max and group by implementation, new quantization capabilities in pgvector, adaptive radix trees and splitting & merging partitions in PG17.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/311-max-group-by-performance/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[1,400 Times Faster Max & Group By Performance | Scaling Postgres 311]]>
                </itunes:title>
                                    <itunes:episode>311</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss a 1,400 times faster max and group by implementation, new quantization capabilities in pgvector, adaptive radix trees and splitting &amp; merging partitions in PG17.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/311-max-group-by-performance/">https://www.scalingpostgres.com/episodes/311-max-group-by-performance/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1719490/c1e-mr25vcnz5n1tg2qrv-04rkpvq4s8n8-3i4dwq.mp3" length="36230373"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a 1,400 times faster max and group by implementation, new quantization capabilities in pgvector, adaptive radix trees and splitting & merging partitions in PG17.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/311-max-group-by-performance/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:18:52</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Andres, Microsoft & Postgres Save Linux? | Scaling Postgres 310]]>
                </title>
                <pubDate>Sun, 07 Apr 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1713319</guid>
                                    <link>https://www.scalingpostgres.com/episodes/310-andres-microsoft-postgres-save-linux/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss whether Postgres will pull a Redis, remembering Simon Riggs, built-in collation provider and C.UTF-8 in PG 17 and health checks.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/310-andres-microsoft-postgres-save-linux/">https://www.scalingpostgres.com/episodes/310-andres-microsoft-postgres-save-linux/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss whether Postgres will pull a Redis, remembering Simon Riggs, built-in collation provider and C.UTF-8 in PG 17 and health checks.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/310-andres-microsoft-postgres-save-linux/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Andres, Microsoft & Postgres Save Linux? | Scaling Postgres 310]]>
                </itunes:title>
                                    <itunes:episode>310</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss whether Postgres will pull a Redis, remembering Simon Riggs, built-in collation provider and C.UTF-8 in PG 17 and health checks.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/310-andres-microsoft-postgres-save-linux/">https://www.scalingpostgres.com/episodes/310-andres-microsoft-postgres-save-linux/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1713319/c1e-w9520crz5qvf8kg13-8m69q4qrbo1v-pu4tn9.mp3" length="24820924"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss whether Postgres will pull a Redis, remembering Simon Riggs, built-in collation provider and C.UTF-8 in PG 17 and health checks.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/310-andres-microsoft-postgres-save-linux/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:12:55</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Will Postgres Pull A Redis? | Scaling Postgres 309]]>
                </title>
                <pubDate>Sun, 31 Mar 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1709444</guid>
                                    <link>https://www.scalingpostgres.com/episodes/309-will-postgres-pull-a-redis/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss whether Postgres will pull a Redis, remembering Simon Riggs, built-in collation provider and C.UTF-8 in PG 17 and health checks.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/309-will-postgres-pull-a-redis/">https://www.scalingpostgres.com/episodes/309-will-postgres-pull-a-redis/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss whether Postgres will pull a Redis, remembering Simon Riggs, built-in collation provider and C.UTF-8 in PG 17 and health checks.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/309-will-postgres-pull-a-redis/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Will Postgres Pull A Redis? | Scaling Postgres 309]]>
                </itunes:title>
                                    <itunes:episode>309</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss whether Postgres will pull a Redis, remembering Simon Riggs, built-in collation provider and C.UTF-8 in PG 17 and health checks.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/309-will-postgres-pull-a-redis/">https://www.scalingpostgres.com/episodes/309-will-postgres-pull-a-redis/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1709444/c1e-g10gns3wo1kuwp435-1xgnvgn0ir1-tpxmfu.mp3" length="29184418"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss whether Postgres will pull a Redis, remembering Simon Riggs, built-in collation provider and C.UTF-8 in PG 17 and health checks.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/309-will-postgres-pull-a-redis/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:15:12</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Scale Through Sharding | Scaling Postgres 308]]>
                </title>
                <pubDate>Sun, 24 Mar 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1695716</guid>
                                    <link>https://www.scalingpostgres.com/episodes/308-scale-through-sharding/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss high availability's future, a custom sharding solution by Figma, sharding pg_vector queries, and PG17 logical replication failover.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/308-scale-through-sharding/">https://www.scalingpostgres.com/episodes/308-scale-through-sharding/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss high availability's future, a custom sharding solution by Figma, sharding pg_vector queries, and PG17 logical replication failover.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/308-scale-through-sharding/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Scale Through Sharding | Scaling Postgres 308]]>
                </itunes:title>
                                    <itunes:episode>308</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss high availability's future, a custom sharding solution by Figma, sharding pg_vector queries, and PG17 logical replication failover.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/308-scale-through-sharding/">https://www.scalingpostgres.com/episodes/308-scale-through-sharding/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1695716/c1e-k31vzsjr02nhg04q3-2o1zprgpi6w5-aiczgo.mp3" length="35047549"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss high availability's future, a custom sharding solution by Figma, sharding pg_vector queries, and PG17 logical replication failover.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/308-scale-through-sharding/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:18:15</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Collation Conundrum | Scaling Postgres 307]]>
                </title>
                <pubDate>Sun, 17 Mar 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1689784</guid>
                                    <link>https://www.scalingpostgres.com/episodes/307-collation-conundrum/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss whether we should be using bytewise or linguistic ordering by default, how to transform data in Postgres, benefits of a transaction_timeout and how to enforce join order.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/307-collation-conundrum/">https://www.scalingpostgres.com/episodes/307-collation-conundrum/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss whether we should be using bytewise or linguistic ordering by default, how to transform data in Postgres, benefits of a transaction_timeout and how to enforce join order.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/307-collation-conundrum/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Collation Conundrum | Scaling Postgres 307]]>
                </itunes:title>
                                    <itunes:episode>307</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss whether we should be using bytewise or linguistic ordering by default, how to transform data in Postgres, benefits of a transaction_timeout and how to enforce join order.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/307-collation-conundrum/">https://www.scalingpostgres.com/episodes/307-collation-conundrum/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1689784/c1e-jog81sq0qrof5v18o-33268vg3s4o-5mvpek.mp3" length="27612891"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss whether we should be using bytewise or linguistic ordering by default, how to transform data in Postgres, benefits of a transaction_timeout and how to enforce join order.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/307-collation-conundrum/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:14:22</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Scalability Limits From SLRU & Lock Manager | Scaling Postgres 306]]>
                </title>
                <pubDate>Sun, 10 Mar 2024 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1683569</guid>
                                    <link>https://www.scalingpostgres.com/episodes/306-scalability-limits-from-slru-lock-manager/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss one configuration change that resulted in an 11,000 times faster query, why Postgres is not using your index, backported PG improvements and parallelism with TOAST.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/306-scalability-limits-from-slru-lock-manager/">https://www.scalingpostgres.com/episodes/306-scalability-limits-from-slru-lock-manager/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss one configuration change that resulted in an 11,000 times faster query, why Postgres is not using your index, backported PG improvements and parallelism with TOAST.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/306-scalability-limits-from-slru-lock-manager/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Scalability Limits From SLRU & Lock Manager | Scaling Postgres 306]]>
                </itunes:title>
                                    <itunes:episode>306</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss one configuration change that resulted in an 11,000 times faster query, why Postgres is not using your index, backported PG improvements and parallelism with TOAST.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/306-scalability-limits-from-slru-lock-manager/">https://www.scalingpostgres.com/episodes/306-scalability-limits-from-slru-lock-manager/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1683569/c1e-pm5o7t5pgr6sq8o3n-7n5d9wr2fm6-4hrtzw.mp3" length="27827722"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss one configuration change that resulted in an 11,000 times faster query, why Postgres is not using your index, backported PG improvements and parallelism with TOAST.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/306-scalability-limits-from-slru-lock-manager/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:14:29</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[11K Faster Configuration Change | Scaling Postgres 305]]>
                </title>
                <pubDate>Sun, 03 Mar 2024 22:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1678490</guid>
                                    <link>https://www.scalingpostgres.com/episodes/305-11k-faster-configuration-change/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss one configuration change that resulted in an 11,000 times faster query, why Postgres is not using your index, backported PG improvements and parallelism with TOAST.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/305-11k-faster-configuration-change/">https://www.scalingpostgres.com/episodes/305-11k-faster-configuration-change/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss one configuration change that resulted in an 11,000 times faster query, why Postgres is not using your index, backported PG improvements and parallelism with TOAST.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/305-11k-faster-configuration-change/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[11K Faster Configuration Change | Scaling Postgres 305]]>
                </itunes:title>
                                    <itunes:episode>305</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss one configuration change that resulted in an 11,000 times faster query, why Postgres is not using your index, backported PG improvements and parallelism with TOAST.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/305-11k-faster-configuration-change/">https://www.scalingpostgres.com/episodes/305-11k-faster-configuration-change/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1678490/c1e-pm5o7t5pxp8bq8o3n-p80ow8rqi27-tg2axb.mp3" length="25823190"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss one configuration change that resulted in an 11,000 times faster query, why Postgres is not using your index, backported PG improvements and parallelism with TOAST.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/305-11k-faster-configuration-change/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:13:26</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Overhead of pg_stat_statements | Scaling Postgres 304]]>
                </title>
                <pubDate>Sun, 25 Feb 2024 22:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1670109</guid>
                                    <link>https://www.scalingpostgres.com/episodes/304-overhead-of-pg_stat_statements/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss new Postgres releases, performance comparisons between PgBouncer, PgCat and Supavisor, a new extension pg_analytics, and new planner capabilities in PG16.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/304-overhead-of-pg_stat_statements/">https://www.scalingpostgres.com/episodes/304-overhead-of-pg_stat_statements/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss new Postgres releases, performance comparisons between PgBouncer, PgCat and Supavisor, a new extension pg_analytics, and new planner capabilities in PG16.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/304-overhead-of-pg_stat_statements/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Overhead of pg_stat_statements | Scaling Postgres 304]]>
                </itunes:title>
                                    <itunes:episode>304</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss new Postgres releases, performance comparisons between PgBouncer, PgCat and Supavisor, a new extension pg_analytics, and new planner capabilities in PG16.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/304-overhead-of-pg_stat_statements/">https://www.scalingpostgres.com/episodes/304-overhead-of-pg_stat_statements/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1670109/c1e-7vwg1c45pwjb5z6j9-8m73g8n8hrw0-wat6lh.mp3" length="27178213"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss new Postgres releases, performance comparisons between PgBouncer, PgCat and Supavisor, a new extension pg_analytics, and new planner capabilities in PG16.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/304-overhead-of-pg_stat_statements/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:14:09</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[PgBouncer, PgCat, Supavisor Fight!!! | Scaling Postgres 303]]>
                </title>
                <pubDate>Sun, 18 Feb 2024 22:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1664234</guid>
                                    <link>https://www.scalingpostgres.com/episodes/303-pgbouncer-pgcat-supavisor-fight/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss new Postgres releases, performance comparisons between PgBouncer, PgCat and Supavisor, a new extension pg_analytics, and new planner capabilities in PG16.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/303-pgbouncer-pgcat-supavisor-fight/">https://www.scalingpostgres.com/episodes/303-pgbouncer-pgcat-supavisor-fight/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss new Postgres releases, performance comparisons between PgBouncer, PgCat and Supavisor, a new extension pg_analytics, and new planner capabilities in PG16.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/303-pgbouncer-pgcat-supavisor-fight/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[PgBouncer, PgCat, Supavisor Fight!!! | Scaling Postgres 303]]>
                </itunes:title>
                                    <itunes:episode>303</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss new Postgres releases, performance comparisons between PgBouncer, PgCat and Supavisor, a new extension pg_analytics, and new planner capabilities in PG16.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/303-pgbouncer-pgcat-supavisor-fight/">https://www.scalingpostgres.com/episodes/303-pgbouncer-pgcat-supavisor-fight/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1664234/c1e-4qp0ns49j8na82pd0-92kpxd99f350-ixu6r1.mp3" length="38257475"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss new Postgres releases, performance comparisons between PgBouncer, PgCat and Supavisor, a new extension pg_analytics, and new planner capabilities in PG16.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/303-pgbouncer-pgcat-supavisor-fight/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:19:55</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[UUID vs Bigint Battle!!! | Scaling Postgres 302]]>
                </title>
                <pubDate>Sun, 11 Feb 2024 22:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1659099</guid>
                                    <link>https://www.scalingpostgres.com/episodes/302-uuid-vs-bigint-battle/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss when and how you should use UUIDs or not, how to optimize space with column order and arrays, whether it is better to tune parameters or queries and what devs should know about Postgres with Andrew Atkinson.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/302-uuid-vs-bigint-battle/">https://www.scalingpostgres.com/episodes/302-uuid-vs-bigint-battle/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss when and how you should use UUIDs or not, how to optimize space with column order and arrays, whether it is better to tune parameters or queries and what devs should know about Postgres with Andrew Atkinson.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/302-uuid-vs-bigint-battle/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[UUID vs Bigint Battle!!! | Scaling Postgres 302]]>
                </itunes:title>
                                    <itunes:episode>302</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss when and how you should use UUIDs or not, how to optimize space with column order and arrays, whether it is better to tune parameters or queries and what devs should know about Postgres with Andrew Atkinson.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/302-uuid-vs-bigint-battle/">https://www.scalingpostgres.com/episodes/302-uuid-vs-bigint-battle/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1659099/c1e-542nmfmrr0gaq6xwk-v0831nx5i7mw-maec1b.mp3" length="25703653"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss when and how you should use UUIDs or not, how to optimize space with column order and arrays, whether it is better to tune parameters or queries and what devs should know about Postgres with Andrew Atkinson.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/302-uuid-vs-bigint-battle/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:13:23</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres LLM OS & 30 Times Faster Index Builds | Scaling Postgres 301]]>
                </title>
                <pubDate>Sun, 04 Feb 2024 23:29:45 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1653889</guid>
                                    <link>https://www.scalingpostgres.com/episodes/301-postgres-llm-os-30-times-faster-index-builds/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how you can build a GPT in 500 lines of SQL code, how to optimize extension loading, the best way to set passwords and being able to change generated columns.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/301-postgres-llm-os-30-times-faster-index-builds/">https://www.scalingpostgres.com/episodes/301-postgres-llm-os-30-times-faster-index-builds/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how you can build a GPT in 500 lines of SQL code, how to optimize extension loading, the best way to set passwords and being able to change generated columns.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/301-postgres-llm-os-30-times-faster-index-builds/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres LLM OS & 30 Times Faster Index Builds | Scaling Postgres 301]]>
                </itunes:title>
                                    <itunes:episode>301</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how you can build a GPT in 500 lines of SQL code, how to optimize extension loading, the best way to set passwords and being able to change generated columns.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/301-postgres-llm-os-30-times-faster-index-builds/">https://www.scalingpostgres.com/episodes/301-postgres-llm-os-30-times-faster-index-builds/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1653889/c1e-9vpz8cok543aw3vgk-498747p8f7v2-gevv1c.mp3" length="35016620"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how you can build a GPT in 500 lines of SQL code, how to optimize extension loading, the best way to set passwords and being able to change generated columns.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/301-postgres-llm-os-30-times-faster-index-builds/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:18:14</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Scaling Postgres Celebration | Scaling Postgres 300]]>
                </title>
                <pubDate>Sun, 28 Jan 2024 22:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1643682</guid>
                                    <link>https://www.scalingpostgres.com/episodes/300-postgres-celebration/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how you can build a GPT in 500 lines of SQL code, how to optimize extension loading, the best way to set passwords and being able to change generated columns.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/300-postgres-celebration/">https://www.scalingpostgres.com/episodes/300-postgres-celebration/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how you can build a GPT in 500 lines of SQL code, how to optimize extension loading, the best way to set passwords and being able to change generated columns.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/300-postgres-celebration/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Scaling Postgres Celebration | Scaling Postgres 300]]>
                </itunes:title>
                                    <itunes:episode>300</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how you can build a GPT in 500 lines of SQL code, how to optimize extension loading, the best way to set passwords and being able to change generated columns.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/300-postgres-celebration/">https://www.scalingpostgres.com/episodes/300-postgres-celebration/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1643682/c1e-w9520c9521ws8kg13-04m0xm3zh8z8-4cbqhs.mp3" length="34634605"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how you can build a GPT in 500 lines of SQL code, how to optimize extension loading, the best way to set passwords and being able to change generated columns.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/300-postgres-celebration/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:18:02</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Build A GPT In SQL | Scaling Postgres 299]]>
                </title>
                <pubDate>Sun, 21 Jan 2024 22:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1638624</guid>
                                    <link>https://www.scalingpostgres.com/episodes/299-build-a-gpt-in-sql/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how you can build a GPT in 500 lines of SQL code, how to optimize extension loading, the best way to set passwords and being able to change generated columns.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/299-build-a-gpt-in-sql/">https://www.scalingpostgres.com/episodes/299-build-a-gpt-in-sql/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how you can build a GPT in 500 lines of SQL code, how to optimize extension loading, the best way to set passwords and being able to change generated columns.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/299-build-a-gpt-in-sql/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Build A GPT In SQL | Scaling Postgres 299]]>
                </itunes:title>
                                    <itunes:episode>299</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how you can build a GPT in 500 lines of SQL code, how to optimize extension loading, the best way to set passwords and being able to change generated columns.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/299-build-a-gpt-in-sql/">https://www.scalingpostgres.com/episodes/299-build-a-gpt-in-sql/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1638624/c1e-pm5o7t9vqr4bq8o3n-92k3jqjjsoj7-lhvozm.mp3" length="23715840"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how you can build a GPT in 500 lines of SQL code, how to optimize extension loading, the best way to set passwords and being able to change generated columns.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/299-build-a-gpt-in-sql/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:12:21</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[10-100 Times Higher Latency With Distributed Postgres | Scaling Postgres 298]]>
                </title>
                <pubDate>Sun, 14 Jan 2024 22:22:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1633304</guid>
                                    <link>https://www.scalingpostgres.com/episodes/298-10-100-times-higher-latency-with-distributed-postgres/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss hopes for Postgres in 2024, whether you need foreign keys, incremental backups, and five ways of doing not exists.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/298-10-100-times-higher-latency-with-distributed-postgres/">https://www.scalingpostgres.com/episodes/298-10-100-times-higher-latency-with-distributed-postgres/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss hopes for Postgres in 2024, whether you need foreign keys, incremental backups, and five ways of doing not exists.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/298-10-100-times-higher-latency-with-distributed-postgres/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[10-100 Times Higher Latency With Distributed Postgres | Scaling Postgres 298]]>
                </itunes:title>
                                    <itunes:episode>298</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss hopes for Postgres in 2024, whether you need foreign keys, incremental backups, and five ways of doing not exists.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/298-10-100-times-higher-latency-with-distributed-postgres/">https://www.scalingpostgres.com/episodes/298-10-100-times-higher-latency-with-distributed-postgres/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1633304/c1e-4qp0nsgq02ka82pd0-rom477w1cqw2-3w7v64.mp3" length="37393136"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss hopes for Postgres in 2024, whether you need foreign keys, incremental backups, and five ways of doing not exists.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/298-10-100-times-higher-latency-with-distributed-postgres/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:19:28</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres In 2024 | Scaling Postgres 297]]>
                </title>
                <pubDate>Sun, 07 Jan 2024 22:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1628306</guid>
                                    <link>https://www.scalingpostgres.com/episodes/297-postgres-in-2024/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss hopes for Postgres in 2024, whether you need foreign keys, incremental backups, and five ways of doing not exists.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/297-postgres-in-2024/">https://www.scalingpostgres.com/episodes/297-postgres-in-2024/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss hopes for Postgres in 2024, whether you need foreign keys, incremental backups, and five ways of doing not exists.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/297-postgres-in-2024/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres In 2024 | Scaling Postgres 297]]>
                </itunes:title>
                                    <itunes:episode>297</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss hopes for Postgres in 2024, whether you need foreign keys, incremental backups, and five ways of doing not exists.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/297-postgres-in-2024/">https://www.scalingpostgres.com/episodes/297-postgres-in-2024/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1628306/c1e-3vqr0cjvozxhwgqox-04m23q5obj-z3hvnu.mp3" length="39631725"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss hopes for Postgres in 2024, whether you need foreign keys, incremental backups, and five ways of doing not exists.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/297-postgres-in-2024/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:20:38</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[State Of Postgres 2023 | Scaling Postgres 296]]>
                </title>
                <pubDate>Sun, 24 Dec 2023 22:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1621569</guid>
                                    <link>https://www.scalingpostgres.com/episodes/296-state-of-postgres-2023/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the State of Postgres 2023 survey, a repository of Postgres how-tos, ways foreign keys can break and a custom SQL playground.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/296-state-of-postgres-2023/">https://www.scalingpostgres.com/episodes/296-state-of-postgres-2023/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the State of Postgres 2023 survey, a repository of Postgres how-tos, ways foreign keys can break and a custom SQL playground.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/296-state-of-postgres-2023/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[State Of Postgres 2023 | Scaling Postgres 296]]>
                </itunes:title>
                                    <itunes:episode>296</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the State of Postgres 2023 survey, a repository of Postgres how-tos, ways foreign keys can break and a custom SQL playground.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/296-state-of-postgres-2023/">https://www.scalingpostgres.com/episodes/296-state-of-postgres-2023/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1621569/c1e-9vpz8co82n6hw3vgk-xmdpvg0ga6oo-qysqse.mp3" length="34108813"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the State of Postgres 2023 survey, a repository of Postgres how-tos, ways foreign keys can break and a custom SQL playground.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/296-state-of-postgres-2023/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:17:45</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[30K Messages Per Second Queue | Scaling Postgres 295]]>
                </title>
                <pubDate>Sun, 17 Dec 2023 22:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1616622</guid>
                                    <link>https://www.scalingpostgres.com/episodes/295-30k-messages-per-second-queue/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss a 30K messages per second queue built on Postgres, a zero downtime logical replication upgrade, the release of the Supavisor 1.0 connection pooler and PostGIS day.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/295-30k-messages-per-second-queue/">https://www.scalingpostgres.com/episodes/295-30k-messages-per-second-queue/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a 30K messages per second queue built on Postgres, a zero downtime logical replication upgrade, the release of the Supavisor 1.0 connection pooler and PostGIS day.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/295-30k-messages-per-second-queue/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[30K Messages Per Second Queue | Scaling Postgres 295]]>
                </itunes:title>
                                    <itunes:episode>295</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss a 30K messages per second queue built on Postgres, a zero downtime logical replication upgrade, the release of the Supavisor 1.0 connection pooler and PostGIS day.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/295-30k-messages-per-second-queue/">https://www.scalingpostgres.com/episodes/295-30k-messages-per-second-queue/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1616622/sp295.mp3" length="29842285"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a 30K messages per second queue built on Postgres, a zero downtime logical replication upgrade, the release of the Supavisor 1.0 connection pooler and PostGIS day.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/295-30k-messages-per-second-queue/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:15:32</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[How Much Observability Is Needed? | Scaling Postgres 294]]>
                </title>
                <pubDate>Mon, 11 Dec 2023 00:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1613018</guid>
                                    <link>https://www.scalingpostgres.com/episodes/294-how-much-observability-is-needed/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how much observability is needed, avoiding locks during database migrations, a huge Postgres events blogging event and FIPS mode.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/294-how-much-observability-is-needed/">https://www.scalingpostgres.com/episodes/294-how-much-observability-is-needed/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how much observability is needed, avoiding locks during database migrations, a huge Postgres events blogging event and FIPS mode.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/294-how-much-observability-is-needed/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[How Much Observability Is Needed? | Scaling Postgres 294]]>
                </itunes:title>
                                    <itunes:episode>294</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how much observability is needed, avoiding locks during database migrations, a huge Postgres events blogging event and FIPS mode.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/294-how-much-observability-is-needed/">https://www.scalingpostgres.com/episodes/294-how-much-observability-is-needed/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1613018/sp294.mp3" length="27182393"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how much observability is needed, avoiding locks during database migrations, a huge Postgres events blogging event and FIPS mode.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/294-how-much-observability-is-needed/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:14:09</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Better Plans With Statistics  | Scaling Postgres 293]]>
                </title>
                <pubDate>Mon, 04 Dec 2023 01:03:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1607282</guid>
                                    <link>https://www.scalingpostgres.com/episodes/293-better-plans-with-statistics/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how create statistics can help you get better plans, issues with subtransactions, all about extensions and best practices when indexing timestamps.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/293-better-plans-with-statistics/">https://www.scalingpostgres.com/episodes/293-better-plans-with-statistics/</a></p>
<p> </p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how create statistics can help you get better plans, issues with subtransactions, all about extensions and best practices when indexing timestamps.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/293-better-plans-with-statistics/
 
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Better Plans With Statistics  | Scaling Postgres 293]]>
                </itunes:title>
                                    <itunes:episode>293</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how create statistics can help you get better plans, issues with subtransactions, all about extensions and best practices when indexing timestamps.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/293-better-plans-with-statistics/">https://www.scalingpostgres.com/episodes/293-better-plans-with-statistics/</a></p>
<p> </p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1607282/sp293.mp3" length="29403428"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how create statistics can help you get better plans, issues with subtransactions, all about extensions and best practices when indexing timestamps.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/293-better-plans-with-statistics/
 
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:15:18</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Companion Databases?  | Scaling Postgres 292]]>
                </title>
                <pubDate>Sun, 26 Nov 2023 20:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1603186</guid>
                                    <link>https://www.scalingpostgres.com/episodes/292-companion-databases/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss using companion databases, multi-tenancy database design, whether SQL is good, and different transaction isolation levels.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/292-companion-databases/">https://www.scalingpostgres.com/episodes/292-companion-databases/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss using companion databases, multi-tenancy database design, whether SQL is good, and different transaction isolation levels.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/292-companion-databases/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Companion Databases?  | Scaling Postgres 292]]>
                </itunes:title>
                                    <itunes:episode>292</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss using companion databases, multi-tenancy database design, whether SQL is good, and different transaction isolation levels.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/292-companion-databases/">https://www.scalingpostgres.com/episodes/292-companion-databases/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1603186/sp292.mp3" length="25399379"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss using companion databases, multi-tenancy database design, whether SQL is good, and different transaction isolation levels.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/292-companion-databases/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:13:13</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[2 To 4 Times Faster With Vectorization  | Scaling Postgres 291]]>
                </title>
                <pubDate>Sun, 19 Nov 2023 20:55:15 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1599574</guid>
                                    <link>https://www.scalingpostgres.com/episodes/291-2-to-4-times-faster-with-vectorization/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss Timescale's performance improvements from adding a query vectorization pipeline, doing blue-green deployments for databases, using reserved_connections and two improvements to null handling.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/291-2-to-4-times-faster-with-vectorization/">https://www.scalingpostgres.com/episodes/291-2-to-4-times-faster-with-vectorization/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss Timescale's performance improvements from adding a query vectorization pipeline, doing blue-green deployments for databases, using reserved_connections and two improvements to null handling.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/291-2-to-4-times-faster-with-vectorization/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[2 To 4 Times Faster With Vectorization  | Scaling Postgres 291]]>
                </itunes:title>
                                    <itunes:episode>291</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss Timescale's performance improvements from adding a query vectorization pipeline, doing blue-green deployments for databases, using reserved_connections and two improvements to null handling.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/291-2-to-4-times-faster-with-vectorization/">https://www.scalingpostgres.com/episodes/291-2-to-4-times-faster-with-vectorization/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1599574/sp291.mp3" length="35069283"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss Timescale's performance improvements from adding a query vectorization pipeline, doing blue-green deployments for databases, using reserved_connections and two improvements to null handling.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/291-2-to-4-times-faster-with-vectorization/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:18:15</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres Releases = Reindexing | Scaling Postgres 290]]>
                </title>
                <pubDate>Sun, 12 Nov 2023 20:36:56 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1594841</guid>
                                    <link>https://www.scalingpostgres.com/episodes/290-postgres-releases-equals-reindexing/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss my Postgres Performance Starter Kit, new releases of Postgres, removing JIT, and a lightweight message queue.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/290-postgres-releases-equals-reindexing/">https://www.scalingpostgres.com/episodes/290-postgres-releases-equals-reindexing/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss my Postgres Performance Starter Kit, new releases of Postgres, removing JIT, and a lightweight message queue.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/290-postgres-releases-equals-reindexing/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres Releases = Reindexing | Scaling Postgres 290]]>
                </itunes:title>
                                    <itunes:episode>290</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss my Postgres Performance Starter Kit, new releases of Postgres, removing JIT, and a lightweight message queue.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/290-postgres-releases-equals-reindexing/">https://www.scalingpostgres.com/episodes/290-postgres-releases-equals-reindexing/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1594841/sp290.mp3" length="27584470"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss my Postgres Performance Starter Kit, new releases of Postgres, removing JIT, and a lightweight message queue.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/290-postgres-releases-equals-reindexing/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:14:22</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres Scheduling Opportunities | Scaling Postgres 289]]>
                </title>
                <pubDate>Sun, 05 Nov 2023 20:51:11 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1590217</guid>
                                    <link>https://www.scalingpostgres.com/episodes/289-postgres-scheduling-opportunities/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss new options for Postgres scheduling tools, proper ways to kill processes and explain usage.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/289-postgres-scheduling-opportunities/">https://www.scalingpostgres.com/episodes/289-postgres-scheduling-opportunities/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss new options for Postgres scheduling tools, proper ways to kill processes and explain usage.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/289-postgres-scheduling-opportunities/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres Scheduling Opportunities | Scaling Postgres 289]]>
                </itunes:title>
                                    <itunes:episode>289</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss new options for Postgres scheduling tools, proper ways to kill processes and explain usage.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/289-postgres-scheduling-opportunities/">https://www.scalingpostgres.com/episodes/289-postgres-scheduling-opportunities/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1590217/sp289.mp3" length="29410951"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss new options for Postgres scheduling tools, proper ways to kill processes and explain usage.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/289-postgres-scheduling-opportunities/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:15:19</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Index Corruption From ICU Collation Change | Scaling Postgres 288]]>
                </title>
                <pubDate>Sun, 29 Oct 2023 22:23:30 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1585986</guid>
                                    <link>https://www.scalingpostgres.com/episodes/288-index-corruption-from-icu-collation-change/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss index corruption from a ICU collation change, another caveat for PgBouncer prepared statements, ways to version data, and using Postgres as a cache.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/288-index-corruption-from-icu-collation-change/">https://www.scalingpostgres.com/episodes/288-index-corruption-from-icu-collation-change/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss index corruption from a ICU collation change, another caveat for PgBouncer prepared statements, ways to version data, and using Postgres as a cache.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/288-index-corruption-from-icu-collation-change/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Index Corruption From ICU Collation Change | Scaling Postgres 288]]>
                </itunes:title>
                                    <itunes:episode>288</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss index corruption from a ICU collation change, another caveat for PgBouncer prepared statements, ways to version data, and using Postgres as a cache.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/288-index-corruption-from-icu-collation-change/">https://www.scalingpostgres.com/episodes/288-index-corruption-from-icu-collation-change/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1585986/sp288.mp3" length="24536379"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss index corruption from a ICU collation change, another caveat for PgBouncer prepared statements, ways to version data, and using Postgres as a cache.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/288-index-corruption-from-icu-collation-change/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:19:02</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[15% - 250% Faster Query Throughput | Scaling Postgres 287]]>
                </title>
                <pubDate>Sun, 22 Oct 2023 21:14:25 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1581903</guid>
                                    <link>https://www.scalingpostgres.com/episodes/287-15-250-percent-faster-query-throughput/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how the new version of pgbouncer could get you 15% to 250% faster query throughput, the availability of using kubernetes snapshots for backup and restore with CloudNativePg and Ruby on Rails Postgres improvements.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/287-15-250-percent-faster-query-throughput/">https://www.scalingpostgres.com/episodes/287-15-250-percent-faster-query-throughput/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how the new version of pgbouncer could get you 15% to 250% faster query throughput, the availability of using kubernetes snapshots for backup and restore with CloudNativePg and Ruby on Rails Postgres improvements.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/287-15-250-percent-faster-query-throughput/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[15% - 250% Faster Query Throughput | Scaling Postgres 287]]>
                </itunes:title>
                                    <itunes:episode>287</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how the new version of pgbouncer could get you 15% to 250% faster query throughput, the availability of using kubernetes snapshots for backup and restore with CloudNativePg and Ruby on Rails Postgres improvements.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/287-15-250-percent-faster-query-throughput/">https://www.scalingpostgres.com/episodes/287-15-250-percent-faster-query-throughput/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1581903/sp287.mp3" length="27688124"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how the new version of pgbouncer could get you 15% to 250% faster query throughput, the availability of using kubernetes snapshots for backup and restore with CloudNativePg and Ruby on Rails Postgres improvements.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/287-15-250-percent-faster-query-throughput/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:14:25</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[20 Times Faster Text Search & Ranking? | Scaling Postgres 286]]>
                </title>
                <pubDate>Sun, 15 Oct 2023 21:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1575081</guid>
                                    <link>https://www.scalingpostgres.com/episodes/286-20-times-faster-text-search-ranking/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss a new extension that promises substantially faster text search and ranking, an AI content storm, how to work with money and the fastest way to stop Postgres.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> <a href="https://www.scalingpostgres.com/episodes/286-20-times-faster-text-search-ranking/">https://www.scalingpostgres.com/episodes/286-20-times-faster-text-search-ranking/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a new extension that promises substantially faster text search and ranking, an AI content storm, how to work with money and the fastest way to stop Postgres.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/286-20-times-faster-text-search-ranking/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[20 Times Faster Text Search & Ranking? | Scaling Postgres 286]]>
                </itunes:title>
                                    <itunes:episode>286</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss a new extension that promises substantially faster text search and ranking, an AI content storm, how to work with money and the fastest way to stop Postgres.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> <a href="https://www.scalingpostgres.com/episodes/286-20-times-faster-text-search-ranking/">https://www.scalingpostgres.com/episodes/286-20-times-faster-text-search-ranking/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1575081/sp286.mp3" length="24947983"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a new extension that promises substantially faster text search and ranking, an AI content storm, how to work with money and the fastest way to stop Postgres.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/286-20-times-faster-text-search-ranking/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:12:59</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Indexing Deep Dive | Scaling Postgres 285]]>
                </title>
                <pubDate>Sun, 08 Oct 2023 21:56:50 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1570782</guid>
                                    <link>https://www.scalingpostgres.com/episodes/285-indexing-deep-dive/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we cover a deep dive into indexes from a presentation that includes a decision tree of sorts, how to convert to partitioned tables once you have hundreds of millions of rows and detail about the new pg_stat_io view.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/285-indexing-deep-dive/">https://www.scalingpostgres.com/episodes/285-indexing-deep-dive/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we cover a deep dive into indexes from a presentation that includes a decision tree of sorts, how to convert to partitioned tables once you have hundreds of millions of rows and detail about the new pg_stat_io view.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/285-indexing-deep-dive/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Indexing Deep Dive | Scaling Postgres 285]]>
                </itunes:title>
                                    <itunes:episode>285</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we cover a deep dive into indexes from a presentation that includes a decision tree of sorts, how to convert to partitioned tables once you have hundreds of millions of rows and detail about the new pg_stat_io view.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/285-indexing-deep-dive/">https://www.scalingpostgres.com/episodes/285-indexing-deep-dive/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1570782/sp285.mp3" length="34639621"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we cover a deep dive into indexes from a presentation that includes a decision tree of sorts, how to convert to partitioned tables once you have hundreds of millions of rows and detail about the new pg_stat_io view.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/285-indexing-deep-dive/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:18:02</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[23 Or 1.1 Times Faster Performance? | Scaling Postgres 284]]>
                </title>
                <pubDate>Sun, 01 Oct 2023 21:27:42 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1566518</guid>
                                    <link>https://www.scalingpostgres.com/episodes/284-23-or-1-times-faster-performance/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss whether something is 23 times faster or 1.1 times faster. We also discuss the release of Timescale Vector and whether you can build a queue on Postgres.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/284-23-or-1-times-faster-performance/">https://www.scalingpostgres.com/episodes/284-23-or-1-times-faster-performance/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss whether something is 23 times faster or 1.1 times faster. We also discuss the release of Timescale Vector and whether you can build a queue on Postgres.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/284-23-or-1-times-faster-performance/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[23 Or 1.1 Times Faster Performance? | Scaling Postgres 284]]>
                </itunes:title>
                                    <itunes:episode>284</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss whether something is 23 times faster or 1.1 times faster. We also discuss the release of Timescale Vector and whether you can build a queue on Postgres.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/284-23-or-1-times-faster-performance/">https://www.scalingpostgres.com/episodes/284-23-or-1-times-faster-performance/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1566518/sp284.mp3" length="36456071"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss whether something is 23 times faster or 1.1 times faster. We also discuss the release of Timescale Vector and whether you can build a queue on Postgres.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/284-23-or-1-times-faster-performance/
 ]]>
                </itunes:summary>
                                                                            <itunes:duration>00:18:59</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[222 Times Faster Analytical Queries With Columnar Storage | Scaling Postgres 283]]>
                </title>
                <pubDate>Sun, 24 Sep 2023 21:23:05 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1562575</guid>
                                    <link>https://www.scalingpostgres.com/episodes/283-222-times-faster-analytical-queries-with-columnar-storage/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to get 222 times faster analytical queries with columnar storage, a Postgres 16 feature review, the birth of a feature and fuzzy search.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/283-222-times-faster-analytical-queries-with-columnar-storage/">https://www.scalingpostgres.com/episodes/283-222-times-faster-analytical-queries-with-columnar-storage/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to get 222 times faster analytical queries with columnar storage, a Postgres 16 feature review, the birth of a feature and fuzzy search.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/283-222-times-faster-analytical-queries-with-columnar-storage/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[222 Times Faster Analytical Queries With Columnar Storage | Scaling Postgres 283]]>
                </itunes:title>
                                    <itunes:episode>283</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to get 222 times faster analytical queries with columnar storage, a Postgres 16 feature review, the birth of a feature and fuzzy search.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/283-222-times-faster-analytical-queries-with-columnar-storage/">https://www.scalingpostgres.com/episodes/283-222-times-faster-analytical-queries-with-columnar-storage/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1562575/sp283.mp3" length="30740062"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to get 222 times faster analytical queries with columnar storage, a Postgres 16 feature review, the birth of a feature and fuzzy search.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/283-222-times-faster-analytical-queries-with-columnar-storage/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:16:00</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres 16 Released, The Postgres Meme, File vs base64 Strings, Intelligent Sharding | Scaling Postgres 282]]>
                </title>
                <pubDate>Sun, 17 Sep 2023 21:15:31 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1557372</guid>
                                    <link>https://www.scalingpostgres.com/episodes/282-postgres-16-released-postgres-meme-file-vs-base64-strings-intelligent-sharding/</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the release of Postgres 16, a Postgres meme, storing files or base64 strings and sharding intelligently.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/282-postgres-16-released-postgres-meme-file-vs-base64-strings-intelligent-sharding/">https://www.scalingpostgres.com/episodes/282-postgres-16-released-postgres-meme-file-vs-base64-strings-intelligent-sharding/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the release of Postgres 16, a Postgres meme, storing files or base64 strings and sharding intelligently.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/282-postgres-16-released-postgres-meme-file-vs-base64-strings-intelligent-sharding/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres 16 Released, The Postgres Meme, File vs base64 Strings, Intelligent Sharding | Scaling Postgres 282]]>
                </itunes:title>
                                    <itunes:episode>282</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the release of Postgres 16, a Postgres meme, storing files or base64 strings and sharding intelligently.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/282-postgres-16-released-postgres-meme-file-vs-base64-strings-intelligent-sharding/">https://www.scalingpostgres.com/episodes/282-postgres-16-released-postgres-meme-file-vs-base64-strings-intelligent-sharding/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1557372/sp282.mp3" length="26892329"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the release of Postgres 16, a Postgres meme, storing files or base64 strings and sharding intelligently.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/282-postgres-16-released-postgres-meme-file-vs-base64-strings-intelligent-sharding/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:14:00</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[HNSW Indexes, Vacuuming Bloat, Watch Me Now, Connections | Scaling Postgres 281]]>
                </title>
                <pubDate>Sun, 10 Sep 2023 21:32:38 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="true">
                    https://permalink.castos.com/podcast/55828/episode/1553579</guid>
                                    <link>https://www.scalingpostgres.com/episodes/281-hnsw-indexes-vacuuming-bloat-watch-me-now-connections/</link>
                                <description>
                                            <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss the benefits and disadvantages of HNSW indexes for working with vector data, configuring vacuum to reduce bloat and optimize performance, the new options available for \watch and all about connections.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="To%20get%20the%20show%20notes%20as%20well%20as%20get%20notified%20of%20new%20episodes,%20visit%3A%C2%A0%20%20https%3A/www.scalingpostgres.com/episodes/281-hnsw-indexes-vacuuming-bloat-watch-me-now-connections/">https://www.scalingpostgres.com/episodes/281-hnsw-indexes-vacuuming-bloat-watch-me-now-connections/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss the benefits and disadvantages of HNSW indexes for working with vector data, configuring vacuum to reduce bloat and optimize performance, the new options available for \watch and all about connections.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/281-hnsw-indexes-vacuuming-bloat-watch-me-now-connections/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[HNSW Indexes, Vacuuming Bloat, Watch Me Now, Connections | Scaling Postgres 281]]>
                </itunes:title>
                                    <itunes:episode>281</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss the benefits and disadvantages of HNSW indexes for working with vector data, configuring vacuum to reduce bloat and optimize performance, the new options available for \watch and all about connections.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="To%20get%20the%20show%20notes%20as%20well%20as%20get%20notified%20of%20new%20episodes,%20visit%3A%C2%A0%20%20https%3A/www.scalingpostgres.com/episodes/281-hnsw-indexes-vacuuming-bloat-watch-me-now-connections/">https://www.scalingpostgres.com/episodes/281-hnsw-indexes-vacuuming-bloat-watch-me-now-connections/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1553579/sp281.mp3" length="33037165"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss the benefits and disadvantages of HNSW indexes for working with vector data, configuring vacuum to reduce bloat and optimize performance, the new options available for \watch and all about connections.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/281-hnsw-indexes-vacuuming-bloat-watch-me-now-connections/]]>
                </itunes:summary>
                                                                            <itunes:duration>00:17:12</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres 16 RC1, Bi-Directional Replication, All About Parameters, Foreign Keys & Polymorphism | Scaling Postgres 280]]>
                </title>
                <pubDate>Sun, 03 Sep 2023 21:42:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    6afb13fc-163b-4512-8f67-ae762429c1fa</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/postgres-16-rc1-bi-directional-replication-all-about-parameters-foreign-keys-polymorphism-scaling-postgres-280-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the release of Postgres 16 RC1, implementing bi-directional replication, different ways you can set up Postgres parameters and how to handle polymorphism and foreign keys.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/280-postgres-16-rc1-bi-directional-replication-all-about-parameters-foreign-keys-polymorphism/">https://www.scalingpostgres.com/episodes/280-postgres-16-rc1-bi-directional-replication-all-about-parameters-foreign-keys-polymorphism/</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the release of Postgres 16 RC1, implementing bi-directional replication, different ways you can set up Postgres parameters and how to handle polymorphism and foreign keys.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/280-postgres-16-rc1-bi-directional-replication-all-about-parameters-foreign-keys-polymorphism/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres 16 RC1, Bi-Directional Replication, All About Parameters, Foreign Keys & Polymorphism | Scaling Postgres 280]]>
                </itunes:title>
                                    <itunes:episode>280</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the release of Postgres 16 RC1, implementing bi-directional replication, different ways you can set up Postgres parameters and how to handle polymorphism and foreign keys.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/280-postgres-16-rc1-bi-directional-replication-all-about-parameters-foreign-keys-polymorphism/">https://www.scalingpostgres.com/episodes/280-postgres-16-rc1-bi-directional-replication-all-about-parameters-foreign-keys-polymorphism/</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551150/sp280.mp3" length="40618109"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the release of Postgres 16 RC1, implementing bi-directional replication, different ways you can set up Postgres parameters and how to handle polymorphism and foreign keys.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/280-postgres-16-rc1-bi-directional-replication-all-about-parameters-foreign-keys-polymorphism/
 ]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551150/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:21:09</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[TPS Benchmark, Partition-wise Join & Aggregate, Partitioning Billions, Posgres 16 Features | Scaling Postgres 279]]>
                </title>
                <pubDate>Sun, 27 Aug 2023 20:50:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    d2736327-b462-4d6e-851c-4638648cc9c2</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/tps-benchmark-partition-wise-join-aggregate-partitioning-billions-posgres-16-features-scaling-postgres-279-1</link>
                                <description>
                                            <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss how pgbouncer can impact a TPS benchmark, partition-wise join &amp; aggregate performance, partitioning a table with billions of rows and cool Postgres 16 features.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/279-tps-benchmark-partition-wise-join-partitioning-billions-postgres-16-features/">https://www.scalingpostgres.com/episodes/279-tps-benchmark-partition-wise-join-partitioning-billions-postgres-16-features/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss how pgbouncer can impact a TPS benchmark, partition-wise join & aggregate performance, partitioning a table with billions of rows and cool Postgres 16 features.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/279-tps-benchmark-partition-wise-join-partitioning-billions-postgres-16-features/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[TPS Benchmark, Partition-wise Join & Aggregate, Partitioning Billions, Posgres 16 Features | Scaling Postgres 279]]>
                </itunes:title>
                                    <itunes:episode>279</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss how pgbouncer can impact a TPS benchmark, partition-wise join &amp; aggregate performance, partitioning a table with billions of rows and cool Postgres 16 features.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/279-tps-benchmark-partition-wise-join-partitioning-billions-postgres-16-features/">https://www.scalingpostgres.com/episodes/279-tps-benchmark-partition-wise-join-partitioning-billions-postgres-16-features/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551151/sp279.mp3" length="30704953"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss how pgbouncer can impact a TPS benchmark, partition-wise join & aggregate performance, partitioning a table with billions of rows and cool Postgres 16 features.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/279-tps-benchmark-partition-wise-join-partitioning-billions-postgres-16-features/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551151/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:59</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Squeeze Your System, One Million Connections, Indexing LIKE, pgvector HNSW | Scaling Postgres 278]]>
                </title>
                <pubDate>Sun, 20 Aug 2023 21:32:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    419bdeea-0740-47ef-aa9e-7a4ca6cfb0b4</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/squeeze-your-system-one-million-connections-indexing-like-pgvector-hnsw-scaling-postgres-278-1</link>
                                <description>
                                            <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss how to squeeze the most out of your database, achieving one million connections to Postgres, how to use indexes with LIKE and pgvector HNSW index performance.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><span style="background-color:#ffffff;"><a style="background-color:#ffffff;" href="https://www.scalingpostgres.com/episodes/278-squeeze-your-system-one-million-connections-indexing-like-pgvector-hnsw/">https://www.scalingpostgres.com/episodes/278-squeeze-your-system-one-million-connections-indexing-like-pgvector-hnsw/</a></span></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss how to squeeze the most out of your database, achieving one million connections to Postgres, how to use indexes with LIKE and pgvector HNSW index performance.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/278-squeeze-your-system-one-million-connections-indexing-like-pgvector-hnsw/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Squeeze Your System, One Million Connections, Indexing LIKE, pgvector HNSW | Scaling Postgres 278]]>
                </itunes:title>
                                    <itunes:episode>278</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss how to squeeze the most out of your database, achieving one million connections to Postgres, how to use indexes with LIKE and pgvector HNSW index performance.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><span style="background-color:#ffffff;"><a style="background-color:#ffffff;" href="https://www.scalingpostgres.com/episodes/278-squeeze-your-system-one-million-connections-indexing-like-pgvector-hnsw/">https://www.scalingpostgres.com/episodes/278-squeeze-your-system-one-million-connections-indexing-like-pgvector-hnsw/</a></span></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551152/sp278.mp3" length="30674024"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss how to squeeze the most out of your database, achieving one million connections to Postgres, how to use indexes with LIKE and pgvector HNSW index performance.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/278-squeeze-your-system-one-million-connections-indexing-like-pgvector-hnsw/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551152/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:58</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres Releases, PostgreSQL Survey, Partitioning vs. Sharding, Bulk Loading | Scaling Postgres 277]]>
                </title>
                <pubDate>Sun, 13 Aug 2023 16:32:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    affd375f-072e-4367-8f35-55124ab9e359</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/postgres-releases-postgresql-survey-partitioning-vs-sharding-bulk-loading-scaling-postgres-277-1</link>
                                <description>
                                            <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss new Postgres releases, taking the 2023 State of PostgreSQL survey, partitioning vs. sharding and the fastest way to do bulk loads.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><span style="background-color:#ffffff;"><a style="background-color:#ffffff;" href="https://www.scalingpostgres.com/episodes/277-postgres-releases-postgresql-survey-partitioning-sharding-bulk-loading/">https://www.scalingpostgres.com/episodes/277-postgres-releases-postgresql-survey-partitioning-sharding-bulk-loading/</a></span></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss new Postgres releases, taking the 2023 State of PostgreSQL survey, partitioning vs. sharding and the fastest way to do bulk loads.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/277-postgres-releases-postgresql-survey-partitioning-sharding-bulk-loading/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres Releases, PostgreSQL Survey, Partitioning vs. Sharding, Bulk Loading | Scaling Postgres 277]]>
                </itunes:title>
                                    <itunes:episode>277</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss new Postgres releases, taking the 2023 State of PostgreSQL survey, partitioning vs. sharding and the fastest way to do bulk loads.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><span style="background-color:#ffffff;"><a style="background-color:#ffffff;" href="https://www.scalingpostgres.com/episodes/277-postgres-releases-postgresql-survey-partitioning-sharding-bulk-loading/">https://www.scalingpostgres.com/episodes/277-postgres-releases-postgresql-survey-partitioning-sharding-bulk-loading/</a></span></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551153/sp277.mp3" length="36622419"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss new Postgres releases, taking the 2023 State of PostgreSQL survey, partitioning vs. sharding and the fastest way to do bulk loads.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/277-postgres-releases-postgresql-survey-partitioning-sharding-bulk-loading/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551153/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:19:04</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[BRIN & Correlation, Poor Partitioning, 10 Beginner Tips, Table & Index Usage | Scaling Postgres 276]]>
                </title>
                <pubDate>Sun, 30 Jul 2023 21:13:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    9c1af4f0-0827-4e23-9e00-3a173820ed07</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/brin-correlation-poor-partitioning-10-beginner-tips-table-index-usage-scaling-postgres-276-1</link>
                                <description>
                                            <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss the importance of correlation with BRIN indexes, how partitioning can kill performance, 10 tips for beginners and how to track table and index usage.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><span style="background-color:#ffffff;"><a style="background-color:#ffffff;" href="https://www.scalingpostgres.com/episodes/276-brin-correlation-poor-partitioning-10-beginner-tips-table-index-usage/">https://www.scalingpostgres.com/episodes/276-brin-correlation-poor-partitioning-10-beginner-tips-table-index-usage/</a></span></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss the importance of correlation with BRIN indexes, how partitioning can kill performance, 10 tips for beginners and how to track table and index usage.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/276-brin-correlation-poor-partitioning-10-beginner-tips-table-index-usage/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[BRIN & Correlation, Poor Partitioning, 10 Beginner Tips, Table & Index Usage | Scaling Postgres 276]]>
                </itunes:title>
                                    <itunes:episode>276</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss the importance of correlation with BRIN indexes, how partitioning can kill performance, 10 tips for beginners and how to track table and index usage.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><span style="background-color:#ffffff;"><a style="background-color:#ffffff;" href="https://www.scalingpostgres.com/episodes/276-brin-correlation-poor-partitioning-10-beginner-tips-table-index-usage/">https://www.scalingpostgres.com/episodes/276-brin-correlation-poor-partitioning-10-beginner-tips-table-index-usage/</a></span></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551154/sp276.mp3" length="30651454"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss the importance of correlation with BRIN indexes, how partitioning can kill performance, 10 tips for beginners and how to track table and index usage.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/276-brin-correlation-poor-partitioning-10-beginner-tips-table-index-usage/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551154/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:57</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[No More Vacuum, Zero-Downtime Cut-Over, Network Impact, Not In Optimization | Scaling Postgres 275]]>
                </title>
                <pubDate>Sun, 23 Jul 2023 21:12:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    973f0575-0ec1-44dc-9ba2-3952fe9851ae</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/no-more-vacuum-zero-downtime-cut-over-network-impact-not-in-optimization-scaling-postgres-275-1</link>
                                <description>
                                            <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss getting rid of vacuum, how to do zero-downtime cut-overs, analyzing the impact of slow networks and seeing a not in optimization.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/275-no-more-vacuum-zero-downtime-cut-over-network-impact-not-in-optimization/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss getting rid of vacuum, how to do zero-downtime cut-overs, analyzing the impact of slow networks and seeing a not in optimization.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/275-no-more-vacuum-zero-downtime-cut-over-network-impact-not-in-optimization/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[No More Vacuum, Zero-Downtime Cut-Over, Network Impact, Not In Optimization | Scaling Postgres 275]]>
                </itunes:title>
                                    <itunes:episode>275</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss getting rid of vacuum, how to do zero-downtime cut-overs, analyzing the impact of slow networks and seeing a not in optimization.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/275-no-more-vacuum-zero-downtime-cut-over-network-impact-not-in-optimization/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551155/sp275.mp3" length="25521423"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss getting rid of vacuum, how to do zero-downtime cut-overs, analyzing the impact of slow networks and seeing a not in optimization.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/275-no-more-vacuum-zero-downtime-cut-over-network-impact-not-in-optimization/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551155/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:13:17</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Subquery Performance, Avoid Update Locking, Column Changes, Outage Workshop | Scaling Postgres 274]]>
                </title>
                <pubDate>Sun, 16 Jul 2023 21:14:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    cbb92d70-2e77-4ba3-a420-808a58274323</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/subquery-performance-avoid-update-locking-column-changes-outage-workshop-scaling-postgres-274-1</link>
                                <description>
                                            <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss subquery performance, how to avoid excessive locking when doing updates, how to change a columns datatype without excessive locking and lessons from an upgrade outage.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/274-subquery-performance-avoid-update-locking-column-changes-outage-workshop/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss subquery performance, how to avoid excessive locking when doing updates, how to change a columns datatype without excessive locking and lessons from an upgrade outage.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/274-subquery-performance-avoid-update-locking-column-changes-outage-workshop/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Subquery Performance, Avoid Update Locking, Column Changes, Outage Workshop | Scaling Postgres 274]]>
                </itunes:title>
                                    <itunes:episode>274</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss subquery performance, how to avoid excessive locking when doing updates, how to change a columns datatype without excessive locking and lessons from an upgrade outage.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/274-subquery-performance-avoid-update-locking-column-changes-outage-workshop/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551156/sp274.mp3" length="28182987"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss subquery performance, how to avoid excessive locking when doing updates, how to change a columns datatype without excessive locking and lessons from an upgrade outage.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/274-subquery-performance-avoid-update-locking-column-changes-outage-workshop/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551156/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:40</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Debian / Ubuntu Packaging, ivfflat Indexes, In vs Any, View Logging | Scaling Postgres 273]]>
                </title>
                <pubDate>Mon, 10 Jul 2023 00:42:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    91ae53a7-6d0f-4d3d-a0d3-4aff57fad49a</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/debian-ubuntu-packaging-ivfflat-indexes-in-vs-any-view-logging-scaling-postgres-273-1</link>
                                <description>
                                            <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss how Debian &amp; Ubuntu package Postgres, how ifflat indexes work, in vs any performance and how to log view usage.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/273-debian-ubuntu-packages-ivfflat-indexes-in-vs-any-view-logging/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss how Debian & Ubuntu package Postgres, how ifflat indexes work, in vs any performance and how to log view usage.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/273-debian-ubuntu-packages-ivfflat-indexes-in-vs-any-view-logging/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Debian / Ubuntu Packaging, ivfflat Indexes, In vs Any, View Logging | Scaling Postgres 273]]>
                </itunes:title>
                                    <itunes:episode>273</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss how Debian &amp; Ubuntu package Postgres, how ifflat indexes work, in vs any performance and how to log view usage.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/273-debian-ubuntu-packages-ivfflat-indexes-in-vs-any-view-logging/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551157/sp273.mp3" length="29923369"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss how Debian & Ubuntu package Postgres, how ifflat indexes work, in vs any performance and how to log view usage.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/273-debian-ubuntu-packages-ivfflat-indexes-in-vs-any-view-logging/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551157/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:35</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres 16 Beta 2, The Rise of Vectors, FDW Performance, Unused Indexes | Scaling Postgres 272]]>
                </title>
                <pubDate>Mon, 03 Jul 2023 03:10:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    8c8827dc-75a5-4fae-bfd7-ab726d161781</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/postgres-16-beta-2-the-rise-of-vectors-fdw-performance-unused-indexes-scaling-postgres-272-1</link>
                                <description>
                                            <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss the release of Postgres 16 Beta 2, the rise of vectors and storing them, Foreign Data Wrapper performance and how to identify unused indexes.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/272-postgres-16-beta-2-rise-of-vectors-fdw-performance-unused-indexes/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss the release of Postgres 16 Beta 2, the rise of vectors and storing them, Foreign Data Wrapper performance and how to identify unused indexes.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/272-postgres-16-beta-2-rise-of-vectors-fdw-performance-unused-indexes/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres 16 Beta 2, The Rise of Vectors, FDW Performance, Unused Indexes | Scaling Postgres 272]]>
                </itunes:title>
                                    <itunes:episode>272</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss the release of Postgres 16 Beta 2, the rise of vectors and storing them, Foreign Data Wrapper performance and how to identify unused indexes.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/272-postgres-16-beta-2-rise-of-vectors-fdw-performance-unused-indexes/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551158/sp272.mp3" length="28129489"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss the release of Postgres 16 Beta 2, the rise of vectors and storing them, Foreign Data Wrapper performance and how to identify unused indexes.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/272-postgres-16-beta-2-rise-of-vectors-fdw-performance-unused-indexes/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551158/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:39</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[30% Faster, UUID Downsides, Growing WAL, Processes vs. Threads | Scaling Postgres 271]]>
                </title>
                <pubDate>Mon, 26 Jun 2023 00:28:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    d9c4eaa1-2ad4-4f07-a753-7db22e82a082</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/30-faster-uuid-downsides-growing-wal-processes-vs-threads-scaling-postgres-271-1</link>
                                <description>
                                            <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss how to get 30% faster performance, the downsides of UUIDs, having too much WAL and whether Postgres should use processes or threads.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/271-30-percent-faster-uuid-downsides-growing-wal-processes-vs-threads/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss how to get 30% faster performance, the downsides of UUIDs, having too much WAL and whether Postgres should use processes or threads.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/271-30-percent-faster-uuid-downsides-growing-wal-processes-vs-threads/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[30% Faster, UUID Downsides, Growing WAL, Processes vs. Threads | Scaling Postgres 271]]>
                </itunes:title>
                                    <itunes:episode>271</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss how to get 30% faster performance, the downsides of UUIDs, having too much WAL and whether Postgres should use processes or threads.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/271-30-percent-faster-uuid-downsides-growing-wal-processes-vs-threads/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551159/sp271.mp3" length="31501583"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss how to get 30% faster performance, the downsides of UUIDs, having too much WAL and whether Postgres should use processes or threads.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/271-30-percent-faster-uuid-downsides-growing-wal-processes-vs-threads/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551159/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:16:24</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Data Skew, Monitoring, Remote Access CSV, Documentation | Scaling Postgres 270]]>
                </title>
                <pubDate>Sun, 18 Jun 2023 21:10:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    4de03be4-e023-4d81-8a8e-de88393c348f</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/data-skew-monitoring-remote-access-csv-documentation-scaling-postgres-270-1</link>
                                <description>
                                            <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss how to handle data skew, tools for Postgres monitoring, how to load data remotely and Postgres documentation.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/270-data-skew-monitoring-remote-access-csv-documentation/</p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss how to handle data skew, tools for Postgres monitoring, how to load data remotely and Postgres documentation.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/270-data-skew-monitoring-remote-access-csv-documentation/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Data Skew, Monitoring, Remote Access CSV, Documentation | Scaling Postgres 270]]>
                </itunes:title>
                                    <itunes:episode>270</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss how to handle data skew, tools for Postgres monitoring, how to load data remotely and Postgres documentation.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/270-data-skew-monitoring-remote-access-csv-documentation/</p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551160/sp270.mp3" length="27408091"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss how to handle data skew, tools for Postgres monitoring, how to load data remotely and Postgres documentation.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/270-data-skew-monitoring-remote-access-csv-documentation/
 ]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551160/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:16</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Upgrade Struggles, Hyperloglog, PgBouncer Usage, Postgres Scaling | Scaling Postgres 269]]>
                </title>
                <pubDate>Sun, 11 Jun 2023 23:45:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    ee71c0b5-0e39-4405-92a2-65f1269b2f35</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/upgrade-struggles-hyperloglog-pgbouncer-usage-postgres-scaling-scaling-postgres-269-1</link>
                                <description>
                                            <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss Postgres upgrade struggles, how and why to use hyperloglog, using pgbouncer for session vs. transaction pooling, and methods to scale Postgres.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/269-upgrade-struggles-hyperloglog-pgbouncer-usage-postgres-scaling/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss Postgres upgrade struggles, how and why to use hyperloglog, using pgbouncer for session vs. transaction pooling, and methods to scale Postgres.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/269-upgrade-struggles-hyperloglog-pgbouncer-usage-postgres-scaling/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Upgrade Struggles, Hyperloglog, PgBouncer Usage, Postgres Scaling | Scaling Postgres 269]]>
                </itunes:title>
                                    <itunes:episode>269</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss Postgres upgrade struggles, how and why to use hyperloglog, using pgbouncer for session vs. transaction pooling, and methods to scale Postgres.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/269-upgrade-struggles-hyperloglog-pgbouncer-usage-postgres-scaling/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551161/sp269.mp3" length="35901858"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss Postgres upgrade struggles, how and why to use hyperloglog, using pgbouncer for session vs. transaction pooling, and methods to scale Postgres.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/269-upgrade-struggles-hyperloglog-pgbouncer-usage-postgres-scaling/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551161/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:18:41</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Faster Copy, psql Variables, backup_label, Bad Encoding | Scaling Postgres 268]]>
                </title>
                <pubDate>Sun, 04 Jun 2023 21:14:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    9d61bd01-45a3-40f2-91b6-e6d5ad0520fc</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/faster-copy-psql-variables-backup-label-bad-encoding-scaling-postgres-268-1</link>
                                <description>
                                            <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss faster COPY in Postgres 16, how to use psql variables, the importance of backup_label and issues with bad character encoding.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/268-faster-copy-psql-variables-backup_label-bad-encoding/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss faster COPY in Postgres 16, how to use psql variables, the importance of backup_label and issues with bad character encoding.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/268-faster-copy-psql-variables-backup_label-bad-encoding/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Faster Copy, psql Variables, backup_label, Bad Encoding | Scaling Postgres 268]]>
                </itunes:title>
                                    <itunes:episode>268</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss faster COPY in Postgres 16, how to use psql variables, the importance of backup_label and issues with bad character encoding.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/268-faster-copy-psql-variables-backup_label-bad-encoding/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551162/sp268.mp3" length="22354964"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss faster COPY in Postgres 16, how to use psql variables, the importance of backup_label and issues with bad character encoding.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/268-faster-copy-psql-variables-backup_label-bad-encoding/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551162/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:11:38</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[PostgreSQL 16 Beta 1, Rust Functions, Partitioning Memory Problems, Tags & Arrays | Scaling Postgres 267]]>
                </title>
                <pubDate>Sun, 28 May 2023 21:11:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    4a7d36d3-d001-43ac-a7d9-1385742d1ca4</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/postgresql-16-beta-1-rust-functions-partitioning-memory-problems-tags-arrays-scaling-postgres-267-1</link>
                                <description>
                                            <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss the release of PostgreSQL 16 Beta 1, creating Rust functions with PL/Rust, memory problems related to partitioning and prepared statements, and modeling tags with arrays.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/267-postgres-16-beta-1-rust-functions-partitioning-memory-problems-tags-arrays/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss the release of PostgreSQL 16 Beta 1, creating Rust functions with PL/Rust, memory problems related to partitioning and prepared statements, and modeling tags with arrays.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/267-postgres-16-beta-1-rust-functions-partitioning-memory-problems-tags-arrays/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[PostgreSQL 16 Beta 1, Rust Functions, Partitioning Memory Problems, Tags & Arrays | Scaling Postgres 267]]>
                </itunes:title>
                                    <itunes:episode>267</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss the release of PostgreSQL 16 Beta 1, creating Rust functions with PL/Rust, memory problems related to partitioning and prepared statements, and modeling tags with arrays.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/267-postgres-16-beta-1-rust-functions-partitioning-memory-problems-tags-arrays/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551164/sp267.mp3" length="30844551"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss the release of PostgreSQL 16 Beta 1, creating Rust functions with PL/Rust, memory problems related to partitioning and prepared statements, and modeling tags with arrays.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/267-postgres-16-beta-1-rust-functions-partitioning-memory-problems-tags-arrays/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551164/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:16:03</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres Releases, Postgres Distributed, Privilege Template, Real-Time Dashboards | Scaling Postgres 266]]>
                </title>
                <pubDate>Sun, 21 May 2023 21:43:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    9f5a08ac-7e6c-49c8-a548-7bda7531df5a</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/postgres-releases-postgres-distributed-privilege-template-real-time-dashboards-scaling-postgres-266-1</link>
                                <description>
                                            <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss new Postgres releases, EDB Postgres Distributed, a privilege template and real-time dashboards.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/266-postgres-releases-postgres-distributed-privilege-template-real-time-dashboard/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss new Postgres releases, EDB Postgres Distributed, a privilege template and real-time dashboards.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/266-postgres-releases-postgres-distributed-privilege-template-real-time-dashboard/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres Releases, Postgres Distributed, Privilege Template, Real-Time Dashboards | Scaling Postgres 266]]>
                </itunes:title>
                                    <itunes:episode>266</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss new Postgres releases, EDB Postgres Distributed, a privilege template and real-time dashboards.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/266-postgres-releases-postgres-distributed-privilege-template-real-time-dashboard/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551163/sp266.mp3" length="32444499"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss new Postgres releases, EDB Postgres Distributed, a privilege template and real-time dashboards.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/266-postgres-releases-postgres-distributed-privilege-template-real-time-dashboard/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551163/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:16:53</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[pg_stat_statements, Transaction ID Wraparound, Consultant Knowledge, CitusCon | Scaling Postgres 265]]>
                </title>
                <pubDate>Sun, 14 May 2023 21:26:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    e4a2f8ae-ffcb-4870-bef5-f2930fade53c</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/pg-stat-statements-transaction-id-wraparound-consultant-knowledge-cituscon-scaling-postgres-265-1</link>
                                <description>
                                            <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss different ways to use pg_stat_statements, how to handle transaction ID wraparound, consultant knowledge and all the videos of CitusCon.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/265-pg_stat_statements-transaction-id-wraparound-consultant-knowledge-cituscon/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss different ways to use pg_stat_statements, how to handle transaction ID wraparound, consultant knowledge and all the videos of CitusCon.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/265-pg_stat_statements-transaction-id-wraparound-consultant-knowledge-cituscon/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[pg_stat_statements, Transaction ID Wraparound, Consultant Knowledge, CitusCon | Scaling Postgres 265]]>
                </itunes:title>
                                    <itunes:episode>265</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss different ways to use pg_stat_statements, how to handle transaction ID wraparound, consultant knowledge and all the videos of CitusCon.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/265-pg_stat_statements-transaction-id-wraparound-consultant-knowledge-cituscon/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551165/sp265.mp3" length="32237191"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss different ways to use pg_stat_statements, how to handle transaction ID wraparound, consultant knowledge and all the videos of CitusCon.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/265-pg_stat_statements-transaction-id-wraparound-consultant-knowledge-cituscon/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551165/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:16:47</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[The Worst Part, Pluggable Storage, A Busy System, Data Architecture | Scaling Postgres 264]]>
                </title>
                <pubDate>Sun, 07 May 2023 20:17:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    d12e2759-fbda-4873-87d5-ccaede92e98f</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/the-worst-part-pluggable-storage-a-busy-system-data-architecture-scaling-postgres-264-1</link>
                                <description>
                                            <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss the worst part of Postgres, the status of pluggable storage, what makes a busy system and methods for managing different data architectures.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/264-worst-part-pluggable-storage-busy-system-data-architecture/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss the worst part of Postgres, the status of pluggable storage, what makes a busy system and methods for managing different data architectures.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/264-worst-part-pluggable-storage-busy-system-data-architecture/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[The Worst Part, Pluggable Storage, A Busy System, Data Architecture | Scaling Postgres 264]]>
                </itunes:title>
                                    <itunes:episode>264</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss the worst part of Postgres, the status of pluggable storage, what makes a busy system and methods for managing different data architectures.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/264-worst-part-pluggable-storage-busy-system-data-architecture/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551166/sp264.mp3" length="32691931"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss the worst part of Postgres, the status of pluggable storage, what makes a busy system and methods for managing different data architectures.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/264-worst-part-pluggable-storage-busy-system-data-architecture/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551166/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:17:01</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[LZ4 & ZSTD Compression, Avoiding Problems, Triggers Simplify, Indexes Can Hurt | Scaling Postgres 263]]>
                </title>
                <pubDate>Mon, 01 May 2023 13:07:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    6dd80c2f-113c-4795-9be8-8bf2b82d4899</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/lz4-zstd-compression-avoiding-problems-triggers-simplify-indexes-can-hurt-scaling-postgres-263-1</link>
                                <description>
                                            <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss LZ4 and ZSTD pg_dump compression, how to avoid problems, can triggers simplify and indexes can hurt.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/263-lz4-zstd-compression-avoiding-problems-triggers-simplify-indexes-can-hurt/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss LZ4 and ZSTD pg_dump compression, how to avoid problems, can triggers simplify and indexes can hurt.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/263-lz4-zstd-compression-avoiding-problems-triggers-simplify-indexes-can-hurt/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[LZ4 & ZSTD Compression, Avoiding Problems, Triggers Simplify, Indexes Can Hurt | Scaling Postgres 263]]>
                </itunes:title>
                                    <itunes:episode>263</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss LZ4 and ZSTD pg_dump compression, how to avoid problems, can triggers simplify and indexes can hurt.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/263-lz4-zstd-compression-avoiding-problems-triggers-simplify-indexes-can-hurt/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551168/sp263-2.mp3" length="36929201"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss LZ4 and ZSTD pg_dump compression, how to avoid problems, can triggers simplify and indexes can hurt.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/263-lz4-zstd-compression-avoiding-problems-triggers-simplify-indexes-can-hurt/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551168/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:19:14</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[pg_failover_slots, Standby Logical Decoding, Trusted Language Extensions, Postgres Package Manager | Scaling Postgres 262]]>
                </title>
                <pubDate>Sun, 23 Apr 2023 21:50:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    215aa252-320e-4da8-81a1-e6429dc6231b</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/pg-failover-slots-standby-logical-decoding-trusted-language-extensions-postgres-package-manager-scaling-postgres-262-1</link>
                                <description>
                                            <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss the pg_failover_slots extension, how PG16 allows logical decoding on standbys, what are trusted language extensions and how a package manager has been built for them.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/262-pg_failover_slots-standby-logical-decoding-trusted-language-extensions-postgres-package-manager/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss the pg_failover_slots extension, how PG16 allows logical decoding on standbys, what are trusted language extensions and how a package manager has been built for them.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/262-pg_failover_slots-standby-logical-decoding-trusted-language-extensions-postgres-package-manager/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[pg_failover_slots, Standby Logical Decoding, Trusted Language Extensions, Postgres Package Manager | Scaling Postgres 262]]>
                </itunes:title>
                                    <itunes:episode>262</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss the pg_failover_slots extension, how PG16 allows logical decoding on standbys, what are trusted language extensions and how a package manager has been built for them.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/262-pg_failover_slots-standby-logical-decoding-trusted-language-extensions-postgres-package-manager/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551167/sp262.mp3" length="28263235"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss the pg_failover_slots extension, how PG16 allows logical decoding on standbys, what are trusted language extensions and how a package manager has been built for them.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/262-pg_failover_slots-standby-logical-decoding-trusted-language-extensions-postgres-package-manager/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551167/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:43</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Easy Foreign Data Wrappers, JSONB Cheatsheet, Updating Cost Limit, Parallel Aggregate | Scaling Postgres 261]]>
                </title>
                <pubDate>Mon, 17 Apr 2023 01:08:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    fad79f96-b4aa-4576-82d5-498b206c3e63</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/easy-foreign-data-wrappers-jsonb-cheatsheet-updating-cost-limit-parallel-aggregate-scaling-postgres-261-1</link>
                                <description>
                                            <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss how to easily crate a foreign data wrapper to consume an API, present a convenient JSONB cheatsheet, changes to updating the vacuum cost limit and new parallel aggregates.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/261-easy-foreign-data-wrappers-jsonb-cheatsheet-updating-cost-limit-parallel-aggregate/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss how to easily crate a foreign data wrapper to consume an API, present a convenient JSONB cheatsheet, changes to updating the vacuum cost limit and new parallel aggregates.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/261-easy-foreign-data-wrappers-jsonb-cheatsheet-updating-cost-limit-parallel-aggregate/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Easy Foreign Data Wrappers, JSONB Cheatsheet, Updating Cost Limit, Parallel Aggregate | Scaling Postgres 261]]>
                </itunes:title>
                                    <itunes:episode>261</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss how to easily crate a foreign data wrapper to consume an API, present a convenient JSONB cheatsheet, changes to updating the vacuum cost limit and new parallel aggregates.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/261-easy-foreign-data-wrappers-jsonb-cheatsheet-updating-cost-limit-parallel-aggregate/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551169/sp261.mp3" length="31516630"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss how to easily crate a foreign data wrapper to consume an API, present a convenient JSONB cheatsheet, changes to updating the vacuum cost limit and new parallel aggregates.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/261-easy-foreign-data-wrappers-jsonb-cheatsheet-updating-cost-limit-parallel-aggregate/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551169/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:16:24</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[PL/Rust, Row Locks, Postgres Errors, SQL 2023 | Scaling Postgres 260]]>
                </title>
                <pubDate>Sun, 09 Apr 2023 18:17:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    01c97b45-e468-43ae-a7c2-783d402e450a</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/plrust-row-locks-postgres-errors-sql-2023-scaling-postgres-260-1</link>
                                <description>
                                            <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss PL/Rust 1.0 release, row locks, Postgres errors and the new SQL 2023 standard.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/260-plrust-row-locks-postgres-errors-sql-2023/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss PL/Rust 1.0 release, row locks, Postgres errors and the new SQL 2023 standard.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/260-plrust-row-locks-postgres-errors-sql-2023/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[PL/Rust, Row Locks, Postgres Errors, SQL 2023 | Scaling Postgres 260]]>
                </itunes:title>
                                    <itunes:episode>260</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss PL/Rust 1.0 release, row locks, Postgres errors and the new SQL 2023 standard.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/260-plrust-row-locks-postgres-errors-sql-2023/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551170/sp260.mp3" length="23341348"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss PL/Rust 1.0 release, row locks, Postgres errors and the new SQL 2023 standard.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/260-plrust-row-locks-postgres-errors-sql-2023/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551170/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:09</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Recovery Time, Lost Data, Production Ready, PG16 Highlights | Scaling Postgres 259]]>
                </title>
                <pubDate>Sun, 02 Apr 2023 21:34:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    d71374af-18dc-45ab-afb2-985506c3c4cd</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/recovery-time-lost-data-production-ready-pg16-highlights-scaling-postgres-259-1</link>
                                <description>
                                            <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss max_wal_size as it relates to recovery time, losing your data with collation changes, getting production ready and highlights coming in Postgres 16.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/259-recovery-time-lost-data-production-ready-pg16-highlights/"> https://www.scalingpostgres.com/episodes/258-logical-replication-database-antipatterns-max_wal_size-delete-vs-truncate/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss max_wal_size as it relates to recovery time, losing your data with collation changes, getting production ready and highlights coming in Postgres 16.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/258-logical-replication-database-antipatterns-max_wal_size-delete-vs-truncate/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Recovery Time, Lost Data, Production Ready, PG16 Highlights | Scaling Postgres 259]]>
                </itunes:title>
                                    <itunes:episode>259</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss max_wal_size as it relates to recovery time, losing your data with collation changes, getting production ready and highlights coming in Postgres 16.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/259-recovery-time-lost-data-production-ready-pg16-highlights/"> https://www.scalingpostgres.com/episodes/258-logical-replication-database-antipatterns-max_wal_size-delete-vs-truncate/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551171/sp259.mp3" length="26068114"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss max_wal_size as it relates to recovery time, losing your data with collation changes, getting production ready and highlights coming in Postgres 16.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/258-logical-replication-database-antipatterns-max_wal_size-delete-vs-truncate/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551171/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:13:34</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Logical Replication, Database Antipatterns, max_wal_size Setting, Delete vs. Truncate | Scaling Postgres 258]]>
                </title>
                <pubDate>Mon, 27 Mar 2023 01:11:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    5ef0a83c-a066-48bd-81f3-f9f431cad24b</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/logical-replication-database-antipatterns-max-wal-size-setting-delete-vs-truncate-scaling-postgres-258-1</link>
                                <description>
                                            <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss use cases for logical replication, database anti-patterns, how to set max_wal_size and the difference between delete and truncate.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/258-logical-replication-database-antipatterns-max_wal_size-delete-vs-truncate/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss use cases for logical replication, database anti-patterns, how to set max_wal_size and the difference between delete and truncate.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/258-logical-replication-database-antipatterns-max_wal_size-delete-vs-truncate/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Logical Replication, Database Antipatterns, max_wal_size Setting, Delete vs. Truncate | Scaling Postgres 258]]>
                </itunes:title>
                                    <itunes:episode>258</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p> </p>
<p>In this episode of Scaling Postgres, we discuss use cases for logical replication, database anti-patterns, how to set max_wal_size and the difference between delete and truncate.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/258-logical-replication-database-antipatterns-max_wal_size-delete-vs-truncate/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551172/sp258.mp3" length="16696633"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[ 
In this episode of Scaling Postgres, we discuss use cases for logical replication, database anti-patterns, how to set max_wal_size and the difference between delete and truncate.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/258-logical-replication-database-antipatterns-max_wal_size-delete-vs-truncate/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551172/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:08:41</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Adopting PgCat, Time Bins, work_mem Settings, Bad Constraints | Scaling Postgres 257]]>
                </title>
                <pubDate>Sun, 19 Mar 2023 23:57:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    75fe0751-0219-483c-b7a6-cad4bba59950</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/adopting-pgcat-time-bins-work-mem-settings-bad-constraints-scaling-postgres-257-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss Instacart adopting PgCat, binning or bucketing your data by time, the best settings for work_mem and how to avoid bad check constraints.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/257-adopting-pgcat-time-bins-work_mem-settings-bad-constraints/"> https://www.scalingpostgres.com/episodes/257-adopting-pgcat-time-bins-work_mem-settings-bad-constraints/</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss Instacart adopting PgCat, binning or bucketing your data by time, the best settings for work_mem and how to avoid bad check constraints.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/257-adopting-pgcat-time-bins-work_mem-settings-bad-constraints/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Adopting PgCat, Time Bins, work_mem Settings, Bad Constraints | Scaling Postgres 257]]>
                </itunes:title>
                                    <itunes:episode>257</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss Instacart adopting PgCat, binning or bucketing your data by time, the best settings for work_mem and how to avoid bad check constraints.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/257-adopting-pgcat-time-bins-work_mem-settings-bad-constraints/"> https://www.scalingpostgres.com/episodes/257-adopting-pgcat-time-bins-work_mem-settings-bad-constraints/</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551175/sp257.mp3" length="37000254"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss Instacart adopting PgCat, binning or bucketing your data by time, the best settings for work_mem and how to avoid bad check constraints.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/257-adopting-pgcat-time-bins-work_mem-settings-bad-constraints/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551175/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:19:16</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[11TB WAL, pgec Writes, Patroni 3 & Citus, PostgREST | Scaling Postgres 256]]>
                </title>
                <pubDate>Sun, 12 Mar 2023 22:35:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    21d7608a-ad49-4c3e-b971-0f1eb1293fdc</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/11tb-wal-pgec-writes-patroni-3-citus-postgrest-scaling-postgres-256-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss WAL growing to 11 Terabytes, pgec supporting writes, Patroni 3.0 &amp; Citus for high availability, and setting up PostgREST.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/256-11tb-wal-pgec-writes-patroni-3-citus-postgrest/">https://www.scalingpostgres.com/episodes/255-integer-overflow-user-friendly-permissions-dump-logical-replication-worker-config/</a> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss WAL growing to 11 Terabytes, pgec supporting writes, Patroni 3.0 & Citus for high availability, and setting up PostgREST.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/255-integer-overflow-user-friendly-permissions-dump-logical-replication-worker-config/ ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[11TB WAL, pgec Writes, Patroni 3 & Citus, PostgREST | Scaling Postgres 256]]>
                </itunes:title>
                                    <itunes:episode>256</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss WAL growing to 11 Terabytes, pgec supporting writes, Patroni 3.0 &amp; Citus for high availability, and setting up PostgREST.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a href="https://www.scalingpostgres.com/episodes/256-11tb-wal-pgec-writes-patroni-3-citus-postgrest/">https://www.scalingpostgres.com/episodes/255-integer-overflow-user-friendly-permissions-dump-logical-replication-worker-config/</a> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551173/sp256.mp3" length="23793580"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss WAL growing to 11 Terabytes, pgec supporting writes, Patroni 3.0 & Citus for high availability, and setting up PostgREST.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/255-integer-overflow-user-friendly-permissions-dump-logical-replication-worker-config/ ]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551173/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:23</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Integer Overflow, User-Friendly Permissions, Dump & Logical Replication, Worker Config | Scaling Postgres 255]]>
                </title>
                <pubDate>Sun, 05 Mar 2023 22:39:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    f215ca5a-c2bc-4009-8f5e-78eac63402b9</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/integer-overflow-user-friendly-permissions-dump-logical-replication-worker-config-scaling-postgres-255-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to detect &amp; handle integer overflows, a wish for user-friendly permissions, using a dump to start logical replication and configuring background workers.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/255-integer-overflow-user-friendly-permissions-dump-logical-replication-worker-config/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to detect & handle integer overflows, a wish for user-friendly permissions, using a dump to start logical replication and configuring background workers.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/255-integer-overflow-user-friendly-permissions-dump-logical-replication-worker-config/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Integer Overflow, User-Friendly Permissions, Dump & Logical Replication, Worker Config | Scaling Postgres 255]]>
                </itunes:title>
                                    <itunes:episode>255</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to detect &amp; handle integer overflows, a wish for user-friendly permissions, using a dump to start logical replication and configuring background workers.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/255-integer-overflow-user-friendly-permissions-dump-logical-replication-worker-config/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551174/sp255.mp3" length="34021877"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to detect & handle integer overflows, a wish for user-friendly permissions, using a dump to start logical replication and configuring background workers.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/255-integer-overflow-user-friendly-permissions-dump-logical-replication-worker-config/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551174/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:17:43</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[PG Edge Cache, Postgres & OpenAI, citext to Collations, Compression Options | Scaling Postgres 254]]>
                </title>
                <pubDate>Sun, 26 Feb 2023 22:12:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    83396c74-74ec-4bba-891d-466a12053ae0</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/pg-edge-cache-postgres-openai-citext-to-collations-compression-options-scaling-postgres-254-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss PG Edge Cache, using Postgres &amp; OpenAI, migrating citext to case-insenstive collations and PG16 compression options.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a class="yt-simple-endpoint style-scope yt-formatted-string" href="https://www.youtube.com/redirect?event=video_description&amp;redir_token=QUFFLUhqazZ4N1g4Qm5RaklHdG1VZGhkSUpSNTQwRV9oUXxBQ3Jtc0tsMDYxZjFuRWp1V3FFUk5fbUxxRUU4Ykw1SEJzMWxfX0o1ME9JN1ZhcU1nRThfVm1IczRKMXpqbm85WTRIV1pROC1VT29veDVOSXc3R1BnNlA5WXZVWEl0VE5PTHNYRHN5QWlJOU5HWnI4ZFpQbm1wbw&amp;q=https%3A%2F%2Fwww.scalingpostgres.com%2F&amp;v=VTbJjssLmsM" target="_blank" rel="noreferrer noopener">https://www.scalingpostgres.com</a></p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss PG Edge Cache, using Postgres & OpenAI, migrating citext to case-insenstive collations and PG16 compression options.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[PG Edge Cache, Postgres & OpenAI, citext to Collations, Compression Options | Scaling Postgres 254]]>
                </itunes:title>
                                    <itunes:episode>254</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss PG Edge Cache, using Postgres &amp; OpenAI, migrating citext to case-insenstive collations and PG16 compression options.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a class="yt-simple-endpoint style-scope yt-formatted-string" href="https://www.youtube.com/redirect?event=video_description&amp;redir_token=QUFFLUhqazZ4N1g4Qm5RaklHdG1VZGhkSUpSNTQwRV9oUXxBQ3Jtc0tsMDYxZjFuRWp1V3FFUk5fbUxxRUU4Ykw1SEJzMWxfX0o1ME9JN1ZhcU1nRThfVm1IczRKMXpqbm85WTRIV1pROC1VT29veDVOSXc3R1BnNlA5WXZVWEl0VE5PTHNYRHN5QWlJOU5HWnI4ZFpQbm1wbw&amp;q=https%3A%2F%2Fwww.scalingpostgres.com%2F&amp;v=VTbJjssLmsM" target="_blank" rel="noreferrer noopener">https://www.scalingpostgres.com</a></p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551176/sp254.mp3" length="25426964"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss PG Edge Cache, using Postgres & OpenAI, migrating citext to case-insenstive collations and PG16 compression options.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com
 ]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551176/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:13:14</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Unlogged Tables, pg_stat_io, Type Constraints, Text Types | Scaling Postgres 253]]>
                </title>
                <pubDate>Sun, 19 Feb 2023 23:21:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    4d925475-e8e3-4516-907e-57537a300c58</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/unlogged-tables-pg-stat-io-type-constraints-text-types-scaling-postgres-253-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss working with unlogged tables, the new pg_stat_io feature, handling complex type constraints and choosing the best text type.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a class="yt-simple-endpoint style-scope yt-formatted-string" href="https://www.youtube.com/redirect?event=video_description&amp;redir_token=QUFFLUhqazZ4N1g4Qm5RaklHdG1VZGhkSUpSNTQwRV9oUXxBQ3Jtc0tsMDYxZjFuRWp1V3FFUk5fbUxxRUU4Ykw1SEJzMWxfX0o1ME9JN1ZhcU1nRThfVm1IczRKMXpqbm85WTRIV1pROC1VT29veDVOSXc3R1BnNlA5WXZVWEl0VE5PTHNYRHN5QWlJOU5HWnI4ZFpQbm1wbw&amp;q=https%3A%2F%2Fwww.scalingpostgres.com%2F&amp;v=VTbJjssLmsM" target="_blank" rel="noreferrer noopener">https://www.scalingpostgres.com</a></p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss working with unlogged tables, the new pg_stat_io feature, handling complex type constraints and choosing the best text type.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Unlogged Tables, pg_stat_io, Type Constraints, Text Types | Scaling Postgres 253]]>
                </itunes:title>
                                    <itunes:episode>253</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss working with unlogged tables, the new pg_stat_io feature, handling complex type constraints and choosing the best text type.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a class="yt-simple-endpoint style-scope yt-formatted-string" href="https://www.youtube.com/redirect?event=video_description&amp;redir_token=QUFFLUhqazZ4N1g4Qm5RaklHdG1VZGhkSUpSNTQwRV9oUXxBQ3Jtc0tsMDYxZjFuRWp1V3FFUk5fbUxxRUU4Ykw1SEJzMWxfX0o1ME9JN1ZhcU1nRThfVm1IczRKMXpqbm85WTRIV1pROC1VT29veDVOSXc3R1BnNlA5WXZVWEl0VE5PTHNYRHN5QWlJOU5HWnI4ZFpQbm1wbw&amp;q=https%3A%2F%2Fwww.scalingpostgres.com%2F&amp;v=VTbJjssLmsM" target="_blank" rel="noreferrer noopener">https://www.scalingpostgres.com</a></p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551177/sp253.mp3" length="31527497"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss working with unlogged tables, the new pg_stat_io feature, handling complex type constraints and choosing the best text type.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551177/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:16:25</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres Releases, Performance Secrets, Don't Do This, Filter vs. Case | Scaling Postgres 252]]>
                </title>
                <pubDate>Sun, 12 Feb 2023 23:28:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    c9412265-50b2-445e-85c3-8cfbf7b5ec75</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/postgres-releases-performance-secrets-dont-do-this-filter-vs-case-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss new Postgres releases, performance secrets, things not to do and filter vs. case.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a class="yt-simple-endpoint style-scope yt-formatted-string" href="https://www.youtube.com/redirect?event=video_description&amp;redir_token=QUFFLUhqazZ4N1g4Qm5RaklHdG1VZGhkSUpSNTQwRV9oUXxBQ3Jtc0tsMDYxZjFuRWp1V3FFUk5fbUxxRUU4Ykw1SEJzMWxfX0o1ME9JN1ZhcU1nRThfVm1IczRKMXpqbm85WTRIV1pROC1VT29veDVOSXc3R1BnNlA5WXZVWEl0VE5PTHNYRHN5QWlJOU5HWnI4ZFpQbm1wbw&amp;q=https%3A%2F%2Fwww.scalingpostgres.com%2F&amp;v=VTbJjssLmsM" target="_blank" rel="noreferrer noopener">https://www.scalingpostgres.com</a> </p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss new Postgres releases, performance secrets, things not to do and filter vs. case.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com 
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres Releases, Performance Secrets, Don't Do This, Filter vs. Case | Scaling Postgres 252]]>
                </itunes:title>
                                    <itunes:episode>252</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss new Postgres releases, performance secrets, things not to do and filter vs. case.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p><a class="yt-simple-endpoint style-scope yt-formatted-string" href="https://www.youtube.com/redirect?event=video_description&amp;redir_token=QUFFLUhqazZ4N1g4Qm5RaklHdG1VZGhkSUpSNTQwRV9oUXxBQ3Jtc0tsMDYxZjFuRWp1V3FFUk5fbUxxRUU4Ykw1SEJzMWxfX0o1ME9JN1ZhcU1nRThfVm1IczRKMXpqbm85WTRIV1pROC1VT29veDVOSXc3R1BnNlA5WXZVWEl0VE5PTHNYRHN5QWlJOU5HWnI4ZFpQbm1wbw&amp;q=https%3A%2F%2Fwww.scalingpostgres.com%2F&amp;v=VTbJjssLmsM" target="_blank" rel="noreferrer noopener">https://www.scalingpostgres.com</a> </p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551178/sp252.mp3" length="28701257"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss new Postgres releases, performance secrets, things not to do and filter vs. case.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com 
 ]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551178/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:56</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Filter Clause, Hypothetical Index, Non-Relational Data, Using TOAST | Scaling Postgres 251]]>
                </title>
                <pubDate>Sun, 05 Feb 2023 22:34:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    9718bb80-c505-4608-b492-30ad7a98c0b3</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-251-filter-clause-hypothetical-index-non-relational-data-using-toast-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to use the filter clause, create hypothetical indexes, store non-relational data and manage TOAST.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/251-filter-clause-hypothetical-index-non-relational-data-using-toast/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to use the filter clause, create hypothetical indexes, store non-relational data and manage TOAST.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/251-filter-clause-hypothetical-index-non-relational-data-using-toast/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Filter Clause, Hypothetical Index, Non-Relational Data, Using TOAST | Scaling Postgres 251]]>
                </itunes:title>
                                    <itunes:episode>251</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to use the filter clause, create hypothetical indexes, store non-relational data and manage TOAST.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/251-filter-clause-hypothetical-index-non-relational-data-using-toast/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551180/sp251.mp3" length="32513044"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to use the filter clause, create hypothetical indexes, store non-relational data and manage TOAST.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/251-filter-clause-hypothetical-index-non-relational-data-using-toast/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551180/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:16:56</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Performance Issue, Survive Without Superuser, Reserved Connections, Partition Management | Scaling Postgres 250]]>
                </title>
                <pubDate>Mon, 30 Jan 2023 04:23:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    dd177542-2306-41ca-ba6a-01020f5bf682</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-250-performance-issue-survive-without-superuser-reserved-connections-partition-management-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss resolving a performance issue, how PG16 allows you to survive without a superuser, reserving connections and handling partition management.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/250-performance-issue-survive-without-superuser-reserved-connections-partition-management/</p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss resolving a performance issue, how PG16 allows you to survive without a superuser, reserving connections and handling partition management.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/250-performance-issue-survive-without-superuser-reserved-connections-partition-management/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Performance Issue, Survive Without Superuser, Reserved Connections, Partition Management | Scaling Postgres 250]]>
                </itunes:title>
                                    <itunes:episode>250</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss resolving a performance issue, how PG16 allows you to survive without a superuser, reserving connections and handling partition management.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/250-performance-issue-survive-without-superuser-reserved-connections-partition-management/</p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551179/sp250.mp3" length="26975921"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss resolving a performance issue, how PG16 allows you to survive without a superuser, reserving connections and handling partition management.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/250-performance-issue-survive-without-superuser-reserved-connections-partition-management/
 ]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551179/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:03</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Locking Tables, Foreign Key Issue, Slow Decimals, Memoize & Joins | Scaling Postgres 249]]>
                </title>
                <pubDate>Mon, 23 Jan 2023 03:28:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    232654f1-5c9a-4855-8b3a-d7c17bcd1ee3</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-249-locking-tables-foreign-key-issue-slow-decimals-memoize-joins-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss issues with locking tables, foreign keys and slow decimals. We also cover when joins use memoize.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/249-locking-tables-foreign-key-issue-slow-decimals-memoize-joins/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss issues with locking tables, foreign keys and slow decimals. We also cover when joins use memoize.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/249-locking-tables-foreign-key-issue-slow-decimals-memoize-joins/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Locking Tables, Foreign Key Issue, Slow Decimals, Memoize & Joins | Scaling Postgres 249]]>
                </itunes:title>
                                    <itunes:episode>249</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss issues with locking tables, foreign keys and slow decimals. We also cover when joins use memoize.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/249-locking-tables-foreign-key-issue-slow-decimals-memoize-joins/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551181/sp249.mp3" length="17479053"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss issues with locking tables, foreign keys and slow decimals. We also cover when joins use memoize.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/249-locking-tables-foreign-key-issue-slow-decimals-memoize-joins/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551181/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:09:06</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Pagination Solutions, Return Modifications, Insert Deletions, How To JSON | Scaling Postgres 248]]>
                </title>
                <pubDate>Sun, 15 Jan 2023 23:08:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    272f7879-ee6c-40d9-9695-dba4693a75fe</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-248-pagination-solutions-return-modifications-insert-deletions-how-to-json-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss different pagination solutions, how to return modifications, soft deletion alternatives and how to use JSON with PostgreSQL.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/248-pagination-solutions-return-modifications-insert-deletions-how-to-json/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss different pagination solutions, how to return modifications, soft deletion alternatives and how to use JSON with PostgreSQL.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/248-pagination-solutions-return-modifications-insert-deletions-how-to-json/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Pagination Solutions, Return Modifications, Insert Deletions, How To JSON | Scaling Postgres 248]]>
                </itunes:title>
                                    <itunes:episode>248</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss different pagination solutions, how to return modifications, soft deletion alternatives and how to use JSON with PostgreSQL.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/248-pagination-solutions-return-modifications-insert-deletions-how-to-json/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551182/sp248.mp3" length="33287105"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss different pagination solutions, how to return modifications, soft deletion alternatives and how to use JSON with PostgreSQL.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/248-pagination-solutions-return-modifications-insert-deletions-how-to-json/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551182/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:17:20</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Generate Test Data, Faster Archiving, Date Statistics, Useless Indexes | Scaling Postgres 247]]>
                </title>
                <pubDate>Wed, 11 Jan 2023 21:47:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    c9857e1f-e01a-4e25-9463-1e02e31a49a8</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-247-generate-test-data-faster-archiving-date-statistics-useless-indexes-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to generate test data, how WAL archiving is faster in PG15, how to set date statistics on a timestamp and how to avoid useless indexes.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/247-generate-test-data-faster-archiving-date-statistics-useless-indexes/</p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to generate test data, how WAL archiving is faster in PG15, how to set date statistics on a timestamp and how to avoid useless indexes.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/247-generate-test-data-faster-archiving-date-statistics-useless-indexes/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Generate Test Data, Faster Archiving, Date Statistics, Useless Indexes | Scaling Postgres 247]]>
                </itunes:title>
                                    <itunes:episode>247</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to generate test data, how WAL archiving is faster in PG15, how to set date statistics on a timestamp and how to avoid useless indexes.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/247-generate-test-data-faster-archiving-date-statistics-useless-indexes/</p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551183/sp247.mp3" length="27700662"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to generate test data, how WAL archiving is faster in PG15, how to set date statistics on a timestamp and how to avoid useless indexes.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/247-generate-test-data-faster-archiving-date-statistics-useless-indexes/
 ]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551183/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:25</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Columnar Tables, Advent of Code, PG 16 Features, Commit Times | Scaling Postgres 246]]>
                </title>
                <pubDate>Sun, 18 Dec 2022 22:45:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    1877800a-481f-4e35-8214-532fe08e947a</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-246-columnar-tables-advent-of-code-pg-16-features-commit-times-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss columnar table storage, solving Advent of Code using Postgres, new features coming in Postgres 16 and when Postgres development happens.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/246-columnar-tables-advent-of-code-pg16-features-commit-times/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss columnar table storage, solving Advent of Code using Postgres, new features coming in Postgres 16 and when Postgres development happens.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/246-columnar-tables-advent-of-code-pg16-features-commit-times/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Columnar Tables, Advent of Code, PG 16 Features, Commit Times | Scaling Postgres 246]]>
                </itunes:title>
                                    <itunes:episode>246</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss columnar table storage, solving Advent of Code using Postgres, new features coming in Postgres 16 and when Postgres development happens.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/246-columnar-tables-advent-of-code-pg16-features-commit-times/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551184/sp246.mp3" length="19791203"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss columnar table storage, solving Advent of Code using Postgres, new features coming in Postgres 16 and when Postgres development happens.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/246-columnar-tables-advent-of-code-pg16-features-commit-times/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551184/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:10:18</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[ENUMs vs Check Constraints, Faceting With Roaring Bitmaps, Better Scaling, In DB Business Logic | Scaling Postgres 245]]>
                </title>
                <pubDate>Mon, 12 Dec 2022 00:31:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    cdc27d40-bf7d-4fee-97ab-b28026286eab</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-245-enums-vs-check-constraints-faceting-with-roaring-bitmaps-better-scaling-in-db-business-logic-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss ENUMs vs. check constraints, querying table facets with roaring bitmaps, a better way to handle scaling and whether you should store your business logic in Postgres.</p>
<p> </p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/245-enums-vs-check-constraints-faceting-with-roaring-bitmaps-better-scaling-in-db-business-logic/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss ENUMs vs. check constraints, querying table facets with roaring bitmaps, a better way to handle scaling and whether you should store your business logic in Postgres.
 
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/245-enums-vs-check-constraints-faceting-with-roaring-bitmaps-better-scaling-in-db-business-logic/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[ENUMs vs Check Constraints, Faceting With Roaring Bitmaps, Better Scaling, In DB Business Logic | Scaling Postgres 245]]>
                </itunes:title>
                                    <itunes:episode>245</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss ENUMs vs. check constraints, querying table facets with roaring bitmaps, a better way to handle scaling and whether you should store your business logic in Postgres.</p>
<p> </p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/245-enums-vs-check-constraints-faceting-with-roaring-bitmaps-better-scaling-in-db-business-logic/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551185/sp245.mp3" length="22412643"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss ENUMs vs. check constraints, querying table facets with roaring bitmaps, a better way to handle scaling and whether you should store your business logic in Postgres.
 
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/245-enums-vs-check-constraints-faceting-with-roaring-bitmaps-better-scaling-in-db-business-logic/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551185/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:11:40</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Index Merge vs Composite, Transparent Column Encryption, Trusted Language Extensions | Scaling Postgres 244]]>
                </title>
                <pubDate>Sun, 04 Dec 2022 22:57:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    16fae5bc-8795-44d6-b0e7-b5d496fb2f77</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-244-index-merge-vs-composite-transparent-column-encryption-trusted-language-extensions-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss merging indexes vs. a composite index, implementing transparent column encryption, developing trusted language extensions, and reviewing the WAL archive module.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/244-index-merge-vs-composite-transparent-column-encryption-trusted-language-extensions-wal-archive-module/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss merging indexes vs. a composite index, implementing transparent column encryption, developing trusted language extensions, and reviewing the WAL archive module.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/244-index-merge-vs-composite-transparent-column-encryption-trusted-language-extensions-wal-archive-module/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Index Merge vs Composite, Transparent Column Encryption, Trusted Language Extensions | Scaling Postgres 244]]>
                </itunes:title>
                                    <itunes:episode>244</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss merging indexes vs. a composite index, implementing transparent column encryption, developing trusted language extensions, and reviewing the WAL archive module.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/244-index-merge-vs-composite-transparent-column-encryption-trusted-language-extensions-wal-archive-module/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551186/sp244.mp3" length="28783177"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss merging indexes vs. a composite index, implementing transparent column encryption, developing trusted language extensions, and reviewing the WAL archive module.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/244-index-merge-vs-composite-transparent-column-encryption-trusted-language-extensions-wal-archive-module/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551186/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:59</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[IN vs ANY, Ghost Conditions, Percentage Calculations, Variadic Unnest | Scaling Postgres 243]]>
                </title>
                <pubDate>Sun, 27 Nov 2022 21:51:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    c3d81b94-5d5c-4076-b4a5-6be61289a1d6</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-243-in-vs-any-ghost-conditions-percentage-calculations-variadic-unnest-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how PG15 helps reduce replication lag, how to get the parameters used in prepared statements, PostGIS Day and how to use multiple pgbouncers.</p>
<p> </p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/243-in-vs-any-ghost-conditions-percentage-calculations-variadic-unnest/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how PG15 helps reduce replication lag, how to get the parameters used in prepared statements, PostGIS Day and how to use multiple pgbouncers.
 
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/243-in-vs-any-ghost-conditions-percentage-calculations-variadic-unnest/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[IN vs ANY, Ghost Conditions, Percentage Calculations, Variadic Unnest | Scaling Postgres 243]]>
                </itunes:title>
                                    <itunes:episode>243</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how PG15 helps reduce replication lag, how to get the parameters used in prepared statements, PostGIS Day and how to use multiple pgbouncers.</p>
<p> </p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/243-in-vs-any-ghost-conditions-percentage-calculations-variadic-unnest/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551187/sp243.mp3" length="20006870"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how PG15 helps reduce replication lag, how to get the parameters used in prepared statements, PostGIS Day and how to use multiple pgbouncers.
 
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/243-in-vs-any-ghost-conditions-percentage-calculations-variadic-unnest/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551187/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:10:25</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Reduce Replication Lag, Explain Parameterized Query, PostGIS Day, Multiple PgBouncers | Scaling Postgres 242]]>
                </title>
                <pubDate>Mon, 21 Nov 2022 00:11:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    663cd277-ecbc-44a8-b99d-67553b3f3340</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-242-reduce-replication-lag-explain-parameterized-query-postgis-day-multiple-pgbouncers-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how PG15 helps reduce replication lag, how to get the parameters used in prepared statements, PostGIS Day and how to use multiple pgbouncers.</p>
<p> </p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/242-reduce-replication-lag-explain-parameterized-query-postgis-day-multiple-pgbouncers/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how PG15 helps reduce replication lag, how to get the parameters used in prepared statements, PostGIS Day and how to use multiple pgbouncers.
 
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/242-reduce-replication-lag-explain-parameterized-query-postgis-day-multiple-pgbouncers/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Reduce Replication Lag, Explain Parameterized Query, PostGIS Day, Multiple PgBouncers | Scaling Postgres 242]]>
                </itunes:title>
                                    <itunes:episode>242</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how PG15 helps reduce replication lag, how to get the parameters used in prepared statements, PostGIS Day and how to use multiple pgbouncers.</p>
<p> </p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/242-reduce-replication-lag-explain-parameterized-query-postgis-day-multiple-pgbouncers/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551189/sp242.mp3" length="22354964"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how PG15 helps reduce replication lag, how to get the parameters used in prepared statements, PostGIS Day and how to use multiple pgbouncers.
 
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/242-reduce-replication-lag-explain-parameterized-query-postgis-day-multiple-pgbouncers/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551189/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:11:38</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres 15.1, Postres 10 Retrospective, Reducing Replication Lag, Listen & Notify | Scaling Postgres 241]]>
                </title>
                <pubDate>Sun, 13 Nov 2022 22:34:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    8f380890-8170-4b26-afc0-8632afb13245</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-241-postgres-151-postres-10-retrospective-reducing-replication-lag-listen-notify-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the release of Postgres 15.1, a Postgres 10 retrospective, how to reduce replication lag and using listen &amp; notify.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/241-postgres-15.1-postgres-10-retrospective-reducing-replication-lag-listen-notify/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the release of Postgres 15.1, a Postgres 10 retrospective, how to reduce replication lag and using listen & notify.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/241-postgres-15.1-postgres-10-retrospective-reducing-replication-lag-listen-notify/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres 15.1, Postres 10 Retrospective, Reducing Replication Lag, Listen & Notify | Scaling Postgres 241]]>
                </itunes:title>
                                    <itunes:episode>241</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the release of Postgres 15.1, a Postgres 10 retrospective, how to reduce replication lag and using listen &amp; notify.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/241-postgres-15.1-postgres-10-retrospective-reducing-replication-lag-listen-notify/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551188/sp241.mp3" length="34362096"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the release of Postgres 15.1, a Postgres 10 retrospective, how to reduce replication lag and using listen & notify.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/241-postgres-15.1-postgres-10-retrospective-reducing-replication-lag-listen-notify/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551188/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:17:53</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Forced Sequential Scans, Table Renaming, Terminology, PGSQL Phriday | Scaling Postgres 240]]>
                </title>
                <pubDate>Sun, 06 Nov 2022 22:48:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    4985cd60-17e2-43dd-9c95-e3381693a3f5</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-240-forced-sequential-scans-table-renaming-terminology-pgsql-phriday-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how sequential scans can be forced, the best way to rename a table without downtime, different Postgres terminology and the PGSQL Phriday blogging event.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/240-forced-sequential-scans-table-renaming-terminology-pgsql-phriday/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how sequential scans can be forced, the best way to rename a table without downtime, different Postgres terminology and the PGSQL Phriday blogging event.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/240-forced-sequential-scans-table-renaming-terminology-pgsql-phriday/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Forced Sequential Scans, Table Renaming, Terminology, PGSQL Phriday | Scaling Postgres 240]]>
                </itunes:title>
                                    <itunes:episode>240</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how sequential scans can be forced, the best way to rename a table without downtime, different Postgres terminology and the PGSQL Phriday blogging event.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/240-forced-sequential-scans-table-renaming-terminology-pgsql-phriday/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551190/sp240.mp3" length="37045394"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how sequential scans can be forced, the best way to rename a table without downtime, different Postgres terminology and the PGSQL Phriday blogging event.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/240-forced-sequential-scans-table-renaming-terminology-pgsql-phriday/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551190/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:19:17</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Shared Buffers, Compression Algorithm, Merge Command, Postgres Contributions | Scaling Postgres 239]]>
                </title>
                <pubDate>Sun, 30 Oct 2022 21:59:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    05513420-4388-453d-9bb1-26b58e203972</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-239-shared-buffers-compression-algorithm-merge-command-postgres-contributions-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to set shared buffers, the different WAL compression algorithm options, how to use the merge command and how to contribute to Postgres.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/239-shared-buffers-compression-algorithms-merge-command-postgres-contributions/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to set shared buffers, the different WAL compression algorithm options, how to use the merge command and how to contribute to Postgres.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/239-shared-buffers-compression-algorithms-merge-command-postgres-contributions/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Shared Buffers, Compression Algorithm, Merge Command, Postgres Contributions | Scaling Postgres 239]]>
                </itunes:title>
                                    <itunes:episode>239</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to set shared buffers, the different WAL compression algorithm options, how to use the merge command and how to contribute to Postgres.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/239-shared-buffers-compression-algorithms-merge-command-postgres-contributions/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551191/sp239.mp3" length="29396741"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to set shared buffers, the different WAL compression algorithm options, how to use the merge command and how to contribute to Postgres.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/239-shared-buffers-compression-algorithms-merge-command-postgres-contributions/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551191/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:18</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Slow Updates, Lateral Joins, Serial To Identity, PG 15 Changes | Scaling Postgres 238]]>
                </title>
                <pubDate>Mon, 24 Oct 2022 01:24:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    5bfdd9df-6782-465b-a15c-29591ba90ff1</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-238-slow-updates-lateral-joins-serial-to-identity-pg-15-changes-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss why and what to do when updates are slow, use cases for lateral joins, moving from serial to identity for auto-incrementing ids and changes to Postgres 15.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/238-slow-updates-lateral-joins-serial-to-identity-pg15-changes/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss why and what to do when updates are slow, use cases for lateral joins, moving from serial to identity for auto-incrementing ids and changes to Postgres 15.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/238-slow-updates-lateral-joins-serial-to-identity-pg15-changes/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Slow Updates, Lateral Joins, Serial To Identity, PG 15 Changes | Scaling Postgres 238]]>
                </itunes:title>
                                    <itunes:episode>238</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss why and what to do when updates are slow, use cases for lateral joins, moving from serial to identity for auto-incrementing ids and changes to Postgres 15.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/238-slow-updates-lateral-joins-serial-to-identity-pg15-changes/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551192/sp238.mp3" length="25148604"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss why and what to do when updates are slow, use cases for lateral joins, moving from serial to identity for auto-incrementing ids and changes to Postgres 15.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/238-slow-updates-lateral-joins-serial-to-identity-pg15-changes/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551192/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:13:05</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres 15 Released, File Systems, Connection Pooling, Secure Connections | Scaling Postgres 237]]>
                </title>
                <pubDate>Sun, 16 Oct 2022 21:49:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    1d416f88-a8f9-4cf9-a84c-2fddf50d418c</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-237-postgres-15-released-file-systems-connection-pooling-secure-connections-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the release of Postgres 15, the performance of different file systems with Postgres, options for connection pooling and how to secure your connections.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/237-postgres-15-released-file-systems-connection-pooling-secure-connections/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the release of Postgres 15, the performance of different file systems with Postgres, options for connection pooling and how to secure your connections.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/237-postgres-15-released-file-systems-connection-pooling-secure-connections/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres 15 Released, File Systems, Connection Pooling, Secure Connections | Scaling Postgres 237]]>
                </itunes:title>
                                    <itunes:episode>237</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the release of Postgres 15, the performance of different file systems with Postgres, options for connection pooling and how to secure your connections.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/237-postgres-15-released-file-systems-connection-pooling-secure-connections/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551193/sp237.mp3" length="36267154"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the release of Postgres 15, the performance of different file systems with Postgres, options for connection pooling and how to secure your connections.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/237-postgres-15-released-file-systems-connection-pooling-secure-connections/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551193/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:18:53</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres 15 RC2, Shared Buffers, Secure Connections, PGSQL Phriday | Scaling Postgres 236]]>
                </title>
                <pubDate>Mon, 10 Oct 2022 00:42:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    51ddf23d-95f9-45f4-b889-b5ad47d8ebc3</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-236-postgres-15-rc2-shared-buffers-secure-connections-pgsql-phriday-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the Postgres 15 RC2, optimizing shared buffers, how to secure your database connections and blog posts from PGSQL Phriday.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/236-postgres-15-rc2-shared-buffers-secure-connections-pgsql-phriday/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the Postgres 15 RC2, optimizing shared buffers, how to secure your database connections and blog posts from PGSQL Phriday.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/236-postgres-15-rc2-shared-buffers-secure-connections-pgsql-phriday/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres 15 RC2, Shared Buffers, Secure Connections, PGSQL Phriday | Scaling Postgres 236]]>
                </itunes:title>
                                    <itunes:episode>236</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the Postgres 15 RC2, optimizing shared buffers, how to secure your database connections and blog posts from PGSQL Phriday.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/236-postgres-15-rc2-shared-buffers-secure-connections-pgsql-phriday/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551194/sp236.mp3" length="38220695"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the Postgres 15 RC2, optimizing shared buffers, how to secure your database connections and blog posts from PGSQL Phriday.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/236-postgres-15-rc2-shared-buffers-secure-connections-pgsql-phriday/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551194/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:19:54</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres 15 RC1, ICU Collations, Listen & Notify, Understanding TOAST | Scaling Postgres 235]]>
                </title>
                <pubDate>Mon, 03 Oct 2022 00:57:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    145a47d1-1d57-4b53-aa42-d8ea853070ef</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-235-postgres-15-rc1-icu-collations-listen-notify-understanding-toast-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the release of the Postgres 15 Release Candidate 1, new ICU collations features, how to use listen &amp; notify and understanding TOAST.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/235-postgres-15-rc1-icu-collations-listen-notify-understanding-toast/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the release of the Postgres 15 Release Candidate 1, new ICU collations features, how to use listen & notify and understanding TOAST.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/235-postgres-15-rc1-icu-collations-listen-notify-understanding-toast/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres 15 RC1, ICU Collations, Listen & Notify, Understanding TOAST | Scaling Postgres 235]]>
                </itunes:title>
                                    <itunes:episode>235</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the release of the Postgres 15 Release Candidate 1, new ICU collations features, how to use listen &amp; notify and understanding TOAST.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/235-postgres-15-rc1-icu-collations-listen-notify-understanding-toast/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551195/sp235.mp3" length="23556597"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the release of the Postgres 15 Release Candidate 1, new ICU collations features, how to use listen & notify and understanding TOAST.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/235-postgres-15-rc1-icu-collations-listen-notify-understanding-toast/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551195/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:16:21</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Rust for Extensions, Timescale vs. Postgres, Uninterrupted Sharding, Data Flow | Scaling Postgres 234]]>
                </title>
                <pubDate>Sun, 25 Sep 2022 23:48:31 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    d8b555b6-1887-4491-973a-da9f58c5b64b</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-234-rust-for-extensions-timescale-vs-postgres-uninterrupted-sharding-data-flow-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss using rust for Postgres extensions, performance comparisons of TimescaleDB vs. Postgres, uninterrupted writes when sharding in Citus and the Postgres data flow.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/234-rust-for-extensions-timescale-vs-postgres-uninterrupted-sharding-data-flow/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss using rust for Postgres extensions, performance comparisons of TimescaleDB vs. Postgres, uninterrupted writes when sharding in Citus and the Postgres data flow.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/234-rust-for-extensions-timescale-vs-postgres-uninterrupted-sharding-data-flow/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Rust for Extensions, Timescale vs. Postgres, Uninterrupted Sharding, Data Flow | Scaling Postgres 234]]>
                </itunes:title>
                                    <itunes:episode>234</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss using rust for Postgres extensions, performance comparisons of TimescaleDB vs. Postgres, uninterrupted writes when sharding in Citus and the Postgres data flow.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/234-rust-for-extensions-timescale-vs-postgres-uninterrupted-sharding-data-flow/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551196/sp234.mp3" length="23542178"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss using rust for Postgres extensions, performance comparisons of TimescaleDB vs. Postgres, uninterrupted writes when sharding in Citus and the Postgres data flow.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/234-rust-for-extensions-timescale-vs-postgres-uninterrupted-sharding-data-flow/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551196/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:16:20</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Useful Features, Community Blogging, PG 15 Anticipation, Generic Plans | Scaling Postgres 233]]>
                </title>
                <pubDate>Sun, 18 Sep 2022 21:14:02 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    f3fa3492-d074-4f53-b31c-023350e5c244</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-233-useful-features-community-blogging-pg-15-anticipation-generic-plans-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss little known useful features, a monthly community blogging initiative, PG 15 Anticipation, and getting generic plans.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/233-useful-features-community-blogging-pg15-anticipation-generic-plans/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss little known useful features, a monthly community blogging initiative, PG 15 Anticipation, and getting generic plans.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/233-useful-features-community-blogging-pg15-anticipation-generic-plans/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Useful Features, Community Blogging, PG 15 Anticipation, Generic Plans | Scaling Postgres 233]]>
                </itunes:title>
                                    <itunes:episode>233</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss little known useful features, a monthly community blogging initiative, PG 15 Anticipation, and getting generic plans.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/233-useful-features-community-blogging-pg15-anticipation-generic-plans/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551197/sp233.mp3" length="19754213"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss little known useful features, a monthly community blogging initiative, PG 15 Anticipation, and getting generic plans.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/233-useful-features-community-blogging-pg15-anticipation-generic-plans/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551197/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:13:43</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[PG15 Beta 4, Primary Key Options, Sequence Limits, Configuration | Scaling Postgres 232]]>
                </title>
                <pubDate>Mon, 12 Sep 2022 01:14:33 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    d706b758-2819-4d6c-a17d-f4b23bdffc29</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-232-pg15-beta-4-primary-key-options-sequence-limits-configuration-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the release of Postgres 15 Beta 4, different primary key options, sequence limits and how to examine your Postgres configuration.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/232-pg15-beta-4-primary-key-options-sequence-limits-configuration/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the release of Postgres 15 Beta 4, different primary key options, sequence limits and how to examine your Postgres configuration.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/232-pg15-beta-4-primary-key-options-sequence-limits-configuration/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[PG15 Beta 4, Primary Key Options, Sequence Limits, Configuration | Scaling Postgres 232]]>
                </itunes:title>
                                    <itunes:episode>232</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the release of Postgres 15 Beta 4, different primary key options, sequence limits and how to examine your Postgres configuration.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/232-pg15-beta-4-primary-key-options-sequence-limits-configuration/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551198/sp232.mp3" length="21047588"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the release of Postgres 15 Beta 4, different primary key options, sequence limits and how to examine your Postgres configuration.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/232-pg15-beta-4-primary-key-options-sequence-limits-configuration/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551198/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:36</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[PG15 Public Schema, Kubernetes Experiences, Dump Manifests, PgBouncer Fork | Scaling Postgres 231]]>
                </title>
                <pubDate>Sun, 04 Sep 2022 21:41:53 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    b2548baf-6ec0-4180-b199-e1ebc0e364d6</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-231-pg15-public-schema-kubernetes-experiences-dump-manifests-pgbouncer-fork-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the PG15 changes to public schema permissions, experiences with kubernetes for Postgres management, using dump manifests for restores and a fork of PgBouncer.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/231-pg15-public-schema-kubernetes-experiences-dump-manifests-pgbouncer-fork/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the PG15 changes to public schema permissions, experiences with kubernetes for Postgres management, using dump manifests for restores and a fork of PgBouncer.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/231-pg15-public-schema-kubernetes-experiences-dump-manifests-pgbouncer-fork/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[PG15 Public Schema, Kubernetes Experiences, Dump Manifests, PgBouncer Fork | Scaling Postgres 231]]>
                </itunes:title>
                                    <itunes:episode>231</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the PG15 changes to public schema permissions, experiences with kubernetes for Postgres management, using dump manifests for restores and a fork of PgBouncer.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/231-pg15-public-schema-kubernetes-experiences-dump-manifests-pgbouncer-fork/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551199/sp231.mp3" length="27449887"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the PG15 changes to public schema permissions, experiences with kubernetes for Postgres management, using dump manifests for restores and a fork of PgBouncer.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/231-pg15-public-schema-kubernetes-experiences-dump-manifests-pgbouncer-fork/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551199/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:19:03</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Stats Collector Gone, Handling Latency, PG In The Browser, Future High Availability | Scaling Postgres 230]]>
                </title>
                <pubDate>Sun, 28 Aug 2022 20:19:11 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    dd721450-3c55-4c79-98e4-dc8a9b68f5ae</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-230-stats-collector-gone-handling-latency-pg-in-the-browser-future-high-availability-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how the stats collector disappears in PG15, steps to mitigate high latency connections, how to run Postgres in the browser and the future of high availability.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/230-stats-collector-gone-handling-latency-postgres-in-browser-future-high-availability/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how the stats collector disappears in PG15, steps to mitigate high latency connections, how to run Postgres in the browser and the future of high availability.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/230-stats-collector-gone-handling-latency-postgres-in-browser-future-high-availability/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Stats Collector Gone, Handling Latency, PG In The Browser, Future High Availability | Scaling Postgres 230]]>
                </itunes:title>
                                    <itunes:episode>230</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how the stats collector disappears in PG15, steps to mitigate high latency connections, how to run Postgres in the browser and the future of high availability.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/230-stats-collector-gone-handling-latency-postgres-in-browser-future-high-availability/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551201/sp230.mp3" length="18073391"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how the stats collector disappears in PG15, steps to mitigate high latency connections, how to run Postgres in the browser and the future of high availability.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/230-stats-collector-gone-handling-latency-postgres-in-browser-future-high-availability/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551201/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:33</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres Playground, PG14 Internals, DB Corruption, Anti-Join | Scaling Postgres 229]]>
                </title>
                <pubDate>Mon, 22 Aug 2022 02:25:21 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    56a5944b-47d1-44eb-9849-871f8f511deb</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-229-postgres-playground-pg14-internals-db-corruption-anti-join-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss a new Postgres playground, a book about PG14 internals, how to corrupt your database and using anti-joins.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/229-postgres-playground-pg14-internals-db-corruption-anti-join/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a new Postgres playground, a book about PG14 internals, how to corrupt your database and using anti-joins.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/229-postgres-playground-pg14-internals-db-corruption-anti-join/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres Playground, PG14 Internals, DB Corruption, Anti-Join | Scaling Postgres 229]]>
                </itunes:title>
                                    <itunes:episode>229</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss a new Postgres playground, a book about PG14 internals, how to corrupt your database and using anti-joins.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/229-postgres-playground-pg14-internals-db-corruption-anti-join/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551200/sp229.mp3" length="17039569"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a new Postgres playground, a book about PG14 internals, how to corrupt your database and using anti-joins.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/229-postgres-playground-pg14-internals-db-corruption-anti-join/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551200/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:11:49</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[New Postgres Releases, Privilege Escalation CVE, Chaos Testing, High Availability | Scaling Postgres 228]]>
                </title>
                <pubDate>Sun, 14 Aug 2022 21:32:39 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    fc41ec5a-1645-4367-be5a-0c183c8b4b3b</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-228-new-postgres-releases-privilege-escalation-cve-chaos-testing-high-availability-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss new Postgres releases, a new privilege escalation CVE, chaos testing a high availability kubernetes cluster as well as addressing other H/A questions.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/228-new-postgres-releases-privilege-escalation-cve-chaos-testing-high-availability/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss new Postgres releases, a new privilege escalation CVE, chaos testing a high availability kubernetes cluster as well as addressing other H/A questions.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/228-new-postgres-releases-privilege-escalation-cve-chaos-testing-high-availability/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[New Postgres Releases, Privilege Escalation CVE, Chaos Testing, High Availability | Scaling Postgres 228]]>
                </itunes:title>
                                    <itunes:episode>228</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss new Postgres releases, a new privilege escalation CVE, chaos testing a high availability kubernetes cluster as well as addressing other H/A questions.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/228-new-postgres-releases-privilege-escalation-cve-chaos-testing-high-availability/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551202/sp228.mp3" length="18381844"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss new Postgres releases, a new privilege escalation CVE, chaos testing a high availability kubernetes cluster as well as addressing other H/A questions.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/228-new-postgres-releases-privilege-escalation-cve-chaos-testing-high-availability/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551202/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:45</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Researching Performance, Postgres Survey, pgAdmin Survey, Long Running Queries | Scaling Postgres 227]]>
                </title>
                <pubDate>Sun, 07 Aug 2022 20:17:19 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    757265c3-16ad-4214-8754-ffaa44f1918d</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-227-researching-performance-postgres-survey-pgadmin-survey-long-running-queries-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss PG14's new SQL function In this episode of Scaling Postgres, we discuss research into a performance puzzle, results from a Postgres and pgAdmin survey as well as the impacts of long running queries on Aurora and Postgres.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/227-researching-performance-postgres-survey-pgadmin-survey-long-running-queries/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss PG14's new SQL function In this episode of Scaling Postgres, we discuss research into a performance puzzle, results from a Postgres and pgAdmin survey as well as the impacts of long running queries on Aurora and Postgres.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/227-researching-performance-postgres-survey-pgadmin-survey-long-running-queries/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Researching Performance, Postgres Survey, pgAdmin Survey, Long Running Queries | Scaling Postgres 227]]>
                </itunes:title>
                                    <itunes:episode>227</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss PG14's new SQL function In this episode of Scaling Postgres, we discuss research into a performance puzzle, results from a Postgres and pgAdmin survey as well as the impacts of long running queries on Aurora and Postgres.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/227-researching-performance-postgres-survey-pgadmin-survey-long-running-queries/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551203/sp227.mp3" length="12792685"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss PG14's new SQL function In this episode of Scaling Postgres, we discuss research into a performance puzzle, results from a Postgres and pgAdmin survey as well as the impacts of long running queries on Aurora and Postgres.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/227-researching-performance-postgres-survey-pgadmin-survey-long-running-queries/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551203/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:08:53</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[SQL Functions, Explain Analyze Buffers, Debug Autovacuum, RLS Multi-Tenancy | Scaling Postgres 226]]>
                </title>
                <pubDate>Sun, 31 Jul 2022 21:45:50 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    acf26eb7-870c-4394-9e47-eb3dc709c667</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-226-sql-functions-explain-analyze-buffers-debug-autovacuum-rls-multi-tenancy-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss PG14's new SQL function syntax, including buffers when doing explain analyze, how to debug autovacuum and using row-level security to handle multi-tenancy.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/226-sql-functions-explain-analyze-buffers-debug-autovacuum-rls-multi-tenancy/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss PG14's new SQL function syntax, including buffers when doing explain analyze, how to debug autovacuum and using row-level security to handle multi-tenancy.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/226-sql-functions-explain-analyze-buffers-debug-autovacuum-rls-multi-tenancy/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[SQL Functions, Explain Analyze Buffers, Debug Autovacuum, RLS Multi-Tenancy | Scaling Postgres 226]]>
                </itunes:title>
                                    <itunes:episode>226</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss PG14's new SQL function syntax, including buffers when doing explain analyze, how to debug autovacuum and using row-level security to handle multi-tenancy.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/226-sql-functions-explain-analyze-buffers-debug-autovacuum-rls-multi-tenancy/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551204/sp226.mp3" length="23513338"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss PG14's new SQL function syntax, including buffers when doing explain analyze, how to debug autovacuum and using row-level security to handle multi-tenancy.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/226-sql-functions-explain-analyze-buffers-debug-autovacuum-rls-multi-tenancy/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551204/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:16:19</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[PSQL GEXEC, Delete Duplicates, Postgres Podcast, Puny to Powerful | Scaling Postgres 225]]>
                </title>
                <pubDate>Sun, 24 Jul 2022 23:36:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    eb4a58a2-d26d-49aa-863f-6844518cc30c</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-225-psql-gexec-delete-duplicates-postgres-podcast-puny-to-powerful-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss /gexec available in psql, how to delete duplicates using a window function, a new Postgres podcast and a performance talk about going from puny to powerful.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/225-psql-gexec-delete-duplicates-postgres-podcast-puny-powerful/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss /gexec available in psql, how to delete duplicates using a window function, a new Postgres podcast and a performance talk about going from puny to powerful.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/225-psql-gexec-delete-duplicates-postgres-podcast-puny-powerful/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[PSQL GEXEC, Delete Duplicates, Postgres Podcast, Puny to Powerful | Scaling Postgres 225]]>
                </itunes:title>
                                    <itunes:episode>225</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss /gexec available in psql, how to delete duplicates using a window function, a new Postgres podcast and a performance talk about going from puny to powerful.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/225-psql-gexec-delete-duplicates-postgres-podcast-puny-powerful/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551206/sp225.mp3" length="14907350"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss /gexec available in psql, how to delete duplicates using a window function, a new Postgres podcast and a performance talk about going from puny to powerful.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/225-psql-gexec-delete-duplicates-postgres-podcast-puny-powerful/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551206/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:10:21</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Column Performance, BRIN Win, Unique and Null, Parallel Distinct | Scaling Postgres 224]]>
                </title>
                <pubDate>Mon, 18 Jul 2022 00:14:56 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    d1e641db-4a04-402d-8b88-9587c54c1a54</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-224-column-performance-brin-win-unique-and-null-parallel-distinct-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how too many columns in a table can affect performance, at what point BRIN indexes win over btree, and Postgres 15 supporting unique nulls and parallel distinct queries.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/224-column-performance-brin-win-unique-null-parallel-distinct/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how too many columns in a table can affect performance, at what point BRIN indexes win over btree, and Postgres 15 supporting unique nulls and parallel distinct queries.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/224-column-performance-brin-win-unique-null-parallel-distinct/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Column Performance, BRIN Win, Unique and Null, Parallel Distinct | Scaling Postgres 224]]>
                </itunes:title>
                                    <itunes:episode>224</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how too many columns in a table can affect performance, at what point BRIN indexes win over btree, and Postgres 15 supporting unique nulls and parallel distinct queries.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/224-column-performance-brin-win-unique-null-parallel-distinct/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551205/sp224.mp3" length="20104672"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how too many columns in a table can affect performance, at what point BRIN indexes win over btree, and Postgres 15 supporting unique nulls and parallel distinct queries.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/224-column-performance-brin-win-unique-null-parallel-distinct/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551205/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:13:57</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Database Decomposition, Fast Text Search, Understanding pg_stat_activity, Window Functions | Scaling Postgres 223]]>
                </title>
                <pubDate>Sun, 10 Jul 2022 21:55:41 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    1c7d835e-4e9e-40aa-9fb4-0625630e01a3</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-223-database-decomposition-fast-text-search-understanding-pg-stat-activity-window-functions-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the process of decomposing your database, how to search text in Postgres quickly, how to understand the output of pg_stat_activity and how to use window functions to solve a use case.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/223-database-decomposition-fast-text-search-understanding-pg_stat_activity-window-functions/ </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the process of decomposing your database, how to search text in Postgres quickly, how to understand the output of pg_stat_activity and how to use window functions to solve a use case.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/223-database-decomposition-fast-text-search-understanding-pg_stat_activity-window-functions/ ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Database Decomposition, Fast Text Search, Understanding pg_stat_activity, Window Functions | Scaling Postgres 223]]>
                </itunes:title>
                                    <itunes:episode>223</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the process of decomposing your database, how to search text in Postgres quickly, how to understand the output of pg_stat_activity and how to use window functions to solve a use case.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/223-database-decomposition-fast-text-search-understanding-pg_stat_activity-window-functions/ </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551207/sp223.mp3" length="21577351"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the process of decomposing your database, how to search text in Postgres quickly, how to understand the output of pg_stat_activity and how to use window functions to solve a use case.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/223-database-decomposition-fast-text-search-understanding-pg_stat_activity-window-functions/ ]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551207/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:59</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres 15 Beta 2, Concerning Locks, Vacuum Tuning, Transaction Anomalies | Scaling Postgres 222]]>
                </title>
                <pubDate>Mon, 04 Jul 2022 13:41:08 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    c7b0283b-14e6-4f38-ad25-7c58a7d257a4</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-222-postgres-15-beta-2-concerning-locks-vacuum-tuning-transaction-anomalies-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss psql shortcuts, how to debug deadlocks, how to find &amp; stop queries and how to understand and use SCRAM authentication.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/222-postgres-15-beta-2-concerning-locks-vacuum-tuning-transaction-anomalies/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss psql shortcuts, how to debug deadlocks, how to find & stop queries and how to understand and use SCRAM authentication.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/222-postgres-15-beta-2-concerning-locks-vacuum-tuning-transaction-anomalies/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres 15 Beta 2, Concerning Locks, Vacuum Tuning, Transaction Anomalies | Scaling Postgres 222]]>
                </itunes:title>
                                    <itunes:episode>222</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss psql shortcuts, how to debug deadlocks, how to find &amp; stop queries and how to understand and use SCRAM authentication.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/222-postgres-15-beta-2-concerning-locks-vacuum-tuning-transaction-anomalies/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551208/sp222.mp3" length="25607941"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss psql shortcuts, how to debug deadlocks, how to find & stop queries and how to understand and use SCRAM authentication.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/222-postgres-15-beta-2-concerning-locks-vacuum-tuning-transaction-anomalies/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551208/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:17:47</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[psql Shortcuts, Debugging Deadlocks, Find & Stop Queries, Using SCRAM | Scaling Postgres 221]]>
                </title>
                <pubDate>Mon, 27 Jun 2022 13:31:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    080a6c29-d40e-4b20-9d6a-025ad02deaaf</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-221-psql-shortcuts-debugging-deadlocks-find-stop-queries-using-scram-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss psql shortcuts, how to debug deadlocks, how to find &amp; stop queries and how to understand and use SCRAM authentication.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/221-psql-shortcuts-debugging-deadlocks-find-and-stop-queries-using-scram/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss psql shortcuts, how to debug deadlocks, how to find & stop queries and how to understand and use SCRAM authentication.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/221-psql-shortcuts-debugging-deadlocks-find-and-stop-queries-using-scram/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[psql Shortcuts, Debugging Deadlocks, Find & Stop Queries, Using SCRAM | Scaling Postgres 221]]>
                </itunes:title>
                                    <itunes:episode>221</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss psql shortcuts, how to debug deadlocks, how to find &amp; stop queries and how to understand and use SCRAM authentication.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/221-psql-shortcuts-debugging-deadlocks-find-and-stop-queries-using-scram/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551209/sp221.mp3" length="25338357"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss psql shortcuts, how to debug deadlocks, how to find & stop queries and how to understand and use SCRAM authentication.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/221-psql-shortcuts-debugging-deadlocks-find-and-stop-queries-using-scram/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551209/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:17:35</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[PG 14.4 Release, Subscription Skip, Using Schemas, Open Source Citus | Scaling Postgres 220]]>
                </title>
                <pubDate>Sun, 19 Jun 2022 21:02:49 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    1f84205c-1538-4156-b0a4-725cf8ceb69b</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-220-pg-144-release-subscription-skip-using-schemas-open-source-citus-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss a PG 14.4 release, how to skip transactions with logical replication, how to use schemas and Citus going fully open source.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/220-pg-14.4-release-subscription-skip-using-schemas-open-source-citus/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a PG 14.4 release, how to skip transactions with logical replication, how to use schemas and Citus going fully open source.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/220-pg-14.4-release-subscription-skip-using-schemas-open-source-citus/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[PG 14.4 Release, Subscription Skip, Using Schemas, Open Source Citus | Scaling Postgres 220]]>
                </itunes:title>
                                    <itunes:episode>220</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss a PG 14.4 release, how to skip transactions with logical replication, how to use schemas and Citus going fully open source.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/220-pg-14.4-release-subscription-skip-using-schemas-open-source-citus/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551210/sp220.mp3" length="27288764"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a PG 14.4 release, how to skip transactions with logical replication, how to use schemas and Citus going fully open source.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/220-pg-14.4-release-subscription-skip-using-schemas-open-source-citus/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551210/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:18:57</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Out-Of-Cycle Release, Should You Upgrade, Postgres Survey, Automatic Indexing | Scaling Postgres 219]]>
                </title>
                <pubDate>Mon, 13 Jun 2022 00:22:06 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    0ff12071-6a23-46f9-86ce-408e331bed37</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-219-out-of-cycle-release-should-you-upgrade-postgres-survey-automatic-indexing-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss a Postgres 14 out-of-cycle release next week, whether you should upgrade, the state of Postgres survey and a tool for automatic indexing.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/219-out-of-cycle-release-should-you-upgrade-state-of-postgres-survey-automatic-indexing/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a Postgres 14 out-of-cycle release next week, whether you should upgrade, the state of Postgres survey and a tool for automatic indexing.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/219-out-of-cycle-release-should-you-upgrade-state-of-postgres-survey-automatic-indexing/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Out-Of-Cycle Release, Should You Upgrade, Postgres Survey, Automatic Indexing | Scaling Postgres 219]]>
                </itunes:title>
                                    <itunes:episode>219</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss a Postgres 14 out-of-cycle release next week, whether you should upgrade, the state of Postgres survey and a tool for automatic indexing.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/219-out-of-cycle-release-should-you-upgrade-state-of-postgres-survey-automatic-indexing/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551211/sp219.mp3" length="18116649"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a Postgres 14 out-of-cycle release next week, whether you should upgrade, the state of Postgres survey and a tool for automatic indexing.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/219-out-of-cycle-release-should-you-upgrade-state-of-postgres-survey-automatic-indexing/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551211/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:34</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[PG14 Index Bug, View Permissions, Logical Replication Conflicts, AlloyDB Under the Hood | Scaling Postgres 218]]>
                </title>
                <pubDate>Sun, 05 Jun 2022 21:25:57 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    f7c29782-e4b9-4c2d-867b-5141175b41c9</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-218-pg14-index-bug-view-permissions-logical-replication-conflicts-alloydb-under-the-hood-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss a severe bug with index creation in Postgres 14, view permissions options, dealing with logical replication conflicts and looking under the hood of AlloyDB.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/214-pg14-index-bug-view-permissions-logical-replication-conflicts-alloydb-under-the-hood/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a severe bug with index creation in Postgres 14, view permissions options, dealing with logical replication conflicts and looking under the hood of AlloyDB.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/214-pg14-index-bug-view-permissions-logical-replication-conflicts-alloydb-under-the-hood/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[PG14 Index Bug, View Permissions, Logical Replication Conflicts, AlloyDB Under the Hood | Scaling Postgres 218]]>
                </itunes:title>
                                    <itunes:episode>218</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss a severe bug with index creation in Postgres 14, view permissions options, dealing with logical replication conflicts and looking under the hood of AlloyDB.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/214-pg14-index-bug-view-permissions-logical-replication-conflicts-alloydb-under-the-hood/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551212/sp218.mp3" length="24554057"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a severe bug with index creation in Postgres 14, view permissions options, dealing with logical replication conflicts and looking under the hood of AlloyDB.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/214-pg14-index-bug-view-permissions-logical-replication-conflicts-alloydb-under-the-hood/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551212/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:17:03</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Schema Change Mistakes, Canceling Statements, pg_rman, Pedantry Removal | Scaling Postgres 217]]>
                </title>
                <pubDate>Sun, 29 May 2022 23:37:19 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    4bf49d19-3308-4f76-ba3e-a640da410be7</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-217-schema-change-mistakes-canceling-statements-pg-rman-pedantry-removal-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss mistakes you can make when doing schema changes, how best to cancel statements, looking into pg_rman, and looking at a pedantry removal.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/217-schema-change-mistakes-canceling-statements-pg_rman-pedantry-removal/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss mistakes you can make when doing schema changes, how best to cancel statements, looking into pg_rman, and looking at a pedantry removal.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/217-schema-change-mistakes-canceling-statements-pg_rman-pedantry-removal/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Schema Change Mistakes, Canceling Statements, pg_rman, Pedantry Removal | Scaling Postgres 217]]>
                </itunes:title>
                                    <itunes:episode>217</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss mistakes you can make when doing schema changes, how best to cancel statements, looking into pg_rman, and looking at a pedantry removal.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/217-schema-change-mistakes-canceling-statements-pg_rman-pedantry-removal/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551213/sp217.mp3" length="23843735"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss mistakes you can make when doing schema changes, how best to cancel statements, looking into pg_rman, and looking at a pedantry removal.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/217-schema-change-mistakes-canceling-statements-pg_rman-pedantry-removal/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551213/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:16:33</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[PG 15 Beta 1 Release, Query Breakdown, Sort Performance, Prepared vs. Partitioned | Scaling Postgres 216]]>
                </title>
                <pubDate>Sun, 22 May 2022 21:20:11 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    46d5547c-bdb1-474b-a649-799cd2a0548a</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-216-pg-15-beta-1-release-query-breakdown-sort-performance-prepared-vs-partitioned-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the Beta 1 release of Postgres 15, optimizing a query by breaking it down, improvements to sort performance and prepared statements for partitioned tables.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/216-pg15-beta1-release-query-breakdown-sort-performance-prepared-vs-partitioned/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the Beta 1 release of Postgres 15, optimizing a query by breaking it down, improvements to sort performance and prepared statements for partitioned tables.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/216-pg15-beta1-release-query-breakdown-sort-performance-prepared-vs-partitioned/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[PG 15 Beta 1 Release, Query Breakdown, Sort Performance, Prepared vs. Partitioned | Scaling Postgres 216]]>
                </itunes:title>
                                    <itunes:episode>216</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the Beta 1 release of Postgres 15, optimizing a query by breaking it down, improvements to sort performance and prepared statements for partitioned tables.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/216-pg15-beta1-release-query-breakdown-sort-performance-prepared-vs-partitioned/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551214/sp216.mp3" length="13292355"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the Beta 1 release of Postgres 15, optimizing a query by breaking it down, improvements to sort performance and prepared statements for partitioned tables.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/216-pg15-beta1-release-query-breakdown-sort-performance-prepared-vs-partitioned/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551214/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:13:50</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[New Releases, AlloyDB, Time Zones, Connecting to Postgres | Scaling Postgres 215]]>
                </title>
                <pubDate>Sun, 15 May 2022 22:47:52 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    fe51afc5-94d3-4c18-941a-6b933336af01</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-215-new-releases-alloydb-time-zones-connecting-to-postgres-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss parallel server-side backup compression, IO in Postgres, parquet files and the new pg_stat_monitor extension.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/215-new-releases-alloydb-time-zones-connecting-to-postgres/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss parallel server-side backup compression, IO in Postgres, parquet files and the new pg_stat_monitor extension.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/215-new-releases-alloydb-time-zones-connecting-to-postgres/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[New Releases, AlloyDB, Time Zones, Connecting to Postgres | Scaling Postgres 215]]>
                </itunes:title>
                                    <itunes:episode>215</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss parallel server-side backup compression, IO in Postgres, parquet files and the new pg_stat_monitor extension.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/215-new-releases-alloydb-time-zones-connecting-to-postgres/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551215/sp215.mp3" length="16542406"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss parallel server-side backup compression, IO in Postgres, parquet files and the new pg_stat_monitor extension.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/215-new-releases-alloydb-time-zones-connecting-to-postgres/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551215/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:17:13</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Backup Compression, Postgres IO, Parquet Files, pg_stat_monitor | Scaling Postgres 214]]>
                </title>
                <pubDate>Sun, 08 May 2022 22:04:19 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    5d46d956-8caa-4b5c-ace3-a676ba614734</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-214-backup-compression-postgres-io-parquet-files-pg-stat-monitor-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss parallel server-side backup compression, IO in Postgres, parquet files and the new pg_stat_monitor extension.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/214-backup-compression-postgres-io-parquet-files-pg_stat_monitor/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss parallel server-side backup compression, IO in Postgres, parquet files and the new pg_stat_monitor extension.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/214-backup-compression-postgres-io-parquet-files-pg_stat_monitor/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Backup Compression, Postgres IO, Parquet Files, pg_stat_monitor | Scaling Postgres 214]]>
                </itunes:title>
                                    <itunes:episode>214</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss parallel server-side backup compression, IO in Postgres, parquet files and the new pg_stat_monitor extension.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/214-backup-compression-postgres-io-parquet-files-pg_stat_monitor/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551216/sp214.mp3" length="18713286"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss parallel server-side backup compression, IO in Postgres, parquet files and the new pg_stat_monitor extension.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/214-backup-compression-postgres-io-parquet-files-pg_stat_monitor/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551216/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:19:29</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Planner Optimization, Fish to Elephants, Large Databases, Spatial Data | Scaling Postgres 213]]>
                </title>
                <pubDate>Sun, 01 May 2022 21:57:03 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    d49e21cb-c61b-4c5d-acf2-46861f9e1887</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-213-planner-optimization-fish-to-elephants-large-databases-spatial-data-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss ways you can optimize the planner, becoming part of the Postgres Community, considerations for large databases and mapping three different types of spatial data.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/213-planner-optimization-fish-to-elephants-large-databases-spatial-data/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss ways you can optimize the planner, becoming part of the Postgres Community, considerations for large databases and mapping three different types of spatial data.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/213-planner-optimization-fish-to-elephants-large-databases-spatial-data/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Planner Optimization, Fish to Elephants, Large Databases, Spatial Data | Scaling Postgres 213]]>
                </itunes:title>
                                    <itunes:episode>213</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss ways you can optimize the planner, becoming part of the Postgres Community, considerations for large databases and mapping three different types of spatial data.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/213-planner-optimization-fish-to-elephants-large-databases-spatial-data/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551217/sp213.mp3" length="15270974"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss ways you can optimize the planner, becoming part of the Postgres Community, considerations for large databases and mapping three different types of spatial data.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/213-planner-optimization-fish-to-elephants-large-databases-spatial-data/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551217/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:54</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Slow Queries, 4TB Upgrade, Postgres on ZFS, Storage Stampede | Scaling Postgres 212]]>
                </title>
                <pubDate>Sun, 24 Apr 2022 21:40:25 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    c9a7ece9-9b02-42d8-9c3c-206076d8581d</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-212-slow-queries-4tb-upgrade-postgres-on-zfs-storage-stampede-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss dealing with slow queries, upgrading a 4TB database, running Postgres on ZFS and handling a storage stampede.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/212-slow-queries-4tb-upgrade-postgres-on-zfs-storage-stampede/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss dealing with slow queries, upgrading a 4TB database, running Postgres on ZFS and handling a storage stampede.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/212-slow-queries-4tb-upgrade-postgres-on-zfs-storage-stampede/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Slow Queries, 4TB Upgrade, Postgres on ZFS, Storage Stampede | Scaling Postgres 212]]>
                </itunes:title>
                                    <itunes:episode>212</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss dealing with slow queries, upgrading a 4TB database, running Postgres on ZFS and handling a storage stampede.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/212-slow-queries-4tb-upgrade-postgres-on-zfs-storage-stampede/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551218/sp212.mp3" length="20532244"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss dealing with slow queries, upgrading a 4TB database, running Postgres on ZFS and handling a storage stampede.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/212-slow-queries-4tb-upgrade-postgres-on-zfs-storage-stampede/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551218/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:21:23</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Multiranges, Missing Metrics, Newbie PostGIS, Conference Videos | Scaling Postgres 211]]>
                </title>
                <pubDate>Sun, 17 Apr 2022 21:08:55 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    f635f816-be09-4d60-8c24-74c9600a540b</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-211-multiranges-missing-metrics-newbie-postgis-conference-videos-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss working with multiranges, missing Postgres metrics, PostGIS for newbies and videos from CitusCon.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/211-mutiranges-missing-metrics-newbie-postgis-conference-videos/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss working with multiranges, missing Postgres metrics, PostGIS for newbies and videos from CitusCon.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/211-mutiranges-missing-metrics-newbie-postgis-conference-videos/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Multiranges, Missing Metrics, Newbie PostGIS, Conference Videos | Scaling Postgres 211]]>
                </itunes:title>
                                    <itunes:episode>211</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss working with multiranges, missing Postgres metrics, PostGIS for newbies and videos from CitusCon.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/211-mutiranges-missing-metrics-newbie-postgis-conference-videos/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551219/sp211.mp3" length="10832666"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss working with multiranges, missing Postgres metrics, PostGIS for newbies and videos from CitusCon.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/211-mutiranges-missing-metrics-newbie-postgis-conference-videos/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551219/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:11:17</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Date Time Bins, Search Every Field, JSON_TABLE, Picking Primary | Scaling Postgres 210]]>
                </title>
                <pubDate>Sun, 10 Apr 2022 23:56:49 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    bee6f3b5-7aa2-4add-ad38-95d106a48051</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-210-date-time-bins-search-every-field-json-table-picking-primary-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to bin date times, search every field of a table, use JSON_TABLE and methods for a client to pick the primary database.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/210-date-time-bins-search-every-field-json_table-picking-primary/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to bin date times, search every field of a table, use JSON_TABLE and methods for a client to pick the primary database.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/210-date-time-bins-search-every-field-json_table-picking-primary/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Date Time Bins, Search Every Field, JSON_TABLE, Picking Primary | Scaling Postgres 210]]>
                </itunes:title>
                                    <itunes:episode>210</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to bin date times, search every field of a table, use JSON_TABLE and methods for a client to pick the primary database.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/210-date-time-bins-search-every-field-json_table-picking-primary/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551220/sp210.mp3" length="9473462"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to bin date times, search every field of a table, use JSON_TABLE and methods for a client to pick the primary database.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/210-date-time-bins-search-every-field-json_table-picking-primary/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551220/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:09:52</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Tidy Vacuum, Dropping Roles, Merge Command, PgBouncer Tutorial | Scaling Postgres 209]]>
                </title>
                <pubDate>Sun, 03 Apr 2022 21:40:36 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    9a1b2104-4dbc-4857-b257-241d98679813</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-209-tidy-vacuum-dropping-roles-merge-command-pgbouncer-tutorial-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to optimize vacuum, how to drop roles, the new merge command in PG15 and a pgbouncer tutorial.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/209-tidy-vacuum-dropping-roles-merge-command-pgbouncer-tutorial/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to optimize vacuum, how to drop roles, the new merge command in PG15 and a pgbouncer tutorial.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/209-tidy-vacuum-dropping-roles-merge-command-pgbouncer-tutorial/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Tidy Vacuum, Dropping Roles, Merge Command, PgBouncer Tutorial | Scaling Postgres 209]]>
                </itunes:title>
                                    <itunes:episode>209</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to optimize vacuum, how to drop roles, the new merge command in PG15 and a pgbouncer tutorial.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/209-tidy-vacuum-dropping-roles-merge-command-pgbouncer-tutorial/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551221/sp209.mp3" length="13667683"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to optimize vacuum, how to drop roles, the new merge command in PG15 and a pgbouncer tutorial.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/209-tidy-vacuum-dropping-roles-merge-command-pgbouncer-tutorial/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551221/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:14</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[pgbouncer Released, Query Parameter Types, Lateral Joins, Security Invoker Views | Scaling Postgres 208]]>
                </title>
                <pubDate>Sun, 27 Mar 2022 21:53:37 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    df7c2bc8-4d6e-4320-b149-e0df1472ceb5</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-208-pgbouncer-released-query-parameter-types-lateral-joins-security-invoker-views-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss a new version of pgbouncer, query parameter types, a performance improvement from a lateral join and security invoker views.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/208-pgbouncer-released-query-parameter-types-lateral-joins-security-invoker-views/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a new version of pgbouncer, query parameter types, a performance improvement from a lateral join and security invoker views.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/208-pgbouncer-released-query-parameter-types-lateral-joins-security-invoker-views/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[pgbouncer Released, Query Parameter Types, Lateral Joins, Security Invoker Views | Scaling Postgres 208]]>
                </itunes:title>
                                    <itunes:episode>208</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss a new version of pgbouncer, query parameter types, a performance improvement from a lateral join and security invoker views.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/208-pgbouncer-released-query-parameter-types-lateral-joins-security-invoker-views/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551222/sp208.mp3" length="11759699"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a new version of pgbouncer, query parameter types, a performance improvement from a lateral join and security invoker views.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/208-pgbouncer-released-query-parameter-types-lateral-joins-security-invoker-views/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551222/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:14</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Autovacuum Configuration, Duplicate Key Violations, Pipelining, Tuning max_wal_size | Scaling Postgres 207]]>
                </title>
                <pubDate>Sun, 20 Mar 2022 21:35:48 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    b3449813-6de7-4af1-9d7f-2567b8af30a4</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-207-autovacuum-configuration-duplicate-key-violations-pipelining-tuning-max-wal-size-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how best to configure autovacuum, the dangers of duplicate key violations, how to set up pipelining, and how to tune max_wal_size.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/207-autovacuum-configuration-dupliate-key-violations-pipelining-tuning-max_wal_size/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how best to configure autovacuum, the dangers of duplicate key violations, how to set up pipelining, and how to tune max_wal_size.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/207-autovacuum-configuration-dupliate-key-violations-pipelining-tuning-max_wal_size/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Autovacuum Configuration, Duplicate Key Violations, Pipelining, Tuning max_wal_size | Scaling Postgres 207]]>
                </itunes:title>
                                    <itunes:episode>207</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how best to configure autovacuum, the dangers of duplicate key violations, how to set up pipelining, and how to tune max_wal_size.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/207-autovacuum-configuration-dupliate-key-violations-pipelining-tuning-max_wal_size/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551223/sp207.mp3" length="17193169"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how best to configure autovacuum, the dangers of duplicate key violations, how to set up pipelining, and how to tune max_wal_size.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/207-autovacuum-configuration-dupliate-key-violations-pipelining-tuning-max_wal_size/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551223/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:17:54</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[100x Optimizations, Auditing, Document Schema Designs, Checksums | Scaling Postgres 206]]>
                </title>
                <pubDate>Sun, 13 Mar 2022 22:54:50 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    593d357d-f6ba-463c-ac49-d5f1801ca909</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-206-100x-optimizations-auditing-document-schema-designs-checksums-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss 100x optimizations, how to audit table activity, designing schemas and how to set up table checksums.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/206-100x-optimizations-auditing-document-schema-designs-checksums/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss 100x optimizations, how to audit table activity, designing schemas and how to set up table checksums.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/206-100x-optimizations-auditing-document-schema-designs-checksums/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[100x Optimizations, Auditing, Document Schema Designs, Checksums | Scaling Postgres 206]]>
                </itunes:title>
                                    <itunes:episode>206</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss 100x optimizations, how to audit table activity, designing schemas and how to set up table checksums.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/206-100x-optimizations-auditing-document-schema-designs-checksums/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551224/sp206.mp3" length="17138834"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss 100x optimizations, how to audit table activity, designing schemas and how to set up table checksums.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/206-100x-optimizations-auditing-document-schema-designs-checksums/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551224/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:17:51</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Indexing With tsearch, Tuples Not Yet Removable, Wicked Problems, Pattern Matching | Scaling Postgres 205]]>
                </title>
                <pubDate>Mon, 07 Mar 2022 01:29:45 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    0c5c401f-8398-4dc6-ab95-26eacc71612e</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-205-indexing-with-tsearch-tuples-not-yet-removable-wicked-problems-pattern-matching-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the best ways to index with tsearch, what to check if tuples are not yet removable, wicked problems with Postgres and different pattern matching techniques.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/205-indexing-with-tsearch-tuples-not-yet-removable-wicked-problems-pattern-matching/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the best ways to index with tsearch, what to check if tuples are not yet removable, wicked problems with Postgres and different pattern matching techniques.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/205-indexing-with-tsearch-tuples-not-yet-removable-wicked-problems-pattern-matching/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Indexing With tsearch, Tuples Not Yet Removable, Wicked Problems, Pattern Matching | Scaling Postgres 205]]>
                </itunes:title>
                                    <itunes:episode>205</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the best ways to index with tsearch, what to check if tuples are not yet removable, wicked problems with Postgres and different pattern matching techniques.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/205-indexing-with-tsearch-tuples-not-yet-removable-wicked-problems-pattern-matching/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551225/sp205.mp3" length="9542008"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the best ways to index with tsearch, what to check if tuples are not yet removable, wicked problems with Postgres and different pattern matching techniques.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/205-indexing-with-tsearch-tuples-not-yet-removable-wicked-problems-pattern-matching/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551225/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:09:56</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Optimizing Trigram Search, Replication Review, Logical Improvements, Timescale Investment | Scaling Postgres 204]]>
                </title>
                <pubDate>Sun, 27 Feb 2022 23:06:52 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    c219eae9-3f3f-48fe-a252-921a9e6a5344</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-204-optimizing-trigram-search-replication-review-logical-improvements-timescale-investment-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss optimizing trigram searches, a review of Postgres replication, improvements to logical replication and a significant Timescale investment.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/204-optimizing-trigram-search-replication-review-logical-improvements-timescale-investment/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss optimizing trigram searches, a review of Postgres replication, improvements to logical replication and a significant Timescale investment.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/204-optimizing-trigram-search-replication-review-logical-improvements-timescale-investment/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Optimizing Trigram Search, Replication Review, Logical Improvements, Timescale Investment | Scaling Postgres 204]]>
                </itunes:title>
                                    <itunes:episode>204</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss optimizing trigram searches, a review of Postgres replication, improvements to logical replication and a significant Timescale investment.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/204-optimizing-trigram-search-replication-review-logical-improvements-timescale-investment/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551226/sp204.mp3" length="17956780"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss optimizing trigram searches, a review of Postgres replication, improvements to logical replication and a significant Timescale investment.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/204-optimizing-trigram-search-replication-review-logical-improvements-timescale-investment/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551226/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:18:42</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Saving Space, Working with TOAST, Protecting Data, High CPU Utilization | Scaling Postgres 203]]>
                </title>
                <pubDate>Sun, 20 Feb 2022 22:26:31 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    3b8b420c-0bff-48a2-862e-562c10036626</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-203-saving-space-working-with-toast-protecting-data-high-cpu-utilization-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the new releases of Postgres, a hairy upgrade incident, why slowing down can make you go faster and using loadable modules for WAL archiving.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/203-saving-space-working-with-toast-protecting-data-high-cpu-utilization/</p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the new releases of Postgres, a hairy upgrade incident, why slowing down can make you go faster and using loadable modules for WAL archiving.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/203-saving-space-working-with-toast-protecting-data-high-cpu-utilization/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Saving Space, Working with TOAST, Protecting Data, High CPU Utilization | Scaling Postgres 203]]>
                </itunes:title>
                                    <itunes:episode>203</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the new releases of Postgres, a hairy upgrade incident, why slowing down can make you go faster and using loadable modules for WAL archiving.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/203-saving-space-working-with-toast-protecting-data-high-cpu-utilization/</p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551227/sp203.mp3" length="11707454"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the new releases of Postgres, a hairy upgrade incident, why slowing down can make you go faster and using loadable modules for WAL archiving.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/203-saving-space-working-with-toast-protecting-data-high-cpu-utilization/
 ]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551227/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:11</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[New Postgres Releases, A Hairy Incident, Slow Down To Go Faster, Loadable Module Archiving | Scaling Postgres 202]]>
                </title>
                <pubDate>Mon, 14 Feb 2022 14:44:29 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    fe033104-8071-462b-926f-86b022b64f86</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-202-new-postgres-releases-a-hairy-incident-slow-down-to-go-faster-loadable-module-archiving-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the new releases of Postgres, a hairy upgrade incident, why slowing down can make you go faster and using loadable modules for WAL archiving.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/202-new-postgres-releases-hairy-incident-slow-down-to-go-faster-loadable-module-archiving/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the new releases of Postgres, a hairy upgrade incident, why slowing down can make you go faster and using loadable modules for WAL archiving.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/202-new-postgres-releases-hairy-incident-slow-down-to-go-faster-loadable-module-archiving/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[New Postgres Releases, A Hairy Incident, Slow Down To Go Faster, Loadable Module Archiving | Scaling Postgres 202]]>
                </itunes:title>
                                    <itunes:episode>202</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the new releases of Postgres, a hairy upgrade incident, why slowing down can make you go faster and using loadable modules for WAL archiving.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/202-new-postgres-releases-hairy-incident-slow-down-to-go-faster-loadable-module-archiving/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551228/sp202.mp3" length="12306390"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the new releases of Postgres, a hairy upgrade incident, why slowing down can make you go faster and using loadable modules for WAL archiving.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/202-new-postgres-releases-hairy-incident-slow-down-to-go-faster-loadable-module-archiving/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551228/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:49</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[JSONB Performance, Bidirectional Replication, Most Recent Record, PG14 JSON | Scaling Postgres 201]]>
                </title>
                <pubDate>Mon, 07 Feb 2022 03:53:51 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    e8147021-2a12-4890-876a-9cfbf0947d95</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-201-jsonb-performance-bidirectional-replication-most-recent-record-pg14-json-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss JSONB performance, bidirectional replication, getting the most recent record and using JSON in Postgres 14.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/201-jsonb-performance-bidirectional-replication-most-recent-record-pg14-json/</p>
<p> </p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss JSONB performance, bidirectional replication, getting the most recent record and using JSON in Postgres 14.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/201-jsonb-performance-bidirectional-replication-most-recent-record-pg14-json/
 ]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[JSONB Performance, Bidirectional Replication, Most Recent Record, PG14 JSON | Scaling Postgres 201]]>
                </itunes:title>
                                    <itunes:episode>201</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss JSONB performance, bidirectional replication, getting the most recent record and using JSON in Postgres 14.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/201-jsonb-performance-bidirectional-replication-most-recent-record-pg14-json/</p>
<p> </p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551229/sp201.mp3" length="14657828"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss JSONB performance, bidirectional replication, getting the most recent record and using JSON in Postgres 14.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/201-jsonb-performance-bidirectional-replication-most-recent-record-pg14-json/
 ]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551229/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:16</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[5 Minutes of Postgres, Unnest, SCRAM, Multi-master Review | Scaling Postgres 200]]>
                </title>
                <pubDate>Sun, 30 Jan 2022 23:35:41 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    ba1d7666-3c92-4687-83ef-9f13d66be943</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-200-5-minutes-of-postgres-unnest-scram-multi-master-review-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the new series 5 minutes of Postgres, using unnest, switching to SCRAM authentication and reviewing multi-master solutions.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/200-5-minute-postgres-unnest-scram-multi-master-review/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the new series 5 minutes of Postgres, using unnest, switching to SCRAM authentication and reviewing multi-master solutions.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/200-5-minute-postgres-unnest-scram-multi-master-review/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[5 Minutes of Postgres, Unnest, SCRAM, Multi-master Review | Scaling Postgres 200]]>
                </itunes:title>
                                    <itunes:episode>200</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the new series 5 minutes of Postgres, using unnest, switching to SCRAM authentication and reviewing multi-master solutions.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/200-5-minute-postgres-unnest-scram-multi-master-review/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551230/sp200.mp3" length="11708708"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the new series 5 minutes of Postgres, using unnest, switching to SCRAM authentication and reviewing multi-master solutions.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/200-5-minute-postgres-unnest-scram-multi-master-review/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551230/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:11</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Shaped Sample Data, Version Changes, Missed Bottlenecks, Indexes for Newbies | Scaling Postgres 199]]>
                </title>
                <pubDate>Mon, 24 Jan 2022 00:36:06 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    d0e4fe4c-a589-4c2f-a09c-e7b312b9c4a8</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-199-shaped-sample-data-version-changes-missed-bottlenecks-indexes-for-newbies-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to generate shaped sample data, track changes between Postgres versions, identify missed bottlenecks and use different index types.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/199-shaped-sample-data-version-changes-missed-bottlenecks-indexes-for-newbies/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to generate shaped sample data, track changes between Postgres versions, identify missed bottlenecks and use different index types.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/199-shaped-sample-data-version-changes-missed-bottlenecks-indexes-for-newbies/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Shaped Sample Data, Version Changes, Missed Bottlenecks, Indexes for Newbies | Scaling Postgres 199]]>
                </itunes:title>
                                    <itunes:episode>199</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to generate shaped sample data, track changes between Postgres versions, identify missed bottlenecks and use different index types.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/199-shaped-sample-data-version-changes-missed-bottlenecks-indexes-for-newbies/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551231/sp199.mp3" length="11807764"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to generate shaped sample data, track changes between Postgres versions, identify missed bottlenecks and use different index types.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/199-shaped-sample-data-version-changes-missed-bottlenecks-indexes-for-newbies/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551231/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:17</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Monitoring Progress, More SQL, Replication Slot Failover, Postgres Contributors | Scaling Postgres 198]]>
                </title>
                <pubDate>Sun, 16 Jan 2022 22:50:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    8e4b43f9-9996-424b-b7e8-e693043bbef1</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-198-monitoring-progress-more-sql-replication-slot-failover-postgres-contributors-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to monitor DML &amp; DDL progress, using more SQL, one way to handle replication slot fail-over, and recent Postgres contributors.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/198-monitoring-progress-more-sql-replication-slot-failover-postgres-contributors/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to monitor DML & DDL progress, using more SQL, one way to handle replication slot fail-over, and recent Postgres contributors.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/198-monitoring-progress-more-sql-replication-slot-failover-postgres-contributors/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Monitoring Progress, More SQL, Replication Slot Failover, Postgres Contributors | Scaling Postgres 198]]>
                </itunes:title>
                                    <itunes:episode>198</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to monitor DML &amp; DDL progress, using more SQL, one way to handle replication slot fail-over, and recent Postgres contributors.</p>
<p>To get the show notes as well as get notified of new episodes, visit:</p>
<p>https://www.scalingpostgres.com/episodes/198-monitoring-progress-more-sql-replication-slot-failover-postgres-contributors/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551232/sp198.mp3" length="14179265"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to monitor DML & DDL progress, using more SQL, one way to handle replication slot fail-over, and recent Postgres contributors.
To get the show notes as well as get notified of new episodes, visit:
https://www.scalingpostgres.com/episodes/198-monitoring-progress-more-sql-replication-slot-failover-postgres-contributors/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551232/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:46</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Explain Analyze Buffers, Healthier Postgres, 2021 Review, High Availability Aspirations | Scaling Postgres 197]]>
                </title>
                <pubDate>Sun, 09 Jan 2022 23:15:41 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    09b71459-9c0c-46fd-9b38-ef2846a56a70</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-197-explain-analyze-buffers-healthier-postgres-2021-review-high-availability-aspirations-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss including buffers with explain analyze, having a healthier Postgres DB, the events of 2021 and aspiring for greater high availability solutions.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/197-explain-analyze-buffers-healthier-postgres-2021-review-high-availability-aspirations/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss including buffers with explain analyze, having a healthier Postgres DB, the events of 2021 and aspiring for greater high availability solutions.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/197-explain-analyze-buffers-healthier-postgres-2021-review-high-availability-aspirations/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Explain Analyze Buffers, Healthier Postgres, 2021 Review, High Availability Aspirations | Scaling Postgres 197]]>
                </itunes:title>
                                    <itunes:episode>197</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss including buffers with explain analyze, having a healthier Postgres DB, the events of 2021 and aspiring for greater high availability solutions.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/197-explain-analyze-buffers-healthier-postgres-2021-review-high-availability-aspirations/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551233/sp197.mp3" length="14009573"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss including buffers with explain analyze, having a healthier Postgres DB, the events of 2021 and aspiring for greater high availability solutions.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/197-explain-analyze-buffers-healthier-postgres-2021-review-high-availability-aspirations/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551233/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:35</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Easy Recursive CTE, Zheap Undo, High Availability, Loading Data | Scaling Postgres 196]]>
                </title>
                <pubDate>Sun, 19 Dec 2021 21:20:49 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    10f7a68b-897b-48b0-9608-0980c814ca7e</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-196-easy-recursive-cte-zheap-undo-high-availability-loading-data-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss easily writing a recursive CTE, the zheap undo capability, high availability considerations and fast ways to load data.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/196-easy-recursive-cte-zheap-undo-high-availability-loading-data/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss easily writing a recursive CTE, the zheap undo capability, high availability considerations and fast ways to load data.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/196-easy-recursive-cte-zheap-undo-high-availability-loading-data/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Easy Recursive CTE, Zheap Undo, High Availability, Loading Data | Scaling Postgres 196]]>
                </itunes:title>
                                    <itunes:episode>196</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss easily writing a recursive CTE, the zheap undo capability, high availability considerations and fast ways to load data.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/196-easy-recursive-cte-zheap-undo-high-availability-loading-data/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551234/sp196.mp3" length="16527360"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss easily writing a recursive CTE, the zheap undo capability, high availability considerations and fast ways to load data.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/196-easy-recursive-cte-zheap-undo-high-availability-loading-data/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551234/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:17:12</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Aurora vs. Postgres, Surprising Transactions, Write-Only & Read-Only, Indexing Advice | Scaling Postgres 195]]>
                </title>
                <pubDate>Mon, 13 Dec 2021 01:05:55 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    817f0ab1-69c6-49a7-9299-383f1db17cba</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-195-aurora-vs-postgres-surprising-transactions-write-only-read-only-indexing-advice-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss Aurora vs. Postgres, surprising transaction behavior, write-only &amp; read-only database connections and indexing best practices.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/195-auroora-vs-postgres-surprising-transactions-write-only-read-only-indexing-advice/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss Aurora vs. Postgres, surprising transaction behavior, write-only & read-only database connections and indexing best practices.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/195-auroora-vs-postgres-surprising-transactions-write-only-read-only-indexing-advice/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Aurora vs. Postgres, Surprising Transactions, Write-Only & Read-Only, Indexing Advice | Scaling Postgres 195]]>
                </itunes:title>
                                    <itunes:episode>195</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss Aurora vs. Postgres, surprising transaction behavior, write-only &amp; read-only database connections and indexing best practices.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/195-auroora-vs-postgres-surprising-transactions-write-only-read-only-indexing-advice/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551235/sp195.mp3" length="17790850"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss Aurora vs. Postgres, surprising transaction behavior, write-only & read-only database connections and indexing best practices.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/195-auroora-vs-postgres-surprising-transactions-write-only-read-only-indexing-advice/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551235/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:18:31</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Go Faster, GIN Indexes, Collation Stability, PG14 & Beyond | Scaling Postgres 194]]>
                </title>
                <pubDate>Fri, 10 Dec 2021 21:52:12 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    5e729d0c-b7ae-47ef-a464-2d3f368ca1ba</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-194-go-faster-gin-indexes-collation-stability-pg14-beyond-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss going slower to go faster, GIN indexes, collation stability and features of PG14 and beyond.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/194-go-faster-gin-indexes-collation-stability-pg14-beyond/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss going slower to go faster, GIN indexes, collation stability and features of PG14 and beyond.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/194-go-faster-gin-indexes-collation-stability-pg14-beyond/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Go Faster, GIN Indexes, Collation Stability, PG14 & Beyond | Scaling Postgres 194]]>
                </itunes:title>
                                    <itunes:episode>194</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss going slower to go faster, GIN indexes, collation stability and features of PG14 and beyond.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/194-go-faster-gin-indexes-collation-stability-pg14-beyond/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551236/sp194.mp3" length="15370866"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss going slower to go faster, GIN indexes, collation stability and features of PG14 and beyond.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/194-go-faster-gin-indexes-collation-stability-pg14-beyond/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551236/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:16:00</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Entity-Attribute-Value Design, JSON Subscripting, mysql-fdw Push-down, New Regex | Scaling Postgres 193]]>
                </title>
                <pubDate>Sun, 28 Nov 2021 22:38:03 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    b16d7c75-1ae2-454f-a481-a1c7444f5bb2</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-193-entity-attribute-value-design-json-subscripting-mysql-fdw-push-down-new-regex-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss using entity-attribute-value designs, new JSON subscripting capabilities, the mysql-fdw support for aggregate pushdowns and new regex functions in PG 15.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/193-entity-attribute-value-design-json-subscripting-mysql-fdw-push-down-new-regex/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss using entity-attribute-value designs, new JSON subscripting capabilities, the mysql-fdw support for aggregate pushdowns and new regex functions in PG 15.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/193-entity-attribute-value-design-json-subscripting-mysql-fdw-push-down-new-regex/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Entity-Attribute-Value Design, JSON Subscripting, mysql-fdw Push-down, New Regex | Scaling Postgres 193]]>
                </itunes:title>
                                    <itunes:episode>193</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss using entity-attribute-value designs, new JSON subscripting capabilities, the mysql-fdw support for aggregate pushdowns and new regex functions in PG 15.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/193-entity-attribute-value-design-json-subscripting-mysql-fdw-push-down-new-regex/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551237/sp193.mp3" length="9056339"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss using entity-attribute-value designs, new JSON subscripting capabilities, the mysql-fdw support for aggregate pushdowns and new regex functions in PG 15.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/193-entity-attribute-value-design-json-subscripting-mysql-fdw-push-down-new-regex/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551237/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:09:26</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Foreign Key Indexes, Graph Queries, Linux Huge Pages, Text Column Size | Scaling Postgres 192]]>
                </title>
                <pubDate>Tue, 23 Nov 2021 00:02:24 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    6b3c56e4-1ff1-46cb-a8ac-1b877faad2c7</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-192-foreign-key-indexes-graph-queries-linux-huge-pages-text-column-size-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss if foreign keys should have indexes, how to run graph queries, how to configure Linux huge pages and the benefits as well as text size similarities.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/192-foreign-key-indexes-graph-queries-linux-huge-pages-text-column-size/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss if foreign keys should have indexes, how to run graph queries, how to configure Linux huge pages and the benefits as well as text size similarities.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/192-foreign-key-indexes-graph-queries-linux-huge-pages-text-column-size/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Foreign Key Indexes, Graph Queries, Linux Huge Pages, Text Column Size | Scaling Postgres 192]]>
                </itunes:title>
                                    <itunes:episode>192</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss if foreign keys should have indexes, how to run graph queries, how to configure Linux huge pages and the benefits as well as text size similarities.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/192-foreign-key-indexes-graph-queries-linux-huge-pages-text-column-size/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551238/sp192.mp3" length="12147565"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss if foreign keys should have indexes, how to run graph queries, how to configure Linux huge pages and the benefits as well as text size similarities.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/192-foreign-key-indexes-graph-queries-linux-huge-pages-text-column-size/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551238/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:39</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Man-In-The-Middle, pg_auto_failover, Lesser Known Features, LZ4 Compression | Scaling Postgres 191]]>
                </title>
                <pubDate>Mon, 15 Nov 2021 01:13:42 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    67a67e2d-50d2-4c96-98fb-7de6f37c4ad8</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-191-man-in-the-middle-pg-auto-failover-lesser-known-features-lz4-compression-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss new releases of Postgres due to a man-in-the-middle vulnerability, the high availability solution pg_auto_failover, lesser known Postgres features and LZ4 compression.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><br /></p>
<p>https://www.scalingpostgres.com/episodes/191-man-in-the-middle-pg_auto_failover-lesser-known-features-lz4-compression/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss new releases of Postgres due to a man-in-the-middle vulnerability, the high availability solution pg_auto_failover, lesser known Postgres features and LZ4 compression.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/191-man-in-the-middle-pg_auto_failover-lesser-known-features-lz4-compression/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Man-In-The-Middle, pg_auto_failover, Lesser Known Features, LZ4 Compression | Scaling Postgres 191]]>
                </itunes:title>
                                    <itunes:episode>191</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss new releases of Postgres due to a man-in-the-middle vulnerability, the high availability solution pg_auto_failover, lesser known Postgres features and LZ4 compression.</p>
<p>To get the show notes as well as get notified of new episodes, visit: <br /><br /></p>
<p>https://www.scalingpostgres.com/episodes/191-man-in-the-middle-pg_auto_failover-lesser-known-features-lz4-compression/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551239/sp191.mp3" length="14306324"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss new releases of Postgres due to a man-in-the-middle vulnerability, the high availability solution pg_auto_failover, lesser known Postgres features and LZ4 compression.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/191-man-in-the-middle-pg_auto_failover-lesser-known-features-lz4-compression/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551239/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:54</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Hello Babelfish, Planner Deconstruction, Exist & Not Exist, Fun With SQL | Scaling Postgres 190]]>
                </title>
                <pubDate>Mon, 08 Nov 2021 02:16:54 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    4d118f14-83db-4b38-843d-132e7201bd3b</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-190-hello-babelfish-planner-deconstruction-exist-not-exist-fun-with-sql-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the open sourcing of Babelfish, deconstructing the Postgres planner, when to avoid exist &amp; not exist and having fun with SQL.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/190-hello-babelfish-planner-deconstruction-exist-not-exist-fun-with-sql/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the open sourcing of Babelfish, deconstructing the Postgres planner, when to avoid exist & not exist and having fun with SQL.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/190-hello-babelfish-planner-deconstruction-exist-not-exist-fun-with-sql/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Hello Babelfish, Planner Deconstruction, Exist & Not Exist, Fun With SQL | Scaling Postgres 190]]>
                </itunes:title>
                                    <itunes:episode>190</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the open sourcing of Babelfish, deconstructing the Postgres planner, when to avoid exist &amp; not exist and having fun with SQL.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/190-hello-babelfish-planner-deconstruction-exist-not-exist-fun-with-sql/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551240/sp190.mp3" length="12034716"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the open sourcing of Babelfish, deconstructing the Postgres planner, when to avoid exist & not exist and having fun with SQL.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/190-hello-babelfish-planner-deconstruction-exist-not-exist-fun-with-sql/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551240/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:32</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Index Downsides, TCP Keep Alive, Development with Postgres, Learning PL/pgSQL | Scaling Postgres 189]]>
                </title>
                <pubDate>Mon, 01 Nov 2021 00:05:53 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    0f229bab-4462-4410-9384-b9e27431379b</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-189-index-downsides-tcp-keep-alive-development-with-postgres-learning-plpgsql-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the downsides of indexes, TCP keep alive options, developing with Postgres as your DB and learning PL/pgSQL.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/189-index-downsides-tcp-keep-alive-development-with-postgres-learning-plpgsql/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the downsides of indexes, TCP keep alive options, developing with Postgres as your DB and learning PL/pgSQL.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/189-index-downsides-tcp-keep-alive-development-with-postgres-learning-plpgsql/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Index Downsides, TCP Keep Alive, Development with Postgres, Learning PL/pgSQL | Scaling Postgres 189]]>
                </itunes:title>
                                    <itunes:episode>189</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the downsides of indexes, TCP keep alive options, developing with Postgres as your DB and learning PL/pgSQL.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/189-index-downsides-tcp-keep-alive-development-with-postgres-learning-plpgsql/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551241/sp189.mp3" length="14825848"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the downsides of indexes, TCP keep alive options, developing with Postgres as your DB and learning PL/pgSQL.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/189-index-downsides-tcp-keep-alive-development-with-postgres-learning-plpgsql/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551241/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:26</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Automatic Indexing, Function Pipelines, With Hold Cursors, Query Scans | Scaling Postgres 188]]>
                </title>
                <pubDate>Mon, 25 Oct 2021 03:13:57 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    a9249bc1-4ef5-48de-82c7-b9fe7b98d27c</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-188-automatic-indexing-function-pipelines-with-hold-cursors-query-scans-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss automatic indexing, function pipelines, with hold cursors and the different query scans.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/188-automatic-indexing-function-pipelines-with-hold-cursors-query-scans/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss automatic indexing, function pipelines, with hold cursors and the different query scans.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/188-automatic-indexing-function-pipelines-with-hold-cursors-query-scans/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Automatic Indexing, Function Pipelines, With Hold Cursors, Query Scans | Scaling Postgres 188]]>
                </itunes:title>
                                    <itunes:episode>188</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss automatic indexing, function pipelines, with hold cursors and the different query scans.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/188-automatic-indexing-function-pipelines-with-hold-cursors-query-scans/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551243/sp188.mp3" length="14830445"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss automatic indexing, function pipelines, with hold cursors and the different query scans.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/188-automatic-indexing-function-pipelines-with-hold-cursors-query-scans/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551243/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:26</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Sharding, Federation, Linux HugePages, Performance Tuning | Scaling Postgres 187]]>
                </title>
                <pubDate>Sun, 17 Oct 2021 22:13:47 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    d8b6ec72-40bd-4e07-a862-d7036a83f4c1</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-187-sharding-federation-linux-hugepages-performance-tuning-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss one method to shard a database, federating your database, the benefits of configuring linux HugePages and performance tuning.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/187-sharding-federation-linux-hugepages-performance-tuning/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss one method to shard a database, federating your database, the benefits of configuring linux HugePages and performance tuning.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/187-sharding-federation-linux-hugepages-performance-tuning/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Sharding, Federation, Linux HugePages, Performance Tuning | Scaling Postgres 187]]>
                </itunes:title>
                                    <itunes:episode>187</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss one method to shard a database, federating your database, the benefits of configuring linux HugePages and performance tuning.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/187-sharding-federation-linux-hugepages-performance-tuning/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551242/sp187.mp3" length="14486883"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss one method to shard a database, federating your database, the benefits of configuring linux HugePages and performance tuning.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/187-sharding-federation-linux-hugepages-performance-tuning/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551242/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:05</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Select For Update, PGx Framework, Cool Additions, Full-Text Search | Scaling Postgres 186]]>
                </title>
                <pubDate>Sun, 10 Oct 2021 21:18:14 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    15872582-d8bc-4fdb-a870-94d9810814ac</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-186-select-for-update-pgx-framework-cool-additions-full-text-search-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss select for update, the pgx framework to generate extensions, cool additions to Postgres 14 and full-text search.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/186-select-for-update-pgx-framework-cool-additions-full-text-search/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss select for update, the pgx framework to generate extensions, cool additions to Postgres 14 and full-text search.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/186-select-for-update-pgx-framework-cool-additions-full-text-search/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Select For Update, PGx Framework, Cool Additions, Full-Text Search | Scaling Postgres 186]]>
                </itunes:title>
                                    <itunes:episode>186</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss select for update, the pgx framework to generate extensions, cool additions to Postgres 14 and full-text search.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/186-select-for-update-pgx-framework-cool-additions-full-text-search/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551244/sp186.mp3" length="8330344"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss select for update, the pgx framework to generate extensions, cool additions to Postgres 14 and full-text search.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/186-select-for-update-pgx-framework-cool-additions-full-text-search/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551244/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:08:40</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres 14 Released, Using JSON, Not Using Indexes, Sequence Gaps | Scaling Postgres 185]]>
                </title>
                <pubDate>Mon, 04 Oct 2021 02:26:57 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    05ca6c71-b7b5-41ff-bc00-dcc63c1e241c</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-185-postgres-14-released-using-json-not-using-indexes-sequence-gaps-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the release of Postgres 14, how best to use JSON, why are your indexes not being used and sequence gaps.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/185-postgres-14-released-using-json-not-using-indexes-sequence-gaps/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the release of Postgres 14, how best to use JSON, why are your indexes not being used and sequence gaps.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/185-postgres-14-released-using-json-not-using-indexes-sequence-gaps/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres 14 Released, Using JSON, Not Using Indexes, Sequence Gaps | Scaling Postgres 185]]>
                </itunes:title>
                                    <itunes:episode>185</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the release of Postgres 14, how best to use JSON, why are your indexes not being used and sequence gaps.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/185-postgres-14-released-using-json-not-using-indexes-sequence-gaps/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551245/sp185.mp3" length="20465789"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the release of Postgres 14, how best to use JSON, why are your indexes not being used and sequence gaps.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/185-postgres-14-released-using-json-not-using-indexes-sequence-gaps/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551245/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:21:19</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres 14 RC1, Little Things, Index Advisor, Million Inserts | Scaling Postgres 184]]>
                </title>
                <pubDate>Sun, 26 Sep 2021 21:55:04 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    057c25de-7396-4373-a73a-16c167966863</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-184-postgres-14-rc1-little-things-index-advisor-million-inserts-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss Postgres 14 RC1, little improvements in PG14, an index advisor and how to handle 1 million insert statements.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/184-postgres-14-rc1-little-things-index-advisor-million-inserts/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss Postgres 14 RC1, little improvements in PG14, an index advisor and how to handle 1 million insert statements.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/184-postgres-14-rc1-little-things-index-advisor-million-inserts/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres 14 RC1, Little Things, Index Advisor, Million Inserts | Scaling Postgres 184]]>
                </itunes:title>
                                    <itunes:episode>184</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss Postgres 14 RC1, little improvements in PG14, an index advisor and how to handle 1 million insert statements.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/184-postgres-14-rc1-little-things-index-advisor-million-inserts/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551246/sp184.mp3" length="12127085"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss Postgres 14 RC1, little improvements in PG14, an index advisor and how to handle 1 million insert statements.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/184-postgres-14-rc1-little-things-index-advisor-million-inserts/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551246/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:37</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Broken Indexes, Trademark Issues, Percentile vs. Average, Logical Improvements | Scaling Postgres 183]]>
                </title>
                <pubDate>Mon, 20 Sep 2021 00:54:31 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    0bcd05f7-f0b6-473d-94fa-e2b07527b833</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-183-broken-indexes-trademark-issues-percentile-vs-average-logical-improvements-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss one cause of broken indexes, Postgres trademark issues, percentiles vs. averages and logical replication improvements.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/183-broken-indexes-trademark-issues-percentile-vs-average-logical-improvements/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss one cause of broken indexes, Postgres trademark issues, percentiles vs. averages and logical replication improvements.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/183-broken-indexes-trademark-issues-percentile-vs-average-logical-improvements/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Broken Indexes, Trademark Issues, Percentile vs. Average, Logical Improvements | Scaling Postgres 183]]>
                </itunes:title>
                                    <itunes:episode>183</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss one cause of broken indexes, Postgres trademark issues, percentiles vs. averages and logical replication improvements.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/183-broken-indexes-trademark-issues-percentile-vs-average-logical-improvements/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551247/sp183.mp3" length="14245302"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss one cause of broken indexes, Postgres trademark issues, percentiles vs. averages and logical replication improvements.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/183-broken-indexes-trademark-issues-percentile-vs-average-logical-improvements/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551247/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:50</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Boundless Text, Revoked Permissions, Index Bloat, Hardware Performance | Scaling Postgres 182]]>
                </title>
                <pubDate>Sun, 12 Sep 2021 21:52:58 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    54cadfe7-e7d0-40ec-bd3d-c2b33ce0ab2d</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-182-boundless-text-revoked-permissions-index-bloat-hardware-performance-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss having boundless text fields, revoking public schema permissions, less index bloat in PG14 and comparing hardware performance.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/182-boundless-text-revoked-permissions-index-bloat-hardware-performance/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss having boundless text fields, revoking public schema permissions, less index bloat in PG14 and comparing hardware performance.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/182-boundless-text-revoked-permissions-index-bloat-hardware-performance/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Boundless Text, Revoked Permissions, Index Bloat, Hardware Performance | Scaling Postgres 182]]>
                </itunes:title>
                                    <itunes:episode>182</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss having boundless text fields, revoking public schema permissions, less index bloat in PG14 and comparing hardware performance.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/182-boundless-text-revoked-permissions-index-bloat-hardware-performance/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551248/sp182.mp3" length="13292773"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss having boundless text fields, revoking public schema permissions, less index bloat in PG14 and comparing hardware performance.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/182-boundless-text-revoked-permissions-index-bloat-hardware-performance/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551248/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:13:50</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Connection Scaling, Cached Sequences, Message Queuing, Harmful Subtransactions | Scaling Postgres 181]]>
                </title>
                <pubDate>Mon, 06 Sep 2021 01:45:16 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    ff6c3a5b-5c0d-41a7-9b9b-3fb171f7d0b3</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-181-connection-scaling-cached-sequences-message-queuing-harmful-subtransactions-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss connection scaling, how to cache your sequences, a message queuing implementation and the harms of subtransactions.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/181-connection-scaling-cached-sequences-message-queuing-harmful-subtransactions/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss connection scaling, how to cache your sequences, a message queuing implementation and the harms of subtransactions.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/181-connection-scaling-cached-sequences-message-queuing-harmful-subtransactions/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Connection Scaling, Cached Sequences, Message Queuing, Harmful Subtransactions | Scaling Postgres 181]]>
                </itunes:title>
                                    <itunes:episode>181</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss connection scaling, how to cache your sequences, a message queuing implementation and the harms of subtransactions.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/181-connection-scaling-cached-sequences-message-queuing-harmful-subtransactions/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551249/sp181.mp3" length="21088130"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss connection scaling, how to cache your sequences, a message queuing implementation and the harms of subtransactions.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/181-connection-scaling-cached-sequences-message-queuing-harmful-subtransactions/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551249/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:21:58</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Aggregate Filters, Insert-Only & Vacuum, Out-of-sync Sequences, Functional Indexes | Scaling Postgres 180]]>
                </title>
                <pubDate>Sun, 29 Aug 2021 21:33:32 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    405584ff-f3ef-4df2-a289-2984db620619</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-180-aggregate-filters-insert-only-vacuum-out-of-sync-sequences-functional-indexes-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to use aggregate filters, the importance of vacuum with insert-only tables, how to fix out-of-sync sequences and faster functional index options.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/180-aggregate-filters-insert-only-vacuum-out-of-sync-sequences-functional-indexes/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to use aggregate filters, the importance of vacuum with insert-only tables, how to fix out-of-sync sequences and faster functional index options.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/180-aggregate-filters-insert-only-vacuum-out-of-sync-sequences-functional-indexes/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Aggregate Filters, Insert-Only & Vacuum, Out-of-sync Sequences, Functional Indexes | Scaling Postgres 180]]>
                </itunes:title>
                                    <itunes:episode>180</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to use aggregate filters, the importance of vacuum with insert-only tables, how to fix out-of-sync sequences and faster functional index options.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/180-aggregate-filters-insert-only-vacuum-out-of-sync-sequences-functional-indexes/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551250/sp180.mp3" length="15825188"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to use aggregate filters, the importance of vacuum with insert-only tables, how to fix out-of-sync sequences and faster functional index options.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/180-aggregate-filters-insert-only-vacuum-out-of-sync-sequences-functional-indexes/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551250/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:16:29</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Foreign Data Wrapper, Timescale Compression, Fuzzy Search, Query Execution | Scaling Postgres 179]]>
                </title>
                <pubDate>Mon, 23 Aug 2021 00:41:05 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    f8e8fce8-e8cf-429a-a8d3-d0a722b5733d</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-179-foreign-data-wrapper-timescale-compression-fuzzy-search-query-execution-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to use foreign data wrappers, compression available in timescaledb, working with fuzzy search and describing Postgres query execution.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/179-foreign-data-wrapper-timescale-compression-fuzzy-search-query-execution/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to use foreign data wrappers, compression available in timescaledb, working with fuzzy search and describing Postgres query execution.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/179-foreign-data-wrapper-timescale-compression-fuzzy-search-query-execution/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Foreign Data Wrapper, Timescale Compression, Fuzzy Search, Query Execution | Scaling Postgres 179]]>
                </itunes:title>
                                    <itunes:episode>179</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to use foreign data wrappers, compression available in timescaledb, working with fuzzy search and describing Postgres query execution.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/179-foreign-data-wrapper-timescale-compression-fuzzy-search-query-execution/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551251/sp179.mp3" length="15051964"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to use foreign data wrappers, compression available in timescaledb, working with fuzzy search and describing Postgres query execution.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/179-foreign-data-wrapper-timescale-compression-fuzzy-search-query-execution/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551251/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:40</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres Releases, Performance Discussion, Index Types, Index Power Use | Scaling Postgres 178]]>
                </title>
                <pubDate>Mon, 16 Aug 2021 00:07:36 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    8d7d54aa-60c9-4929-84f6-3d0716bd05f5</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-178-postgres-releases-performance-discussion-index-types-index-power-use-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss new releases for Postgres &amp; pgbouncer, have a performance discussion, describe the different index types and how to use them.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/178-postgres-releases-performance-discussion-index-types-index-power-use/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss new releases for Postgres & pgbouncer, have a performance discussion, describe the different index types and how to use them.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/178-postgres-releases-performance-discussion-index-types-index-power-use/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres Releases, Performance Discussion, Index Types, Index Power Use | Scaling Postgres 178]]>
                </itunes:title>
                                    <itunes:episode>178</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss new releases for Postgres &amp; pgbouncer, have a performance discussion, describe the different index types and how to use them.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/178-postgres-releases-performance-discussion-index-types-index-power-use/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551252/sp178.mp3" length="14577998"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss new releases for Postgres & pgbouncer, have a performance discussion, describe the different index types and how to use them.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/178-postgres-releases-performance-discussion-index-types-index-power-use/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551252/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:11</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Planner Workarounds, Grouping Sets, Lateral Join, Not-So-Easy | Scaling Postgres 177]]>
                </title>
                <pubDate>Mon, 09 Aug 2021 01:34:32 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    6b8d278a-8d33-467c-863b-219984ec5afb</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-177-planner-workarounds-grouping-sets-lateral-join-not-so-easy-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss ways to work around the planner, working with grouping sets, using a lateral join and not-so-easy Postgres issues.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/177-planner-workarounds-grouping-sets-lateral-join-not-so-easy/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss ways to work around the planner, working with grouping sets, using a lateral join and not-so-easy Postgres issues.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/177-planner-workarounds-grouping-sets-lateral-join-not-so-easy/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Planner Workarounds, Grouping Sets, Lateral Join, Not-So-Easy | Scaling Postgres 177]]>
                </itunes:title>
                                    <itunes:episode>177</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss ways to work around the planner, working with grouping sets, using a lateral join and not-so-easy Postgres issues.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/177-planner-workarounds-grouping-sets-lateral-join-not-so-easy/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551253/sp177.mp3" length="15823516"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss ways to work around the planner, working with grouping sets, using a lateral join and not-so-easy Postgres issues.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/177-planner-workarounds-grouping-sets-lateral-join-not-so-easy/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551253/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:16:28</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[JSONB vs. Window Functions, Security Checklist, Full-Text Search, NFL Time-Series | Scaling Postgres 176]]>
                </title>
                <pubDate>Sun, 01 Aug 2021 21:12:53 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    f6a1a779-8830-45b6-8a1b-c5462f0364f9</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-176-jsonb-vs-window-functions-security-checklist-full-text-search-nfl-time-series-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss JSONB vs. window functions, a Postgres security checklist, implementing full-text search and using NFL timeseries data.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/176-jsonb-vs-window-functions-security-checklist-full-text-search-nfl-timeseries/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss JSONB vs. window functions, a Postgres security checklist, implementing full-text search and using NFL timeseries data.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/176-jsonb-vs-window-functions-security-checklist-full-text-search-nfl-timeseries/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[JSONB vs. Window Functions, Security Checklist, Full-Text Search, NFL Time-Series | Scaling Postgres 176]]>
                </itunes:title>
                                    <itunes:episode>176</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss JSONB vs. window functions, a Postgres security checklist, implementing full-text search and using NFL timeseries data.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/176-jsonb-vs-window-functions-security-checklist-full-text-search-nfl-timeseries/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551254/sp176.mp3" length="18102230"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss JSONB vs. window functions, a Postgres security checklist, implementing full-text search and using NFL timeseries data.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/176-jsonb-vs-window-functions-security-checklist-full-text-search-nfl-timeseries/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551254/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:18:51</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Zheap Status, Sequence Gaps, Efficient Pagination, Set Up Patroni | Scaling Postgres 175]]>
                </title>
                <pubDate>Mon, 26 Jul 2021 00:44:48 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    9d1c1843-7ce9-4737-92ea-88af211ee851</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-175-zheap-status-sequence-gaps-efficient-pagination-set-up-patroni-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the current status of zheap, the gaps in sequences, how to efficiently paginate and how to set up patroni with etcd and haproxy.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/175-zheap-status-sequence-gaps-efficient-pagination-set-up-patroni/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the current status of zheap, the gaps in sequences, how to efficiently paginate and how to set up patroni with etcd and haproxy.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/175-zheap-status-sequence-gaps-efficient-pagination-set-up-patroni/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Zheap Status, Sequence Gaps, Efficient Pagination, Set Up Patroni | Scaling Postgres 175]]>
                </itunes:title>
                                    <itunes:episode>175</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the current status of zheap, the gaps in sequences, how to efficiently paginate and how to set up patroni with etcd and haproxy.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/175-zheap-status-sequence-gaps-efficient-pagination-set-up-patroni/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551255/sp175.mp3" length="13018174"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the current status of zheap, the gaps in sequences, how to efficiently paginate and how to set up patroni with etcd and haproxy.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/175-zheap-status-sequence-gaps-efficient-pagination-set-up-patroni/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551255/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:13:33</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Lateral Joins, Generating JSON, dbcritic, Fetch First Rows | Scaling Postgres 174]]>
                </title>
                <pubDate>Mon, 19 Jul 2021 02:39:31 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    ee6b60fb-c974-4901-a2c4-9b661b72c602</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-174-lateral-joins-generating-json-dbcritic-fetch-first-rows-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss understanding lateral joins, generating JSON with Postgres, the dbcritic utility, and fetch first rows vs. limit.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/174-lateral-joins-generating-json-dbcritic-fetch-first-rows/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss understanding lateral joins, generating JSON with Postgres, the dbcritic utility, and fetch first rows vs. limit.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/174-lateral-joins-generating-json-dbcritic-fetch-first-rows/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Lateral Joins, Generating JSON, dbcritic, Fetch First Rows | Scaling Postgres 174]]>
                </itunes:title>
                                    <itunes:episode>174</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss understanding lateral joins, generating JSON with Postgres, the dbcritic utility, and fetch first rows vs. limit.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/174-lateral-joins-generating-json-dbcritic-fetch-first-rows/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551256/sp174.mp3" length="15264705"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss understanding lateral joins, generating JSON with Postgres, the dbcritic utility, and fetch first rows vs. limit.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/174-lateral-joins-generating-json-dbcritic-fetch-first-rows/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551256/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:54</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Delayed Replication, Materialized View Permissons, Paranoid Postgres, Memory Overcommit | Scaling Postgres 173]]>
                </title>
                <pubDate>Mon, 12 Jul 2021 02:44:21 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    86c77a48-c7a3-49a6-a340-1e6861c49d03</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-173-delayed-replication-materialized-view-permissons-paranoid-postgres-memory-overcommit-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to delay replication, working with materialized view permissions, paranoid configuration options and addressing memory overcommit.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/173-delayed-replication-materialized-view-permissions-paranoid-postgres-memory-overcommit/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to delay replication, working with materialized view permissions, paranoid configuration options and addressing memory overcommit.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/173-delayed-replication-materialized-view-permissions-paranoid-postgres-memory-overcommit/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Delayed Replication, Materialized View Permissons, Paranoid Postgres, Memory Overcommit | Scaling Postgres 173]]>
                </itunes:title>
                                    <itunes:episode>173</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to delay replication, working with materialized view permissions, paranoid configuration options and addressing memory overcommit.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/173-delayed-replication-materialized-view-permissions-paranoid-postgres-memory-overcommit/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551257/sp173.mp3" length="14840058"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to delay replication, working with materialized view permissions, paranoid configuration options and addressing memory overcommit.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/173-delayed-replication-materialized-view-permissions-paranoid-postgres-memory-overcommit/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551257/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:27</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Per-Operation Explain, PG14 Contributions, Foreign Parallel Execution, Incremental View Maintenance | Scaling Postgres 172]]>
                </title>
                <pubDate>Sun, 04 Jul 2021 23:50:22 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    fbd702fa-1011-427a-b1ed-6d60e74cd013</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-172-per-operation-explain-pg14-contributions-foreign-parallel-execution-incremental-view-maintenance-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss tracking per-operation explain analyze, Postgres 14 contribution stats, parallel execution on foreign servers and incremental view maintenance.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/172-per-operation-explain-pg14-contributions-foreign-parallel-execution-incremental-view-maintenance/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss tracking per-operation explain analyze, Postgres 14 contribution stats, parallel execution on foreign servers and incremental view maintenance.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/172-per-operation-explain-pg14-contributions-foreign-parallel-execution-incremental-view-maintenance/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Per-Operation Explain, PG14 Contributions, Foreign Parallel Execution, Incremental View Maintenance | Scaling Postgres 172]]>
                </itunes:title>
                                    <itunes:episode>172</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss tracking per-operation explain analyze, Postgres 14 contribution stats, parallel execution on foreign servers and incremental view maintenance.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/172-per-operation-explain-pg14-contributions-foreign-parallel-execution-incremental-view-maintenance/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551258/sp172.mp3" length="12150491"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss tracking per-operation explain analyze, Postgres 14 contribution stats, parallel execution on foreign servers and incremental view maintenance.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/172-per-operation-explain-pg14-contributions-foreign-parallel-execution-incremental-view-maintenance/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551258/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:39</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Practical Partitioning, Understanding pg_repack, Explaining Buffers, Multi-row Contraints | Scaling Postgres 171]]>
                </title>
                <pubDate>Mon, 28 Jun 2021 01:20:30 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    ae3379e8-cf52-4181-9795-5b6ae8f5f6be</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-171-practical-partitioning-understanding-pg-repack-explaining-buffers-multi-row-contraints-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss practical partitioning, understanding pg_repack, explaining buffers and enforcing multi-row constraints.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/171-practical-partitioning-understanding-pg_repack-explaining-buffers-multi-row-constraints/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss practical partitioning, understanding pg_repack, explaining buffers and enforcing multi-row constraints.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/171-practical-partitioning-understanding-pg_repack-explaining-buffers-multi-row-constraints/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Practical Partitioning, Understanding pg_repack, Explaining Buffers, Multi-row Contraints | Scaling Postgres 171]]>
                </itunes:title>
                                    <itunes:episode>171</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss practical partitioning, understanding pg_repack, explaining buffers and enforcing multi-row constraints.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/171-practical-partitioning-understanding-pg_repack-explaining-buffers-multi-row-constraints/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551259/sp171.mp3" length="16082651"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss practical partitioning, understanding pg_repack, explaining buffers and enforcing multi-row constraints.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/171-practical-partitioning-understanding-pg_repack-explaining-buffers-multi-row-constraints/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551259/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:16:45</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Redis vs Postgres, Hard Quadrant, Optimizing Joins, Materialized Views | Scaling Postgres 170]]>
                </title>
                <pubDate>Sun, 20 Jun 2021 23:20:55 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    28d99812-f671-4553-bcd4-1cbb984b804d</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-170-redis-vs-postgres-hard-quadrant-optimizing-joins-materialized-views-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss Redis vs. Postgres, working in the hard quadrant, how Postgres optimizes joins and working with materialized views.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/170-redis-vs-postgres-hard-quadrant-optimizing-joins-materialized-views/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss Redis vs. Postgres, working in the hard quadrant, how Postgres optimizes joins and working with materialized views.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/170-redis-vs-postgres-hard-quadrant-optimizing-joins-materialized-views/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Redis vs Postgres, Hard Quadrant, Optimizing Joins, Materialized Views | Scaling Postgres 170]]>
                </itunes:title>
                                    <itunes:episode>170</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss Redis vs. Postgres, working in the hard quadrant, how Postgres optimizes joins and working with materialized views.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/170-redis-vs-postgres-hard-quadrant-optimizing-joins-materialized-views/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551260/sp170.mp3" length="14542471"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss Redis vs. Postgres, working in the hard quadrant, how Postgres optimizes joins and working with materialized views.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/170-redis-vs-postgres-hard-quadrant-optimizing-joins-materialized-views/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551260/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:08</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Use Bigint, High Availability, Autocommit, Synchronized Sequential Scans | Scaling Postgres 169]]>
                </title>
                <pubDate>Mon, 14 Jun 2021 00:50:21 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    5b3dcb73-31b0-48f8-a3f4-857e74845477</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-169-use-bigint-high-availability-autocommit-synchronized-sequential-scans-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss only using bigint, high availability, Postgres autocommit and synchronized sequential scans.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/169-use-bigint-high-availability-autocommit-synchronized-sequential-scans/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss only using bigint, high availability, Postgres autocommit and synchronized sequential scans.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/169-use-bigint-high-availability-autocommit-synchronized-sequential-scans/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Use Bigint, High Availability, Autocommit, Synchronized Sequential Scans | Scaling Postgres 169]]>
                </itunes:title>
                                    <itunes:episode>169</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss only using bigint, high availability, Postgres autocommit and synchronized sequential scans.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/169-use-bigint-high-availability-autocommit-synchronized-sequential-scans/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551261/sp169.mp3" length="18029923"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss only using bigint, high availability, Postgres autocommit and synchronized sequential scans.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/169-use-bigint-high-availability-autocommit-synchronized-sequential-scans/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551261/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:18:46</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Managing Autovacuum, Better JSON, Avoiding Updates, OS Tuning | Scaling Postgres 168]]>
                </title>
                <pubDate>Sun, 06 Jun 2021 21:13:29 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    853b47b8-3265-4435-bff9-399e1b1559bd</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-168-managing-autovacuum-better-json-avoiding-updates-os-tuning-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss managing autovacuum, better JSON in Postgres 14, how to avoid redundant updates and operating system tuning.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/168-managing-autovacuum-better-json-avoiding-updates-os-tuning/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss managing autovacuum, better JSON in Postgres 14, how to avoid redundant updates and operating system tuning.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/168-managing-autovacuum-better-json-avoiding-updates-os-tuning/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Managing Autovacuum, Better JSON, Avoiding Updates, OS Tuning | Scaling Postgres 168]]>
                </itunes:title>
                                    <itunes:episode>168</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss managing autovacuum, better JSON in Postgres 14, how to avoid redundant updates and operating system tuning.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/168-managing-autovacuum-better-json-avoiding-updates-os-tuning/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551262/sp168.mp3" length="15462400"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss managing autovacuum, better JSON in Postgres 14, how to avoid redundant updates and operating system tuning.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/168-managing-autovacuum-better-json-avoiding-updates-os-tuning/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551262/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:16:06</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Interpreting Explain Analyze, Bulk Loading Data, Limiting Update & Delete, pg_buffercache | Scaling Postgres 167]]>
                </title>
                <pubDate>Sun, 30 May 2021 21:31:39 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    f4844c2f-5fa0-4949-abac-49b0062e9a05</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-167-interpreting-explain-analyze-bulk-loading-data-limiting-update-delete-pg-buffercache-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to interpret explain analyze, the best ways to load data in bulk, how to limit rows affected by update or delete and using pg_buffercache.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/167-interpreting-explain-analyze-bulk-data-loading-limiting-update-delete-pg_buffercache/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to interpret explain analyze, the best ways to load data in bulk, how to limit rows affected by update or delete and using pg_buffercache.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/167-interpreting-explain-analyze-bulk-data-loading-limiting-update-delete-pg_buffercache/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Interpreting Explain Analyze, Bulk Loading Data, Limiting Update & Delete, pg_buffercache | Scaling Postgres 167]]>
                </itunes:title>
                                    <itunes:episode>167</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to interpret explain analyze, the best ways to load data in bulk, how to limit rows affected by update or delete and using pg_buffercache.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p> https://www.scalingpostgres.com/episodes/167-interpreting-explain-analyze-bulk-data-loading-limiting-update-delete-pg_buffercache/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551263/sp167.mp3" length="17956780"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to interpret explain analyze, the best ways to load data in bulk, how to limit rows affected by update or delete and using pg_buffercache.
To get the show notes as well as get notified of new episodes, visit: 
 https://www.scalingpostgres.com/episodes/167-interpreting-explain-analyze-bulk-data-loading-limiting-update-delete-pg_buffercache/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551263/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:18:42</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres 14 Beta 1, PG 14 Improvements, Best Primary Keys, Composite Keys | Scaling Postgres 166]]>
                </title>
                <pubDate>Sun, 23 May 2021 22:20:16 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    15614298-00c9-4cf2-b2d7-dc4e0bccc2e5</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-166-postgres-14-beta-1-pg-14-improvements-best-primary-keys-composite-keys-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the release of Postgres 14 Beta 1, different PG 14 improvements, choosing the best type of primary key and using composite keys.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/166-postgres-14-beta1-pg14-improvements-best-primary-keys-composite-keys/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the release of Postgres 14 Beta 1, different PG 14 improvements, choosing the best type of primary key and using composite keys.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/166-postgres-14-beta1-pg14-improvements-best-primary-keys-composite-keys/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres 14 Beta 1, PG 14 Improvements, Best Primary Keys, Composite Keys | Scaling Postgres 166]]>
                </itunes:title>
                                    <itunes:episode>166</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the release of Postgres 14 Beta 1, different PG 14 improvements, choosing the best type of primary key and using composite keys.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/166-postgres-14-beta1-pg14-improvements-best-primary-keys-composite-keys/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551264/sp166.mp3" length="15864058"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the release of Postgres 14 Beta 1, different PG 14 improvements, choosing the best type of primary key and using composite keys.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/166-postgres-14-beta1-pg14-improvements-best-primary-keys-composite-keys/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551264/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:16:31</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres Releases, Data Warehouses, Exclusion Operators, Read-Only Users | Scaling Postgres 165]]>
                </title>
                <pubDate>Sun, 16 May 2021 22:09:50 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    3bd60ec6-cd2b-4570-8583-b3ef3f550754</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-165-postgres-releases-data-warehouses-exclusion-operators-read-only-users-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the newest Postgres releases, implementing a data warehouse, using exclusion operators and setting up read-only users.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/165-postgres-releases-data-warehouses-exclusion-operators-read-only-users/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the newest Postgres releases, implementing a data warehouse, using exclusion operators and setting up read-only users.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/165-postgres-releases-data-warehouses-exclusion-operators-read-only-users/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres Releases, Data Warehouses, Exclusion Operators, Read-Only Users | Scaling Postgres 165]]>
                </itunes:title>
                                    <itunes:episode>165</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the newest Postgres releases, implementing a data warehouse, using exclusion operators and setting up read-only users.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/165-postgres-releases-data-warehouses-exclusion-operators-read-only-users/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551266/sp165.mp3" length="13021100"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the newest Postgres releases, implementing a data warehouse, using exclusion operators and setting up read-only users.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/165-postgres-releases-data-warehouses-exclusion-operators-read-only-users/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551266/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:13:33</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Fast Random Rows, Fast Distinct Queries, Temp & Unlogged Tables, Terminating Connections | Scaling Postgres 164]]>
                </title>
                <pubDate>Sun, 09 May 2021 20:19:12 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    85d927d9-ee51-42f6-89a4-0f1f2c23588a</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-164-fast-random-rows-fast-distinct-queries-temp-unlogged-tables-terminating-connections-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss selecting random rows quickly, faster distinct queries, how replication handles temp and unlogged tables and how to terminate connections.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/164-fast-random-rows-fast-distinct-queries-temp-unlogged-tables-terminating-connections/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss selecting random rows quickly, faster distinct queries, how replication handles temp and unlogged tables and how to terminate connections.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/164-fast-random-rows-fast-distinct-queries-temp-unlogged-tables-terminating-connections/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Fast Random Rows, Fast Distinct Queries, Temp & Unlogged Tables, Terminating Connections | Scaling Postgres 164]]>
                </itunes:title>
                                    <itunes:episode>164</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss selecting random rows quickly, faster distinct queries, how replication handles temp and unlogged tables and how to terminate connections.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/164-fast-random-rows-fast-distinct-queries-temp-unlogged-tables-terminating-connections/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551267/sp164.mp3" length="16787330"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss selecting random rows quickly, faster distinct queries, how replication handles temp and unlogged tables and how to terminate connections.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/164-fast-random-rows-fast-distinct-queries-temp-unlogged-tables-terminating-connections/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551267/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:17:29</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[SQL Data Analysis, pgBouncer Setup, Understanding Deadlocks, Tuning & Optimization | Scaling Postgres 163]]>
                </title>
                <pubDate>Sun, 02 May 2021 21:13:38 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    f4a72c83-fef9-4d3d-b89f-9de018c4b4e3</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-163-sql-data-analysis-pgbouncer-setup-understanding-deadlocks-tuning-optimization-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss doing data analysis with SQL, sophisticated pgBouncer set ups, understanding how to avoid deadlocks and an intro to tuning and optimization.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/163-sql-data-analysis-pgbouncer-setup-understanding-deadlocks-tuning-optimization/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss doing data analysis with SQL, sophisticated pgBouncer set ups, understanding how to avoid deadlocks and an intro to tuning and optimization.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/163-sql-data-analysis-pgbouncer-setup-understanding-deadlocks-tuning-optimization/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[SQL Data Analysis, pgBouncer Setup, Understanding Deadlocks, Tuning & Optimization | Scaling Postgres 163]]>
                </itunes:title>
                                    <itunes:episode>163</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss doing data analysis with SQL, sophisticated pgBouncer set ups, understanding how to avoid deadlocks and an intro to tuning and optimization.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/163-sql-data-analysis-pgbouncer-setup-understanding-deadlocks-tuning-optimization/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551268/sp163.mp3" length="15080803"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss doing data analysis with SQL, sophisticated pgBouncer set ups, understanding how to avoid deadlocks and an intro to tuning and optimization.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/163-sql-data-analysis-pgbouncer-setup-understanding-deadlocks-tuning-optimization/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551268/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:42</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Custom Data Types, Row Level Triggers, Dynamic pl/pgsql Columns, citext Usage | Scaling Postgres 162]]>
                </title>
                <pubDate>Sun, 25 Apr 2021 21:51:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    906aa54b-3d48-4057-9467-c352959fa75a</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-162-custom-data-types-row-level-triggers-dynamic-plpgsql-columns-citext-usage-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss implementing row level triggers, how to return dynamic columns using pl/pgsql, and when to use citext.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/162-custom-data-types-row-level-triggers-dynamic-plpgsql-columns-citext-usage/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss implementing row level triggers, how to return dynamic columns using pl/pgsql, and when to use citext.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/162-custom-data-types-row-level-triggers-dynamic-plpgsql-columns-citext-usage/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Custom Data Types, Row Level Triggers, Dynamic pl/pgsql Columns, citext Usage | Scaling Postgres 162]]>
                </itunes:title>
                                    <itunes:episode>162</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss implementing row level triggers, how to return dynamic columns using pl/pgsql, and when to use citext.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/162-custom-data-types-row-level-triggers-dynamic-plpgsql-columns-citext-usage/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551269/sp162.mp3" length="10353684"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss implementing row level triggers, how to return dynamic columns using pl/pgsql, and when to use citext.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/162-custom-data-types-row-level-triggers-dynamic-plpgsql-columns-citext-usage/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551269/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:10:47</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Scaling Lessons, Synchronous Commit, Connection Management, BLOB Cleanup | Scaling Postgres 161]]>
                </title>
                <pubDate>Sun, 18 Apr 2021 22:02:05 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    b57486f2-7095-4d77-ac8f-527ca46e9a2a</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-161-scaling-lessons-synchronous-commit-connection-management-blob-cleanup-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss 5 years of scaling lessons, working with synchronous commit, managing connections and cleaning up BLOBs.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/161-scaling-lessons-synchronus-commit-connection-management-blob-cleanup/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss 5 years of scaling lessons, working with synchronous commit, managing connections and cleaning up BLOBs.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/161-scaling-lessons-synchronus-commit-connection-management-blob-cleanup/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Scaling Lessons, Synchronous Commit, Connection Management, BLOB Cleanup | Scaling Postgres 161]]>
                </itunes:title>
                                    <itunes:episode>161</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss 5 years of scaling lessons, working with synchronous commit, managing connections and cleaning up BLOBs.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/161-scaling-lessons-synchronus-commit-connection-management-blob-cleanup/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551270/sp161.mp3" length="17470693"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss 5 years of scaling lessons, working with synchronous commit, managing connections and cleaning up BLOBs.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/161-scaling-lessons-synchronus-commit-connection-management-blob-cleanup/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551270/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:18:11</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[psql Tips, Postgres 13 Upgrade, Roles Hierarchy, Replica Scaling | Scaling Postgres 160]]>
                </title>
                <pubDate>Sun, 11 Apr 2021 23:44:18 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    87516a1c-7b8f-40fa-b8f9-81a4222d8e52</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-160-psql-tips-postgres-13-upgrade-roles-hierarchy-replica-scaling-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss tips for using psql, stories from a Postgres 13 upgrade, exploring the role hierarchy and replica scaling considerations.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/160-psql-tips-postgres-13-upgrade-roles-hierarchy-replica-scaling/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss tips for using psql, stories from a Postgres 13 upgrade, exploring the role hierarchy and replica scaling considerations.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/160-psql-tips-postgres-13-upgrade-roles-hierarchy-replica-scaling/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[psql Tips, Postgres 13 Upgrade, Roles Hierarchy, Replica Scaling | Scaling Postgres 160]]>
                </itunes:title>
                                    <itunes:episode>160</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss tips for using psql, stories from a Postgres 13 upgrade, exploring the role hierarchy and replica scaling considerations.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/160-psql-tips-postgres-13-upgrade-roles-hierarchy-replica-scaling/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551271/sp160.mp3" length="8799712"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss tips for using psql, stories from a Postgres 13 upgrade, exploring the role hierarchy and replica scaling considerations.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/160-psql-tips-postgres-13-upgrade-roles-hierarchy-replica-scaling/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551271/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:09:09</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Tablespaces, Streaming Replication, More Postgres 14, Security | Scaling Postgres 159]]>
                </title>
                <pubDate>Sun, 04 Apr 2021 23:58:43 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    e27b6ef2-afc2-4ff7-86c1-ab1dd1b9934b</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-159-tablespaces-streaming-replication-more-postgres-14-security-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss when to use tablespaces, setting up streaming replication, features coming in Postgres 14 and implementing security.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/159-tablespaces-streaming-replication-more-postgres-14-security/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss when to use tablespaces, setting up streaming replication, features coming in Postgres 14 and implementing security.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/159-tablespaces-streaming-replication-more-postgres-14-security/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Tablespaces, Streaming Replication, More Postgres 14, Security | Scaling Postgres 159]]>
                </itunes:title>
                                    <itunes:episode>159</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss when to use tablespaces, setting up streaming replication, features coming in Postgres 14 and implementing security.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/159-tablespaces-streaming-replication-more-postgres-14-security/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551272/sp159.mp3" length="9167098"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss when to use tablespaces, setting up streaming replication, features coming in Postgres 14 and implementing security.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/159-tablespaces-streaming-replication-more-postgres-14-security/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551272/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:09:32</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Vacuum Speed Up, Faster Foreign Tables, Fast Queries With Union, Query Optimizer | Scaling Postgres 158]]>
                </title>
                <pubDate>Sun, 28 Mar 2021 21:43:55 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    35bd8583-4c8a-4770-b6eb-52fa704297d3</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-158-vacuum-speed-up-faster-foreign-tables-fast-queries-with-union-query-optimizer-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss a vacuum speed up and faster foreign tables in Postgres 14, running faster queries with union and learning about the query optimizer.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/158-vacuum-speed-up-faster-foreign-tables-fast-queries-with-union-query-optimizer/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a vacuum speed up and faster foreign tables in Postgres 14, running faster queries with union and learning about the query optimizer.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/158-vacuum-speed-up-faster-foreign-tables-fast-queries-with-union-query-optimizer/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Vacuum Speed Up, Faster Foreign Tables, Fast Queries With Union, Query Optimizer | Scaling Postgres 158]]>
                </itunes:title>
                                    <itunes:episode>158</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss a vacuum speed up and faster foreign tables in Postgres 14, running faster queries with union and learning about the query optimizer.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/158-vacuum-speed-up-faster-foreign-tables-fast-queries-with-union-query-optimizer/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551273/sp158.mp3" length="19015889"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a vacuum speed up and faster foreign tables in Postgres 14, running faster queries with union and learning about the query optimizer.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/158-vacuum-speed-up-faster-foreign-tables-fast-queries-with-union-query-optimizer/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551273/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:19:48</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[auto_explain Overhead, Postgres Data Lake, Citus Shard Rebalance, SSL Authentication | Scaling Postgres 157]]>
                </title>
                <pubDate>Mon, 22 Mar 2021 00:59:43 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    39257e55-b57e-4d9c-9f21-b27678867d9e</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-157-auto-explain-overhead-postgres-data-lake-citus-shard-rebalance-ssl-authentication-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss auto_explain's overhead, setting up a Postgres data lake, rebalancing a Citus shared database and implementing SSL authentication.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/157-auto_explain-overhead-postgres-data-lake-citus-shard-rebalance-ssl-authentication/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss auto_explain's overhead, setting up a Postgres data lake, rebalancing a Citus shared database and implementing SSL authentication.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/157-auto_explain-overhead-postgres-data-lake-citus-shard-rebalance-ssl-authentication/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[auto_explain Overhead, Postgres Data Lake, Citus Shard Rebalance, SSL Authentication | Scaling Postgres 157]]>
                </itunes:title>
                                    <itunes:episode>157</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss auto_explain's overhead, setting up a Postgres data lake, rebalancing a Citus shared database and implementing SSL authentication.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/157-auto_explain-overhead-postgres-data-lake-citus-shard-rebalance-ssl-authentication/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551274/sp157.mp3" length="17929195"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss auto_explain's overhead, setting up a Postgres data lake, rebalancing a Citus shared database and implementing SSL authentication.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/157-auto_explain-overhead-postgres-data-lake-citus-shard-rebalance-ssl-authentication/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551274/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:18:40</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Columnar Storage, Docker Containers, Notify & Listen, Tuning RHEL | Scaling Postgres 156]]>
                </title>
                <pubDate>Mon, 15 Mar 2021 00:42:05 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    bf744147-d696-46f6-affc-e92ab63ddb89</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-156-columnar-storage-docker-containers-notify-listen-tuning-rhel-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss Citus 10 columnar storage, using Postgres in docker containers, using notify &amp; listen for real-time apps and tuning RHEL.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/156-columnar-storage-docker-containers-notify-listen-tuning-rhel/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss Citus 10 columnar storage, using Postgres in docker containers, using notify & listen for real-time apps and tuning RHEL.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/156-columnar-storage-docker-containers-notify-listen-tuning-rhel/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Columnar Storage, Docker Containers, Notify & Listen, Tuning RHEL | Scaling Postgres 156]]>
                </itunes:title>
                                    <itunes:episode>156</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss Citus 10 columnar storage, using Postgres in docker containers, using notify &amp; listen for real-time apps and tuning RHEL.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/156-columnar-storage-docker-containers-notify-listen-tuning-rhel/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551275/sp156.mp3" length="16204695"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss Citus 10 columnar storage, using Postgres in docker containers, using notify & listen for real-time apps and tuning RHEL.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/156-columnar-storage-docker-containers-notify-listen-tuning-rhel/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551275/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:16:52</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Citus Open Source, Time Series Performance, Subscripting Updates, target_session_attrs | Scaling Postgres 155]]>
                </title>
                <pubDate>Mon, 08 Mar 2021 00:11:41 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    2ba73451-ad99-44bd-915e-38b676977373</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-155-citus-open-source-time-series-performance-subscripting-updates-target-session-attrs-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss Citus 10 open source, time series performance in native Postgres, using subscripting for updates and new target_session_attrs.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/155-citus-open-source-time-series-performance-subscripting-updates-target_session_attrs/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss Citus 10 open source, time series performance in native Postgres, using subscripting for updates and new target_session_attrs.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/155-citus-open-source-time-series-performance-subscripting-updates-target_session_attrs/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Citus Open Source, Time Series Performance, Subscripting Updates, target_session_attrs | Scaling Postgres 155]]>
                </itunes:title>
                                                    <itunes:season>155</itunes:season>
                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss Citus 10 open source, time series performance in native Postgres, using subscripting for updates and new target_session_attrs.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/155-citus-open-source-time-series-performance-subscripting-updates-target_session_attrs/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551276/sp155.mp3" length="16577933"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss Citus 10 open source, time series performance in native Postgres, using subscripting for updates and new target_session_attrs.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/155-citus-open-source-time-series-performance-subscripting-updates-target_session_attrs/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551276/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:17:16</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Connection Queuing, Connection Pool Size, Simple Audting, Fuzzy Matching | Scaling Postgres 154]]>
                </title>
                <pubDate>Mon, 01 Mar 2021 02:26:32 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    0d7d0734-652f-45ca-99fd-d985ece576b2</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-154-connection-queuing-connection-pool-size-simple-audting-fuzzy-matching-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss connection queuing, estimating connection pools size, how to do simple auditing and how to run queries using fuzzy matching.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/154-connection-queuing-connection-pool-size-simple-auditing-fuzzy-matching/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss connection queuing, estimating connection pools size, how to do simple auditing and how to run queries using fuzzy matching.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/154-connection-queuing-connection-pool-size-simple-auditing-fuzzy-matching/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Connection Queuing, Connection Pool Size, Simple Audting, Fuzzy Matching | Scaling Postgres 154]]>
                </itunes:title>
                                    <itunes:episode>154</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss connection queuing, estimating connection pools size, how to do simple auditing and how to run queries using fuzzy matching.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/154-connection-queuing-connection-pool-size-simple-auditing-fuzzy-matching/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551277/sp154.mp3" length="18638889"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss connection queuing, estimating connection pools size, how to do simple auditing and how to run queries using fuzzy matching.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/154-connection-queuing-connection-pool-size-simple-auditing-fuzzy-matching/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551277/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:19:24</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Int to BigInt, Resistance is Futile, Optimizer Statistics, Advanced Query Optimization | Scaling Postgres 153]]>
                </title>
                <pubDate>Sun, 21 Feb 2021 22:56:34 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    bf88fc5a-2899-477c-b06c-f01125c425a9</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-153-int-to-bigint-resistance-is-futile-optimizer-statistics-advanced-query-optimization-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to convert an integer primary key to a bigint, how container resistance is futile, how the optimizer uses statistics and how to set manual statistics.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/153-int-to-bigint-resistance-is-futile-optimizer-statistics-advanced-query-optimization/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to convert an integer primary key to a bigint, how container resistance is futile, how the optimizer uses statistics and how to set manual statistics.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/153-int-to-bigint-resistance-is-futile-optimizer-statistics-advanced-query-optimization/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Int to BigInt, Resistance is Futile, Optimizer Statistics, Advanced Query Optimization | Scaling Postgres 153]]>
                </itunes:title>
                                    <itunes:episode>153</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to convert an integer primary key to a bigint, how container resistance is futile, how the optimizer uses statistics and how to set manual statistics.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/153-int-to-bigint-resistance-is-futile-optimizer-statistics-advanced-query-optimization/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551278/sp153.mp3" length="11910164"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to convert an integer primary key to a bigint, how container resistance is futile, how the optimizer uses statistics and how to set manual statistics.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/153-int-to-bigint-resistance-is-futile-optimizer-statistics-advanced-query-optimization/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551278/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:24</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[New Releases, Reconnect After Failure, Bablefish, Troubleshoot Disk & Memory | Scaling Postgres 152]]>
                </title>
                <pubDate>Sun, 14 Feb 2021 22:46:24 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    f6f8edbf-5aa4-4b3c-959d-f5c86d803fb7</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-152-new-releases-reconnect-after-failure-bablefish-troubleshoot-disk-memory-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss new PostgreSQL releases, reconnecting after a connection failure, Babelfish SQL Server compatibility and troubleshooting disk and memory issues.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/152-new-releases-reconnect-after-failure-babelfish-troubleshoot-disk-memory/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss new PostgreSQL releases, reconnecting after a connection failure, Babelfish SQL Server compatibility and troubleshooting disk and memory issues.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/152-new-releases-reconnect-after-failure-babelfish-troubleshoot-disk-memory/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[New Releases, Reconnect After Failure, Bablefish, Troubleshoot Disk & Memory | Scaling Postgres 152]]>
                </itunes:title>
                                    <itunes:episode>152</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss new PostgreSQL releases, reconnecting after a connection failure, Babelfish SQL Server compatibility and troubleshooting disk and memory issues.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/152-new-releases-reconnect-after-failure-babelfish-troubleshoot-disk-memory/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551279/sp152.mp3" length="14921978"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss new PostgreSQL releases, reconnecting after a connection failure, Babelfish SQL Server compatibility and troubleshooting disk and memory issues.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/152-new-releases-reconnect-after-failure-babelfish-troubleshoot-disk-memory/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551279/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:32</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Cleaning Up, Function Performance, 11 Million IOPS, Change Data Capture | Scaling Postgres 151]]>
                </title>
                <pubDate>Sun, 07 Feb 2021 22:00:16 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    14bd0be1-1cfa-452c-aa68-72d88cadf0f6</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-151-cleaning-up-function-performance-11-million-iops-change-data-capture-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss cleaning up your database, function performance, 11 million IOPS and change data capture.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/151-cleaning-up-function-performance-11-million-iops-change-data-capture/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss cleaning up your database, function performance, 11 million IOPS and change data capture.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/151-cleaning-up-function-performance-11-million-iops-change-data-capture/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Cleaning Up, Function Performance, 11 Million IOPS, Change Data Capture | Scaling Postgres 151]]>
                </itunes:title>
                                    <itunes:episode>151</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss cleaning up your database, function performance, 11 million IOPS and change data capture.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/151-cleaning-up-function-performance-11-million-iops-change-data-capture/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551280/sp151.mp3" length="17442272"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss cleaning up your database, function performance, 11 million IOPS and change data capture.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/151-cleaning-up-function-performance-11-million-iops-change-data-capture/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551280/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:18:10</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Scaling Advice, Vicious Cycle, Improve Observability, Addressing Corruption | Scaling Postgres 150]]>
                </title>
                <pubDate>Sun, 31 Jan 2021 22:05:24 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    3158956e-bdb0-4261-a152-ac4982876075</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-150-scaling-advice-vicious-cycle-improve-observability-addressing-corruption-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss scaling advice, a vicious cycle of WAL writes, how to improve observability and addressing database corruption.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/150-scaling-advice-vicious-cycle-improving-observability-addressing-corruption/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss scaling advice, a vicious cycle of WAL writes, how to improve observability and addressing database corruption.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/150-scaling-advice-vicious-cycle-improving-observability-addressing-corruption/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Scaling Advice, Vicious Cycle, Improve Observability, Addressing Corruption | Scaling Postgres 150]]>
                </itunes:title>
                                    <itunes:episode>150</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss scaling advice, a vicious cycle of WAL writes, how to improve observability and addressing database corruption.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/150-scaling-advice-vicious-cycle-improving-observability-addressing-corruption/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551282/sp150.mp3" length="16271986"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss scaling advice, a vicious cycle of WAL writes, how to improve observability and addressing database corruption.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/150-scaling-advice-vicious-cycle-improving-observability-addressing-corruption/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551282/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:16:57</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[ARM Tests, Tips & Tricks, Hierarchical Structures, Benchmarking Framework | Scaling Postgres 149]]>
                </title>
                <pubDate>Sun, 24 Jan 2021 22:41:50 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    b04887ab-2b4b-4b4b-8394-63afb06ce1ed</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-149-arm-tests-tips-tricks-hierarchical-structures-benchmarking-framework-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss tests of Postgres on ARM processors, 2021 tips &amp; tricks, working with hierarchical structures and creating a benchmarking framework.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/149-arm-tests-tips-tricks-hierarchical-structures-benchmarking-framework/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss tests of Postgres on ARM processors, 2021 tips & tricks, working with hierarchical structures and creating a benchmarking framework.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/149-arm-tests-tips-tricks-hierarchical-structures-benchmarking-framework/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[ARM Tests, Tips & Tricks, Hierarchical Structures, Benchmarking Framework | Scaling Postgres 149]]>
                </itunes:title>
                                    <itunes:episode>149</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss tests of Postgres on ARM processors, 2021 tips &amp; tricks, working with hierarchical structures and creating a benchmarking framework.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/149-arm-tests-tips-tricks-hierarchical-structures-benchmarking-framework/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551281/sp149.mp3" length="11897626"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss tests of Postgres on ARM processors, 2021 tips & tricks, working with hierarchical structures and creating a benchmarking framework.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/149-arm-tests-tips-tricks-hierarchical-structures-benchmarking-framework/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551281/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:23</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Hash Indexes, Int Float Numeric Types, Postgres 14 Features, Data Science | Scaling Postgres 148]]>
                </title>
                <pubDate>Sun, 17 Jan 2021 22:00:57 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    a4387954-82b4-4e8e-b268-b2bbc119c541</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-148-hash-indexes-int-float-numeric-types-postgres-14-features-data-science-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss hash indexes, the int, float and numeric data types, features coming in Postgres 14 and data science in Postgres.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/148-hash-indexes-int-float-numeric-postgres-14-features-data-science/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss hash indexes, the int, float and numeric data types, features coming in Postgres 14 and data science in Postgres.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/148-hash-indexes-int-float-numeric-postgres-14-features-data-science/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Hash Indexes, Int Float Numeric Types, Postgres 14 Features, Data Science | Scaling Postgres 148]]>
                </itunes:title>
                                    <itunes:episode>148</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss hash indexes, the int, float and numeric data types, features coming in Postgres 14 and data science in Postgres.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/148-hash-indexes-int-float-numeric-postgres-14-features-data-science/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551283/sp148.mp3" length="11438706"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss hash indexes, the int, float and numeric data types, features coming in Postgres 14 and data science in Postgres.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/148-hash-indexes-int-float-numeric-postgres-14-features-data-science/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551283/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:11:54</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[DBMS of the Year, Better Data Migrations, Idle Connection Impact, Security Implementation Guide | Scaling Postgres 147]]>
                </title>
                <pubDate>Sun, 10 Jan 2021 22:44:59 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    455c84a1-3402-4a49-a400-0bea83bb4799</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-147-dbms-of-the-year-better-data-migrations-idle-connection-impact-security-implementation-guide-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss PostgreSQL as the DBMS of the year, running better data migrations, the impact of idle connections and a security implementation guild.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/147-dbms-of-the-year-better-data-migrations-idle-connection-impact-security-implementation-guide/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss PostgreSQL as the DBMS of the year, running better data migrations, the impact of idle connections and a security implementation guild.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/147-dbms-of-the-year-better-data-migrations-idle-connection-impact-security-implementation-guide/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[DBMS of the Year, Better Data Migrations, Idle Connection Impact, Security Implementation Guide | Scaling Postgres 147]]>
                </itunes:title>
                                    <itunes:episode>147</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss PostgreSQL as the DBMS of the year, running better data migrations, the impact of idle connections and a security implementation guild.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/147-dbms-of-the-year-better-data-migrations-idle-connection-impact-security-implementation-guide/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551284/sp147.mp3" length="19652440"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss PostgreSQL as the DBMS of the year, running better data migrations, the impact of idle connections and a security implementation guild.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/147-dbms-of-the-year-better-data-migrations-idle-connection-impact-security-implementation-guide/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551284/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:20:28</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Active-Active & Federated, Memory Speed, Table Rewrite Causes, PostgreSQL Shibboleth | Scaling Postgres 146]]>
                </title>
                <pubDate>Mon, 04 Jan 2021 00:22:42 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    2e284a5b-a05c-4d20-a5e1-b23fff869b4d</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-146-active-active-federated-memory-speed-table-rewrite-causes-postgresql-shibboleth-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss setting up active-active instances with federation, the impact of memory speed, the causes of table rewrites and the Postgres shibboleth.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/146-active-active-federated-memory-speed-table-rewrite-causes-postgresql-shibboleth/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss setting up active-active instances with federation, the impact of memory speed, the causes of table rewrites and the Postgres shibboleth.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/146-active-active-federated-memory-speed-table-rewrite-causes-postgresql-shibboleth/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Active-Active & Federated, Memory Speed, Table Rewrite Causes, PostgreSQL Shibboleth | Scaling Postgres 146]]>
                </itunes:title>
                                    <itunes:episode>146</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss setting up active-active instances with federation, the impact of memory speed, the causes of table rewrites and the Postgres shibboleth.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/146-active-active-federated-memory-speed-table-rewrite-causes-postgresql-shibboleth/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551285/sp146.mp3" length="14173413"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss setting up active-active instances with federation, the impact of memory speed, the causes of table rewrites and the Postgres shibboleth.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/146-active-active-federated-memory-speed-table-rewrite-causes-postgresql-shibboleth/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551285/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:45</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[PgMiner Botnet, Collation Index Corruption, postgresql.conf, Custom Data Types | Scaling Postgres 145]]>
                </title>
                <pubDate>Sun, 20 Dec 2020 22:18:30 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    8deffb73-3996-4664-a219-f1982b6d27a0</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-145-pgminer-botnet-collation-index-corruption-postgresqlconf-custom-data-types-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the PGMiner botnet attack, how collation changes can cause index corruption, managing your postgresql.conf and implementing custom data types.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/145-pgminer-botnet-attack-collation-index-corruption-postgresqlconf-custom-data-types/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the PGMiner botnet attack, how collation changes can cause index corruption, managing your postgresql.conf and implementing custom data types.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/145-pgminer-botnet-attack-collation-index-corruption-postgresqlconf-custom-data-types/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[PgMiner Botnet, Collation Index Corruption, postgresql.conf, Custom Data Types | Scaling Postgres 145]]>
                </itunes:title>
                                                    <itunes:season>145</itunes:season>
                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the PGMiner botnet attack, how collation changes can cause index corruption, managing your postgresql.conf and implementing custom data types.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/145-pgminer-botnet-attack-collation-index-corruption-postgresqlconf-custom-data-types/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551286/sp145.mp3" length="13544803"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the PGMiner botnet attack, how collation changes can cause index corruption, managing your postgresql.conf and implementing custom data types.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/145-pgminer-botnet-attack-collation-index-corruption-postgresqlconf-custom-data-types/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551286/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:06</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres Migration, Bulk Data Loading, Updates vs. Upgrades, UUID Benchmarks | Scaling Postgres 144]]>
                </title>
                <pubDate>Sun, 13 Dec 2020 22:17:59 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    db7c45b5-538b-4611-8be8-04960b85cec5</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-144-postgres-migration-bulk-data-loading-updates-vs-upgrades-uuid-benchmarks-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss a Mongo to Postgres migration, the best way to bulk load data, running an update vs. an upgrade and benchmarks for UUIDs.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/144-postgres-migration-bulk-data-loading-updates-vs-upgrades-uuid-benchmarks/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a Mongo to Postgres migration, the best way to bulk load data, running an update vs. an upgrade and benchmarks for UUIDs.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/144-postgres-migration-bulk-data-loading-updates-vs-upgrades-uuid-benchmarks/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres Migration, Bulk Data Loading, Updates vs. Upgrades, UUID Benchmarks | Scaling Postgres 144]]>
                </itunes:title>
                                    <itunes:episode>144</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss a Mongo to Postgres migration, the best way to bulk load data, running an update vs. an upgrade and benchmarks for UUIDs.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/144-postgres-migration-bulk-data-loading-updates-vs-upgrades-uuid-benchmarks/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551287/sp144.mp3" length="11671928"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a Mongo to Postgres migration, the best way to bulk load data, running an update vs. an upgrade and benchmarks for UUIDs.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/144-postgres-migration-bulk-data-loading-updates-vs-upgrades-uuid-benchmarks/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551287/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:09</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Microsoft SQL Server Compatible, Time Series Performance, Feature Casualties, BLOB Cleanup | Scaling Postgres 143]]>
                </title>
                <pubDate>Mon, 07 Dec 2020 01:41:38 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    fb34fbc4-a7be-40aa-9d18-2ee6aae5a79c</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-143-microsoft-sql-server-compatible-time-series-performance-feature-casualties-blob-cleanup-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss Microsoft SQL server compatibility, the performance of time series DBs, DB feature casualties and how to clean up BLOBs.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/143-microsoft-sql-server-compatible-time-series-performance-feature-casualties-blob-cleanup/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss Microsoft SQL server compatibility, the performance of time series DBs, DB feature casualties and how to clean up BLOBs.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/143-microsoft-sql-server-compatible-time-series-performance-feature-casualties-blob-cleanup/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Microsoft SQL Server Compatible, Time Series Performance, Feature Casualties, BLOB Cleanup | Scaling Postgres 143]]>
                </itunes:title>
                                    <itunes:episode>143</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss Microsoft SQL server compatibility, the performance of time series DBs, DB feature casualties and how to clean up BLOBs.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/143-microsoft-sql-server-compatible-time-series-performance-feature-casualties-blob-cleanup/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551288/sp143.mp3" length="17965139"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss Microsoft SQL server compatibility, the performance of time series DBs, DB feature casualties and how to clean up BLOBs.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/143-microsoft-sql-server-compatible-time-series-performance-feature-casualties-blob-cleanup/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551288/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:18:42</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Insert vs. Update, Select * Performance, Debezium Set Up, Standardizing Data | Scaling Postgres 142]]>
                </title>
                <pubDate>Sun, 29 Nov 2020 22:19:57 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    fa496161-194f-4144-b0a2-2f1b1ec49775</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-142-insert-vs-update-select-performance-debezium-set-up-standardizing-data-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss inserts vs. updates, select * performance, how to set up Debezium and methods to standardize data.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/142-insert-vs-update-select-performance-debezium-set-up-standardizing-data/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss inserts vs. updates, select * performance, how to set up Debezium and methods to standardize data.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/142-insert-vs-update-select-performance-debezium-set-up-standardizing-data/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Insert vs. Update, Select * Performance, Debezium Set Up, Standardizing Data | Scaling Postgres 142]]>
                </itunes:title>
                                    <itunes:episode>142</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss inserts vs. updates, select * performance, how to set up Debezium and methods to standardize data.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/142-insert-vs-update-select-performance-debezium-set-up-standardizing-data/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551289/sp142.mp3" length="13032803"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss inserts vs. updates, select * performance, how to set up Debezium and methods to standardize data.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/142-insert-vs-update-select-performance-debezium-set-up-standardizing-data/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551289/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:13:34</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Unattended Upgrade, ARM Benchmarks, Exploration, PostGIS Performance | Scaling Postgres 141]]>
                </title>
                <pubDate>Mon, 23 Nov 2020 00:20:47 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    33bea220-25e9-4520-91cd-356b74536aca</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-141-unattended-upgrade-arm-benchmarks-exploration-postgis-performance-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss an unattended upgrade, ARM Postgres benchmarks, how to explore new databases and PostGIS performance.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/141-unattended-upgrade-arm-benchmarks-exploration-postgis-performance/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss an unattended upgrade, ARM Postgres benchmarks, how to explore new databases and PostGIS performance.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/141-unattended-upgrade-arm-benchmarks-exploration-postgis-performance/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Unattended Upgrade, ARM Benchmarks, Exploration, PostGIS Performance | Scaling Postgres 141]]>
                </itunes:title>
                                    <itunes:episode>141</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss an unattended upgrade, ARM Postgres benchmarks, how to explore new databases and PostGIS performance.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/141-unattended-upgrade-arm-benchmarks-exploration-postgis-performance/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551290/sp141.mp3" length="10096640"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss an unattended upgrade, ARM Postgres benchmarks, how to explore new databases and PostGIS performance.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/141-unattended-upgrade-arm-benchmarks-exploration-postgis-performance/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551290/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:10:31</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Replication Conflicts, Postgres Governance, pg_crash, MobilityDB | Scaling Postgres 140]]>
                </title>
                <pubDate>Sun, 15 Nov 2020 22:28:48 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    09d88513-e5e7-4f54-a8d5-11b50982edb7</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-140-replication-conflicts-postgres-governance-pg-crash-mobilitydb-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss replication conflicts, how Postgres is governed, a pg_crash utility and tracking temporal spatial data with Mobility.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/140-replication-conflicts-postgres-governance-pg_crash-mobilitydb/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss replication conflicts, how Postgres is governed, a pg_crash utility and tracking temporal spatial data with Mobility.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/140-replication-conflicts-postgres-governance-pg_crash-mobilitydb/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Replication Conflicts, Postgres Governance, pg_crash, MobilityDB | Scaling Postgres 140]]>
                </itunes:title>
                                    <itunes:episode>140</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss replication conflicts, how Postgres is governed, a pg_crash utility and tracking temporal spatial data with Mobility.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/140-replication-conflicts-postgres-governance-pg_crash-mobilitydb/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551291/sp140.mp3" length="11004865"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss replication conflicts, how Postgres is governed, a pg_crash utility and tracking temporal spatial data with Mobility.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/140-replication-conflicts-postgres-governance-pg_crash-mobilitydb/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551291/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:11:27</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Weekly News, Full-Text Search Performance, pg_cron, Bulk Data Loading | Scaling Postgres 139]]>
                </title>
                <pubDate>Sun, 08 Nov 2020 22:16:42 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    fde44151-babf-49d2-a544-ca5d315e61b4</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-139-weekly-news-full-text-search-performance-pg-cron-bulk-data-loading-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss Postgres weekly news, full-text search performance, enhancements to pg_cron and the best way to bulk load data.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/139-weekly-news-full-text-search-performance-pg_cron-bulk-data-loading/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss Postgres weekly news, full-text search performance, enhancements to pg_cron and the best way to bulk load data.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/139-weekly-news-full-text-search-performance-pg_cron-bulk-data-loading/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Weekly News, Full-Text Search Performance, pg_cron, Bulk Data Loading | Scaling Postgres 139]]>
                </itunes:title>
                                    <itunes:episode>139</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss Postgres weekly news, full-text search performance, enhancements to pg_cron and the best way to bulk load data.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/139-weekly-news-full-text-search-performance-pg_cron-bulk-data-loading/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551292/sp139.mp3" length="12116636"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss Postgres weekly news, full-text search performance, enhancements to pg_cron and the best way to bulk load data.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/139-weekly-news-full-text-search-performance-pg_cron-bulk-data-loading/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551292/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:37</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Scaling Connections, TimescaleDB, Time-series Gaps, Red & Golden Signals | Scaling Postgres 138]]>
                </title>
                <pubDate>Sun, 01 Nov 2020 22:47:24 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    7a04e9ef-6137-4ddb-a5d5-3188f528abb0</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-138-scaling-connections-timescaledb-time-series-gaps-red-golden-signals-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss scaling connections, the release of TimescaleDB 2.0, how to find time-series gaps and monitoring RED &amp; Golden signals.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/138-scaling-connections-timescaledb-time-series-gaps-red-golden-signals/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss scaling connections, the release of TimescaleDB 2.0, how to find time-series gaps and monitoring RED & Golden signals.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/138-scaling-connections-timescaledb-time-series-gaps-red-golden-signals/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Scaling Connections, TimescaleDB, Time-series Gaps, Red & Golden Signals | Scaling Postgres 138]]>
                </itunes:title>
                                    <itunes:episode>138</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss scaling connections, the release of TimescaleDB 2.0, how to find time-series gaps and monitoring RED &amp; Golden signals.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/138-scaling-connections-timescaledb-time-series-gaps-red-golden-signals/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551293/sp138.mp3" length="16264463"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss scaling connections, the release of TimescaleDB 2.0, how to find time-series gaps and monitoring RED & Golden signals.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/138-scaling-connections-timescaledb-time-series-gaps-red-golden-signals/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551293/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:16:56</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Toast Impact, zheap Storage, More Performance, pg_rewind Changes | Scaling Postgres 137]]>
                </title>
                <pubDate>Mon, 26 Oct 2020 00:07:55 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    f185aa06-31ba-41e8-aaea-e92d1ff7dab8</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-137-toast-impact-zheap-storage-more-performance-pg-rewind-changes-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the impact of toast, zheap storage results, more Postgres 13 performance data and changes to pg_rewind.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/137-toast-impact-zheap-storage-more-performance-pg_rewind_changes/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the impact of toast, zheap storage results, more Postgres 13 performance data and changes to pg_rewind.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/137-toast-impact-zheap-storage-more-performance-pg_rewind_changes/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Toast Impact, zheap Storage, More Performance, pg_rewind Changes | Scaling Postgres 137]]>
                </itunes:title>
                                    <itunes:episode>137</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the impact of toast, zheap storage results, more Postgres 13 performance data and changes to pg_rewind.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/137-toast-impact-zheap-storage-more-performance-pg_rewind_changes/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551294/sp137.mp3" length="20386377"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the impact of toast, zheap storage results, more Postgres 13 performance data and changes to pg_rewind.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/137-toast-impact-zheap-storage-more-performance-pg_rewind_changes/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551294/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:21:14</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Stat Tracking, Temporary Tables, pg_squeeze, pg_auto_failover | Scaling Postgres 136]]>
                </title>
                <pubDate>Mon, 19 Oct 2020 00:07:55 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    e99e8a54-54bd-4904-b375-28ace7f56ff4</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-136-stat-tracking-temporary-tables-pg-squeeze-pg-auto-failover-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss stat tracking, temporary tables, a new utility called pg_squeeze and an update to pg_auto_failover.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/136-stat-tracking-temporary-tables-pg_squeeze-pg_auto_failover/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss stat tracking, temporary tables, a new utility called pg_squeeze and an update to pg_auto_failover.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/136-stat-tracking-temporary-tables-pg_squeeze-pg_auto_failover/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Stat Tracking, Temporary Tables, pg_squeeze, pg_auto_failover | Scaling Postgres 136]]>
                </itunes:title>
                                    <itunes:episode>136</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss stat tracking, temporary tables, a new utility called pg_squeeze and an update to pg_auto_failover.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/136-stat-tracking-temporary-tables-pg_squeeze-pg_auto_failover/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551295/sp136.mp3" length="12620277"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss stat tracking, temporary tables, a new utility called pg_squeeze and an update to pg_auto_failover.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/136-stat-tracking-temporary-tables-pg_squeeze-pg_auto_failover/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551295/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:13:08</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Connection Scalability, Benchmarking Performance, Community Impact, zheap Progress | Scaling Postgres 135]]>
                </title>
                <pubDate>Sun, 11 Oct 2020 23:56:09 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    02430092-9723-4ec4-9ccd-59522d100ae2</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-135-connection-scalability-benchmarking-performance-community-impact-zheap-progress-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss connection scalability, benchmarking Postgres performance, the community impact of an acquisition and the progress of zheap.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/135-connection-scalability-benchmarking-performance-community-impact-zheap-progress/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss connection scalability, benchmarking Postgres performance, the community impact of an acquisition and the progress of zheap.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/135-connection-scalability-benchmarking-performance-community-impact-zheap-progress/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Connection Scalability, Benchmarking Performance, Community Impact, zheap Progress | Scaling Postgres 135]]>
                </itunes:title>
                                    <itunes:episode>135</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss connection scalability, benchmarking Postgres performance, the community impact of an acquisition and the progress of zheap.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/135-connection-scalability-benchmarking-performance-community-impact-zheap-progress/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551296/sp135.mp3" length="18921430"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss connection scalability, benchmarking Postgres performance, the community impact of an acquisition and the progress of zheap.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/135-connection-scalability-benchmarking-performance-community-impact-zheap-progress/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551296/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:19:42</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Community Acquisition, Space Saving Terabytes, WAL Archiving, Vacuum Analyze Tips | Scaling Postgres 134]]>
                </title>
                <pubDate>Sun, 04 Oct 2020 23:45:48 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    b46fe991-bf15-4dd0-a067-e5792f6319cf</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-134-community-acquisition-space-saving-terabytes-wal-archiving-vacuum-analyze-tips-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss a company acquisition within the Postgres community, how to save terabytes of space, setting up WAL archiving and vacuum/analyze tips.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/134-community-acquisition-space-saving-terabytes-wal-archiving-vacuum-analyze-tips/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a company acquisition within the Postgres community, how to save terabytes of space, setting up WAL archiving and vacuum/analyze tips.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/134-community-acquisition-space-saving-terabytes-wal-archiving-vacuum-analyze-tips/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Community Acquisition, Space Saving Terabytes, WAL Archiving, Vacuum Analyze Tips | Scaling Postgres 134]]>
                </itunes:title>
                                    <itunes:episode>134</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss a company acquisition within the Postgres community, how to save terabytes of space, setting up WAL archiving and vacuum/analyze tips.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/134-community-acquisition-space-saving-terabytes-wal-archiving-vacuum-analyze-tips/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551297/sp134.mp3" length="13604989"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss a company acquisition within the Postgres community, how to save terabytes of space, setting up WAL archiving and vacuum/analyze tips.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/134-community-acquisition-space-saving-terabytes-wal-archiving-vacuum-analyze-tips/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551297/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:10</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres 13 Released, What's New In Postgres 13, Debugging PL/PGSQL, Monitoring | Scaling Postgres 133]]>
                </title>
                <pubDate>Sun, 27 Sep 2020 22:16:24 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    8953523f-866b-48b9-b451-494915547fda</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-133-postgres-13-released-whats-new-in-postgres-13-debugging-plpgsql-monitoring-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the release of Postgres 13, what is new in Postgres 13, how to debug PL/PGSQL and Postgres monitoring best practices.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/133-postgres-13-released-what-is-new-in-postgres-13-debugging-plpgsql-monitoring/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the release of Postgres 13, what is new in Postgres 13, how to debug PL/PGSQL and Postgres monitoring best practices.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/133-postgres-13-released-what-is-new-in-postgres-13-debugging-plpgsql-monitoring/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres 13 Released, What's New In Postgres 13, Debugging PL/PGSQL, Monitoring | Scaling Postgres 133]]>
                </itunes:title>
                                    <itunes:episode>133</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the release of Postgres 13, what is new in Postgres 13, how to debug PL/PGSQL and Postgres monitoring best practices.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/133-postgres-13-released-what-is-new-in-postgres-13-debugging-plpgsql-monitoring/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551298/sp133.mp3" length="13336659"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the release of Postgres 13, what is new in Postgres 13, how to debug PL/PGSQL and Postgres monitoring best practices.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/133-postgres-13-released-what-is-new-in-postgres-13-debugging-plpgsql-monitoring/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551298/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:13:53</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres 13 RC1, Upgrading at Scale, With Ties, HOT Updates | Scaling Postgres 132]]>
                </title>
                <pubDate>Mon, 21 Sep 2020 19:12:04 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    5f79be74-a8b8-400f-8762-3eb019038327</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-132-postgres-13-rc1-upgrading-at-scale-with-ties-hot-updates-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the release of Postgres 13 RC1, how to upgrade Postgres at scale, using limit with ties and understanding Heap Only Tuple (HOT) updates.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/132-postgres-13-rc1-upgrading-at-scale-with-ties-hot-updates/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the release of Postgres 13 RC1, how to upgrade Postgres at scale, using limit with ties and understanding Heap Only Tuple (HOT) updates.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/132-postgres-13-rc1-upgrading-at-scale-with-ties-hot-updates/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres 13 RC1, Upgrading at Scale, With Ties, HOT Updates | Scaling Postgres 132]]>
                </itunes:title>
                                    <itunes:episode>132</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the release of Postgres 13 RC1, how to upgrade Postgres at scale, using limit with ties and understanding Heap Only Tuple (HOT) updates.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/132-postgres-13-rc1-upgrading-at-scale-with-ties-hot-updates/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551299/sp132.mp3" length="16946573"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the release of Postgres 13 RC1, how to upgrade Postgres at scale, using limit with ties and understanding Heap Only Tuple (HOT) updates.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/132-postgres-13-rc1-upgrading-at-scale-with-ties-hot-updates/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551299/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:17:39</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Slow Archival, Index Improvements, Node Metrics, Join or Subquery | Scaling Postgres 131]]>
                </title>
                <pubDate>Sun, 13 Sep 2020 23:49:09 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    6ef84bb1-eaba-461e-8c80-7dbbc82a66df</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-131-slow-archival-index-improvements-node-metrics-join-or-subquery-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss slow WAL archival, index improvements coming for Postgres 13, accessing node metrics via SQL and deciding between a join or subquery.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/131-slow-archival-index-improvements-node-metrics-join-subquery/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss slow WAL archival, index improvements coming for Postgres 13, accessing node metrics via SQL and deciding between a join or subquery.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/131-slow-archival-index-improvements-node-metrics-join-subquery/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Slow Archival, Index Improvements, Node Metrics, Join or Subquery | Scaling Postgres 131]]>
                </itunes:title>
                                    <itunes:episode>131</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss slow WAL archival, index improvements coming for Postgres 13, accessing node metrics via SQL and deciding between a join or subquery.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/131-slow-archival-index-improvements-node-metrics-join-subquery/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551300/sp131.mp3" length="15330324"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss slow WAL archival, index improvements coming for Postgres 13, accessing node metrics via SQL and deciding between a join or subquery.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/131-slow-archival-index-improvements-node-metrics-join-subquery/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551300/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:58</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[External Compression, Parallel Vacuum, JSON Aggregates, JSON & Arrays | Scaling Postgres 130]]>
                </title>
                <pubDate>Sun, 06 Sep 2020 23:46:04 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    ce8364f8-cc03-4633-a402-cce824b7bad6</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-130-external-compression-parallel-vacuum-json-aggregates-json-arrays-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss external compression, vacuuming in parallel, working with JSON Aggregates and the JSON &amp; Array datatypes.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/130-external-compression-parallel-vacuum-json-aggregates-json-arrays/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss external compression, vacuuming in parallel, working with JSON Aggregates and the JSON & Array datatypes.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/130-external-compression-parallel-vacuum-json-aggregates-json-arrays/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[External Compression, Parallel Vacuum, JSON Aggregates, JSON & Arrays | Scaling Postgres 130]]>
                </itunes:title>
                                    <itunes:episode>130</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss external compression, vacuuming in parallel, working with JSON Aggregates and the JSON &amp; Array datatypes.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/130-external-compression-parallel-vacuum-json-aggregates-json-arrays/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551301/sp130.mp3" length="14649469"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss external compression, vacuuming in parallel, working with JSON Aggregates and the JSON & Array datatypes.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/130-external-compression-parallel-vacuum-json-aggregates-json-arrays/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551301/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:15</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[28 Tips, Lucky 13, Autovacuum Tuning, Logical Pitfalls | Scaling Postgres 129]]>
                </title>
                <pubDate>Sun, 30 Aug 2020 23:21:38 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    92abd012-d781-402d-9473-6708d83831c3</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-129-28-tips-lucky-13-autovacuum-tuning-logical-pitfalls-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss 28 tips &amp; tricks, Postgres 13 is lucky, autovacuum tuning and logical replication pitfalls.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/129-28-tips-lucky-13-autovacuum-tuning-logical-pitfalls/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss 28 tips & tricks, Postgres 13 is lucky, autovacuum tuning and logical replication pitfalls.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/129-28-tips-lucky-13-autovacuum-tuning-logical-pitfalls/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[28 Tips, Lucky 13, Autovacuum Tuning, Logical Pitfalls | Scaling Postgres 129]]>
                </itunes:title>
                                    <itunes:episode>129</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss 28 tips &amp; tricks, Postgres 13 is lucky, autovacuum tuning and logical replication pitfalls.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/129-28-tips-lucky-13-autovacuum-tuning-logical-pitfalls/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551302/sp129.mp3" length="15331160"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss 28 tips & tricks, Postgres 13 is lucky, autovacuum tuning and logical replication pitfalls.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/129-28-tips-lucky-13-autovacuum-tuning-logical-pitfalls/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551302/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:58</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Statistics Speed Up, Synchronous Commits, TLS Updates, Avoiding Cursors | Scaling Postgres 128]]>
                </title>
                <pubDate>Mon, 24 Aug 2020 00:09:46 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    6a25d36b-746c-4f11-8e9c-4d79f51151ab</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-128-statistics-speed-up-synchronous-commits-tls-updates-avoiding-cursors-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss speeding up performance with statistics, setting synchronous_commit, updates to TLS settings and how to avoid cursors.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/128-statistics-speed-up-synchronous-commits-tls-updates-avoiding-cursors/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss speeding up performance with statistics, setting synchronous_commit, updates to TLS settings and how to avoid cursors.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/128-statistics-speed-up-synchronous-commits-tls-updates-avoiding-cursors/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Statistics Speed Up, Synchronous Commits, TLS Updates, Avoiding Cursors | Scaling Postgres 128]]>
                </itunes:title>
                                    <itunes:episode>128</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss speeding up performance with statistics, setting synchronous_commit, updates to TLS settings and how to avoid cursors.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/128-statistics-speed-up-synchronous-commits-tls-updates-avoiding-cursors/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551303/sp128.mp3" length="16269897"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss speeding up performance with statistics, setting synchronous_commit, updates to TLS settings and how to avoid cursors.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/128-statistics-speed-up-synchronous-commits-tls-updates-avoiding-cursors/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551303/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:16:56</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Recursive Queries, Lateral Joins, Pagination, JSONB Arrays | Scaling Postgres 127]]>
                </title>
                <pubDate>Mon, 17 Aug 2020 00:21:53 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    1799c3c2-b67b-4b69-814f-1f5b1b71ff02</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-127-recursive-queries-lateral-joins-pagination-jsonb-arrays-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss recursive queries, using lateral joins, paging through a data sets efficiently and working with JSONB arrays.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/127-recursive-queries-lateral-joins-pagination-jsonb-arrays/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss recursive queries, using lateral joins, paging through a data sets efficiently and working with JSONB arrays.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/127-recursive-queries-lateral-joins-pagination-jsonb-arrays/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Recursive Queries, Lateral Joins, Pagination, JSONB Arrays | Scaling Postgres 127]]>
                </itunes:title>
                                    <itunes:episode>127</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss recursive queries, using lateral joins, paging through a data sets efficiently and working with JSONB arrays.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/127-recursive-queries-lateral-joins-pagination-jsonb-arrays/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551304/sp127.mp3" length="14037995"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss recursive queries, using lateral joins, paging through a data sets efficiently and working with JSONB arrays.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/127-recursive-queries-lateral-joins-pagination-jsonb-arrays/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551304/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:37</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[BRIN Pitfalls, pg_stat_statement Troubleshooting, Natural Join, Geography Type | Scaling Postgres 126]]>
                </title>
                <pubDate>Sun, 09 Aug 2020 23:22:23 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    6da3a4d7-187a-4f82-88bd-b751972d9060</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-126-brin-pitfalls-pg-stat-statement-troubleshooting-natural-join-geography-type-1</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss BRIN pitfalls, using pg_stat_statements for troubleshooting, natural joins to detect duplicates and the geography type.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/126-brin-pitfalls-pg_stat_statement-troubleshooting-natural-join-geography-type/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss BRIN pitfalls, using pg_stat_statements for troubleshooting, natural joins to detect duplicates and the geography type.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/126-brin-pitfalls-pg_stat_statement-troubleshooting-natural-join-geography-type/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[BRIN Pitfalls, pg_stat_statement Troubleshooting, Natural Join, Geography Type | Scaling Postgres 126]]>
                </itunes:title>
                                    <itunes:episode>126</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss BRIN pitfalls, using pg_stat_statements for troubleshooting, natural joins to detect duplicates and the geography type.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/126-brin-pitfalls-pg_stat_statement-troubleshooting-natural-join-geography-type/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551305/sp126.mp3" length="13649293"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss BRIN pitfalls, using pg_stat_statements for troubleshooting, natural joins to detect duplicates and the geography type.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/126-brin-pitfalls-pg_stat_statement-troubleshooting-natural-join-geography-type/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551305/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:13</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Scaling Suggestions, Slot Safety, SCRAM Channel Binding, Effective Cache Size | Scaling Postgres 125]]>
                </title>
                <pubDate>Mon, 03 Aug 2020 00:16:29 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    811b1ab7-f70d-4328-a631-f47d21edf00e</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-125-scaling-suggestions-slot-safety-scram-channel-binding-effective-cache-size</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss suggestions for scaling postgres, replication slots safety, implementing scram password authentication with channel binding and setting effective_cache_size.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/125-scaling-suggestions-slot-safety-scram-channel-binding-effective-cache-size/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss suggestions for scaling postgres, replication slots safety, implementing scram password authentication with channel binding and setting effective_cache_size.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/125-scaling-suggestions-slot-safety-scram-channel-binding-effective-cache-size/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Scaling Suggestions, Slot Safety, SCRAM Channel Binding, Effective Cache Size | Scaling Postgres 125]]>
                </itunes:title>
                                    <itunes:episode>125</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss suggestions for scaling postgres, replication slots safety, implementing scram password authentication with channel binding and setting effective_cache_size.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/125-scaling-suggestions-slot-safety-scram-channel-binding-effective-cache-size/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551306/sp125.mp3" length="14410814"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss suggestions for scaling postgres, replication slots safety, implementing scram password authentication with channel binding and setting effective_cache_size.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/125-scaling-suggestions-slot-safety-scram-channel-binding-effective-cache-size/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551306/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:00</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Partition Migration, Like Performance, Best Fillfactor, In-Memory Tables | Scaling Postgres 124]]>
                </title>
                <pubDate>Mon, 27 Jul 2020 00:05:59 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    fec4e580-b19d-4198-9c92-37dce994da6e</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-124-partition-migration-like-performance-best-fillfactor-in-memory-tables</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how best to migrate to using partitions, like &amp; ilike performance, determining the best fillfactor and the work towards in-memory tables.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/124-partition-migration-like-performance-best-fillfactor-in-memory-tables/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how best to migrate to using partitions, like & ilike performance, determining the best fillfactor and the work towards in-memory tables.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/124-partition-migration-like-performance-best-fillfactor-in-memory-tables/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Partition Migration, Like Performance, Best Fillfactor, In-Memory Tables | Scaling Postgres 124]]>
                </itunes:title>
                                    <itunes:episode>124</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how best to migrate to using partitions, like &amp; ilike performance, determining the best fillfactor and the work towards in-memory tables.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/124-partition-migration-like-performance-best-fillfactor-in-memory-tables/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551307/sp124.mp3" length="15309426"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how best to migrate to using partitions, like & ilike performance, determining the best fillfactor and the work towards in-memory tables.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/124-partition-migration-like-performance-best-fillfactor-in-memory-tables/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551307/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:56</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[JSONB Types, Earth Distance, Dates, Times & Intervals, Authentication | Scaling Postgres 123]]>
                </title>
                <pubDate>Sun, 19 Jul 2020 22:36:37 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    f302b323-bd62-41f1-ae51-900232ccc368</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-123-jsonb-types-earth-distance-dates-times-intervals-authentication</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss working with JSONB types, calculating earth distance, utilizing dates, times &amp; intervals and Postgres authentication.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/123-jsonb-types-earth-distance-dates-times-intervals-authentication/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss working with JSONB types, calculating earth distance, utilizing dates, times & intervals and Postgres authentication.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/123-jsonb-types-earth-distance-dates-times-intervals-authentication/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[JSONB Types, Earth Distance, Dates, Times & Intervals, Authentication | Scaling Postgres 123]]>
                </itunes:title>
                                    <itunes:episode>123</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss working with JSONB types, calculating earth distance, utilizing dates, times &amp; intervals and Postgres authentication.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/123-jsonb-types-earth-distance-dates-times-intervals-authentication/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551308/sp123.mp3" length="12932493"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss working with JSONB types, calculating earth distance, utilizing dates, times & intervals and Postgres authentication.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/123-jsonb-types-earth-distance-dates-times-intervals-authentication/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551308/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:13:28</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres is Fine, Generated Columns, Postgres Inserts, Synchronous Replication | Scaling Postgres 122]]>
                </title>
                <pubDate>Mon, 13 Jul 2020 01:23:50 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    016a884d-fad8-44c7-aca9-4809137fba10</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-122-postgres-is-fine-generated-columns-postgres-inserts-synchronous-replication</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss determining if Postgres is fine, generated columns vs. triggers, insert features and synchronous replication usage.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/122-postgres-is-fine-generated-columns-postgres-inserts-synchronous-replication/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss determining if Postgres is fine, generated columns vs. triggers, insert features and synchronous replication usage.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/122-postgres-is-fine-generated-columns-postgres-inserts-synchronous-replication/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres is Fine, Generated Columns, Postgres Inserts, Synchronous Replication | Scaling Postgres 122]]>
                </itunes:title>
                                    <itunes:episode>122</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss determining if Postgres is fine, generated columns vs. triggers, insert features and synchronous replication usage.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/122-postgres-is-fine-generated-columns-postgres-inserts-synchronous-replication/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551309/sp122.mp3" length="9829982"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss determining if Postgres is fine, generated columns vs. triggers, insert features and synchronous replication usage.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/122-postgres-is-fine-generated-columns-postgres-inserts-synchronous-replication/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551309/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:10:14</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Fantastic Data Types, Domain Data Types, Insert Performance, Row Differences | Scaling Postgres 121]]>
                </title>
                <pubDate>Mon, 06 Jul 2020 00:22:47 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    4969c7bb-71b0-48d7-9380-2c3383b03da4</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-121-fantastic-data-types-domain-data-types-insert-performance-row-differences</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss fantastic data types, custom domain data types, improving insert performance and how to query row differences.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/121-fantastic-data-types-domain-data-types-insert-performance-row-differences/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss fantastic data types, custom domain data types, improving insert performance and how to query row differences.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/121-fantastic-data-types-domain-data-types-insert-performance-row-differences/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Fantastic Data Types, Domain Data Types, Insert Performance, Row Differences | Scaling Postgres 121]]>
                </itunes:title>
                                    <itunes:episode>121</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss fantastic data types, custom domain data types, improving insert performance and how to query row differences.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/121-fantastic-data-types-domain-data-types-insert-performance-row-differences/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551310/sp121.mp3" length="15889972"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss fantastic data types, custom domain data types, improving insert performance and how to query row differences.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/121-fantastic-data-types-domain-data-types-insert-performance-row-differences/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551310/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:16:33</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres 13 Beta 2, System Stats Extension, Tuned, Join Strategy | Scaling Postgres 120]]>
                </title>
                <pubDate>Sun, 28 Jun 2020 23:27:54 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    e4b27157-1558-43c5-9793-41357034490c</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-120-postgres-13-beta-2-system-stats-extension-tuned-join-strategy</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss Postgres 13 Beta 2, a system stats extension, tuning your operating systems for Postgres and different join strategies.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/120-postgres13-beta2-system-stats-extension-tuned-join-strategy/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss Postgres 13 Beta 2, a system stats extension, tuning your operating systems for Postgres and different join strategies.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/120-postgres13-beta2-system-stats-extension-tuned-join-strategy/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres 13 Beta 2, System Stats Extension, Tuned, Join Strategy | Scaling Postgres 120]]>
                </itunes:title>
                                    <itunes:episode>120</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss Postgres 13 Beta 2, a system stats extension, tuning your operating systems for Postgres and different join strategies.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/120-postgres13-beta2-system-stats-extension-tuned-join-strategy/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551311/sp120.mp3" length="11712052"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss Postgres 13 Beta 2, a system stats extension, tuning your operating systems for Postgres and different join strategies.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/120-postgres13-beta2-system-stats-extension-tuned-join-strategy/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551311/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:12</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Replication Complications, One Word Performance, Pgbouncer Users, Serializable Isolation | Scaling Postgres 119]]>
                </title>
                <pubDate>Mon, 22 Jun 2020 01:32:05 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    a5020063-1690-4486-895c-e0876e490f48</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-119-replication-complications-one-word-performance-pgbouncer-users-serializable-isolation</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss replication complications, adding one word to boost performance, handling pgbouncer users and serializable isolation testing.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/119-replication-complication-one-word-performance-pgbouncer-users-serializable-isolation/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss replication complications, adding one word to boost performance, handling pgbouncer users and serializable isolation testing.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/119-replication-complication-one-word-performance-pgbouncer-users-serializable-isolation/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Replication Complications, One Word Performance, Pgbouncer Users, Serializable Isolation | Scaling Postgres 119]]>
                </itunes:title>
                                    <itunes:episode>119</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss replication complications, adding one word to boost performance, handling pgbouncer users and serializable isolation testing.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/119-replication-complication-one-word-performance-pgbouncer-users-serializable-isolation/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551312/sp119.mp3" length="14493988"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss replication complications, adding one word to boost performance, handling pgbouncer users and serializable isolation testing.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/119-replication-complication-one-word-performance-pgbouncer-users-serializable-isolation/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551312/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:05</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Safety Systems, Failover Slots, Transaction ID Complications, Repartitioning | Scaling Postgres 118]]>
                </title>
                <pubDate>Sun, 14 Jun 2020 23:39:59 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    716c3600-c9f0-492a-9a7e-a300d587387c</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-118-safety-systems-failover-slots-transaction-id-complications-repartitioning</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss safety systems, the purpose and existence of failover slots, complications with transaction IDs and how to repartition without downtime.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/118-safety-systems-failover-slots-transaction-id-complications-repartitioning/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss safety systems, the purpose and existence of failover slots, complications with transaction IDs and how to repartition without downtime.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/118-safety-systems-failover-slots-transaction-id-complications-repartitioning/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Safety Systems, Failover Slots, Transaction ID Complications, Repartitioning | Scaling Postgres 118]]>
                </itunes:title>
                                    <itunes:episode>118</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss safety systems, the purpose and existence of failover slots, complications with transaction IDs and how to repartition without downtime.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/118-safety-systems-failover-slots-transaction-id-complications-repartitioning/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551313/sp118.mp3" length="15225417"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss safety systems, the purpose and existence of failover slots, complications with transaction IDs and how to repartition without downtime.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/118-safety-systems-failover-slots-transaction-id-complications-repartitioning/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551313/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:51</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Index Deduplication, Fast Hierarchy, More Monitoring, Cloud-Native | Scaling Postgres 117]]>
                </title>
                <pubDate>Mon, 08 Jun 2020 00:12:38 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    54f9dff2-f9f0-4dd3-9e3c-aad7a6357c2a</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-117-index-deduplication-fast-hierarchy-more-monitoring-cloud-native</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss index deduplication in Postgres 13, fast hierarchical access, more essential monitoring and cloud native Postgres.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/117-index-deduplication-fast-hierarchy-more-monitoring-cloud-native/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss index deduplication in Postgres 13, fast hierarchical access, more essential monitoring and cloud native Postgres.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/117-index-deduplication-fast-hierarchy-more-monitoring-cloud-native/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Index Deduplication, Fast Hierarchy, More Monitoring, Cloud-Native | Scaling Postgres 117]]>
                </itunes:title>
                                    <itunes:episode>117</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss index deduplication in Postgres 13, fast hierarchical access, more essential monitoring and cloud native Postgres.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/117-index-deduplication-fast-hierarchy-more-monitoring-cloud-native/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551314/sp117.mp3" length="16885551"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss index deduplication in Postgres 13, fast hierarchical access, more essential monitoring and cloud native Postgres.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/117-index-deduplication-fast-hierarchy-more-monitoring-cloud-native/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551314/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:17:35</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Observer Effect, Partition Management, Tuple Freezing, Hung Transactions | Scaling Postgres 116]]>
                </title>
                <pubDate>Mon, 01 Jun 2020 00:15:30 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    cb5141f2-4933-42e7-9423-e5292c78c6ed</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-116-observer-effect-partition-management-tuple-freezing-hung-transactions</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the observer effect with explain analyze, partition management, tuple freezing and sources of hung transactions.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/116-observer-effect-partition-management-tuple-freezing-hung-transactions/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the observer effect with explain analyze, partition management, tuple freezing and sources of hung transactions.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/116-observer-effect-partition-management-tuple-freezing-hung-transactions/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Observer Effect, Partition Management, Tuple Freezing, Hung Transactions | Scaling Postgres 116]]>
                </itunes:title>
                                    <itunes:episode>116</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the observer effect with explain analyze, partition management, tuple freezing and sources of hung transactions.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/116-observer-effect-partition-management-tuple-freezing-hung-transactions/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551315/sp116.mp3" length="13468316"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the observer effect with explain analyze, partition management, tuple freezing and sources of hung transactions.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/116-observer-effect-partition-management-tuple-freezing-hung-transactions/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551315/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:01</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[PGCon Online, Performance Tips, Tracking Counts, Essential Monitoring | Scaling Postgres 115]]>
                </title>
                <pubDate>Mon, 25 May 2020 04:12:44 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    1dbe7bc9-31e7-46e0-9eb2-a68ee09d2961</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-115-pgcon-online-performance-tips-tracking-counts-essential-monitoring</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss PGCon going online, application performance tips, ways to track counts and essential areas to monitor.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/115-pgcon-online-performance-tips-tracking-counts-essential-monitoring/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss PGCon going online, application performance tips, ways to track counts and essential areas to monitor.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/115-pgcon-online-performance-tips-tracking-counts-essential-monitoring/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[PGCon Online, Performance Tips, Tracking Counts, Essential Monitoring | Scaling Postgres 115]]>
                </itunes:title>
                                    <itunes:episode>115</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss PGCon going online, application performance tips, ways to track counts and essential areas to monitor.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/115-pgcon-online-performance-tips-tracking-counts-essential-monitoring/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551316/sp115.mp3" length="12329377"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss PGCon going online, application performance tips, ways to track counts and essential areas to monitor.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/115-pgcon-online-performance-tips-tracking-counts-essential-monitoring/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551316/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:50</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Data Directory, Vacuum Features, Binary Performance, Network Latency | Scaling Postgres 114]]>
                </title>
                <pubDate>Mon, 18 May 2020 05:17:52 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    6ac8644e-cb01-4913-b2a4-4f842a3661c3</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-114-data-directory-vacuum-features-binary-performance-network-latency</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the Postgres data directory, new vacuum features, binary storage performance and the impact of network latency.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/114-data-directory-vacuum-features-binary-performance-network-latency/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the Postgres data directory, new vacuum features, binary storage performance and the impact of network latency.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/114-data-directory-vacuum-features-binary-performance-network-latency/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Data Directory, Vacuum Features, Binary Performance, Network Latency | Scaling Postgres 114]]>
                </itunes:title>
                                    <itunes:episode>114</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the Postgres data directory, new vacuum features, binary storage performance and the impact of network latency.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/114-data-directory-vacuum-features-binary-performance-network-latency/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551317/sp114.mp3" length="19657874"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the Postgres data directory, new vacuum features, binary storage performance and the impact of network latency.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/114-data-directory-vacuum-features-binary-performance-network-latency/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551317/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:20:28</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[arm64 with apt, Contributors, Backup Manifest, Now Functions | Scaling Postgres 113]]>
                </title>
                <pubDate>Mon, 11 May 2020 00:18:04 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    c02cf5fa-305d-49ce-bbcb-a55564cc2de8</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-113-arm64-with-apt-contributors-backup-manifest-now-functions</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss arm64 package support for apt, annual Postgres contributors, backup manifests &amp; verifications and different now functions.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/113-arm64-with-apt-contributors-backup-manifest-now-functions/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss arm64 package support for apt, annual Postgres contributors, backup manifests & verifications and different now functions.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/113-arm64-with-apt-contributors-backup-manifest-now-functions/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[arm64 with apt, Contributors, Backup Manifest, Now Functions | Scaling Postgres 113]]>
                </itunes:title>
                                    <itunes:episode>113</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss arm64 package support for apt, annual Postgres contributors, backup manifests &amp; verifications and different now functions.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/113-arm64-with-apt-contributors-backup-manifest-now-functions/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551318/sp113.mp3" length="12579735"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss arm64 package support for apt, annual Postgres contributors, backup manifests & verifications and different now functions.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/113-arm64-with-apt-contributors-backup-manifest-now-functions/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551318/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:13:06</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Explain Analyze, Sequence Counts, Best Books, Partition Migration | Scaling Postgres 112]]>
                </title>
                <pubDate>Mon, 04 May 2020 02:51:33 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    236921ed-d019-4899-9587-91406d8d276b</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-112-explain-analyze-sequence-counts-best-books-partition-migration</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to use explain analyze, the problem with counting sequences, the best books to learn Postgres and how to migrate to declarative partitioning.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/112-explain-analyze-sequence-counts-best-books-partition-migration/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to use explain analyze, the problem with counting sequences, the best books to learn Postgres and how to migrate to declarative partitioning.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/112-explain-analyze-sequence-counts-best-books-partition-migration/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Explain Analyze, Sequence Counts, Best Books, Partition Migration | Scaling Postgres 112]]>
                </itunes:title>
                                    <itunes:episode>112</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to use explain analyze, the problem with counting sequences, the best books to learn Postgres and how to migrate to declarative partitioning.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/112-explain-analyze-sequence-counts-best-books-partition-migration/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551321/sp112.mp3" length="16073038"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to use explain analyze, the problem with counting sequences, the best books to learn Postgres and how to migrate to declarative partitioning.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/112-explain-analyze-sequence-counts-best-books-partition-migration/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551321/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:16:44</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Insert-Only Vacuum, Settings, Sequence Replication, Improvements | Scaling Postgres 111]]>
                </title>
                <pubDate>Sun, 26 Apr 2020 23:47:25 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    8dffe6fe-3f25-4400-902b-4850046d676c</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-111-insert-only-vacuum-settings-sequence-replication-improvements</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss insert-only vacuums, the Postgres settings hierarchy, sequence replication and desired improvements.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/111-insert-only-vacuum-settings-sequence-replication-improvements/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss insert-only vacuums, the Postgres settings hierarchy, sequence replication and desired improvements.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/111-insert-only-vacuum-settings-sequence-replication-improvements/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Insert-Only Vacuum, Settings, Sequence Replication, Improvements | Scaling Postgres 111]]>
                </itunes:title>
                                    <itunes:episode>111</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss insert-only vacuums, the Postgres settings hierarchy, sequence replication and desired improvements.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/111-insert-only-vacuum-settings-sequence-replication-improvements/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551319/sp111.mp3" length="16131134"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss insert-only vacuums, the Postgres settings hierarchy, sequence replication and desired improvements.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/111-insert-only-vacuum-settings-sequence-replication-improvements/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551319/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:16:48</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Max Connections, SQL Tricks, Fast Text Search, Security & Compliance | Scaling Postgres 110]]>
                </title>
                <pubDate>Mon, 20 Apr 2020 00:01:28 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    7ee096ed-9f60-448d-9d10-e61cb91c7b66</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-110-max-connections-sql-tricks-fast-text-search-security-compliance</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss tuning max connections, different SQL tricks, setting up fast text search and handling security &amp; compliance.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/110-max-connections-sql-tricks-fast-text-search-security-compliance/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss tuning max connections, different SQL tricks, setting up fast text search and handling security & compliance.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/110-max-connections-sql-tricks-fast-text-search-security-compliance/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Max Connections, SQL Tricks, Fast Text Search, Security & Compliance | Scaling Postgres 110]]>
                </itunes:title>
                                    <itunes:episode>110</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss tuning max connections, different SQL tricks, setting up fast text search and handling security &amp; compliance.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/110-max-connections-sql-tricks-fast-text-search-security-compliance/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551320/sp110.mp3" length="13014413"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss tuning max connections, different SQL tricks, setting up fast text search and handling security & compliance.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/110-max-connections-sql-tricks-fast-text-search-security-compliance/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551320/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:13:33</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Show Plans, WAL Monitoring, Using UUIDs, Default Logging | Scaling Postgres 109]]>
                </title>
                <pubDate>Mon, 13 Apr 2020 00:06:07 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    b17fea8a-99a5-4e22-a26b-b9e75f97f506</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-109-show-plans-wal-monitoring-using-uuids-default-logging</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to show live plans, how Postgres 13 allows WAL monitoring, how to use UUIDs in your app and how logging is setup by default.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/109-show-plans-wal-monitoring-using-uuids-default-logging/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to show live plans, how Postgres 13 allows WAL monitoring, how to use UUIDs in your app and how logging is setup by default.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/109-show-plans-wal-monitoring-using-uuids-default-logging/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Show Plans, WAL Monitoring, Using UUIDs, Default Logging | Scaling Postgres 109]]>
                </itunes:title>
                                    <itunes:episode>109</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to show live plans, how Postgres 13 allows WAL monitoring, how to use UUIDs in your app and how logging is setup by default.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/109-show-plans-wal-monitoring-using-uuids-default-logging/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551322/sp109.mp3" length="12088633"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to show live plans, how Postgres 13 allows WAL monitoring, how to use UUIDs in your app and how logging is setup by default.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/109-show-plans-wal-monitoring-using-uuids-default-logging/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551322/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:35</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Ten Things, Audit Triggers, Schema Design, High Availability | Scaling Postgres 108]]>
                </title>
                <pubDate>Mon, 06 Apr 2020 00:26:34 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    e5a31209-44ca-422e-bbb3-f703f00e69d2</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-108-ten-things-audit-triggers-schema-design-high-availability</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss ten things to hate about Postgres, audit trigger performance, designing a schema and the future of high availability.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/108-ten-things-audit-triggers-schema-design-high-availability/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss ten things to hate about Postgres, audit trigger performance, designing a schema and the future of high availability.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/108-ten-things-audit-triggers-schema-design-high-availability/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Ten Things, Audit Triggers, Schema Design, High Availability | Scaling Postgres 108]]>
                </itunes:title>
                                    <itunes:episode>108</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss ten things to hate about Postgres, audit trigger performance, designing a schema and the future of high availability.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/108-ten-things-audit-triggers-schema-design-high-availability/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551323/sp108.mp3" length="19894439"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss ten things to hate about Postgres, audit trigger performance, designing a schema and the future of high availability.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/108-ten-things-audit-triggers-schema-design-high-availability/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551323/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:20:43</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Showing Plans, Atomic, Configuration, Migrations | Scaling Postgres 107]]>
                </title>
                <pubDate>Mon, 30 Mar 2020 00:28:44 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    9f19ae18-4848-431b-a41a-b421cce0d9ed</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-107-showing-plans-atomic-configuration-migrations</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to show live query plans, the importance of atomic operations for scaling out, configuration options and DBaaS migrations.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/107-showing-plans-atomic-configuration-migrations/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to show live query plans, the importance of atomic operations for scaling out, configuration options and DBaaS migrations.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/107-showing-plans-atomic-configuration-migrations/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Showing Plans, Atomic, Configuration, Migrations | Scaling Postgres 107]]>
                </itunes:title>
                                    <itunes:episode>107</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to show live query plans, the importance of atomic operations for scaling out, configuration options and DBaaS migrations.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/107-showing-plans-atomic-configuration-migrations/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551324/sp107.mp3" length="10379598"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to show live query plans, the importance of atomic operations for scaling out, configuration options and DBaaS migrations.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/107-showing-plans-atomic-configuration-migrations/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551324/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:10:48</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Recursive CTEs, DB Access Patterns, Dates & Times, Cluster | Scaling Postgres 106]]>
                </title>
                <pubDate>Mon, 23 Mar 2020 00:12:02 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    f4bbdb3d-2b3e-4671-86c8-0041ad4363d6</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-106-recursive-ctes-db-access-patterns-dates-times-cluster</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to use recursive CTEs, database access patterns, using dates and times and how to cluster your data.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/106-recursive-cte-db-access-patterns-dates-times-cluster/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to use recursive CTEs, database access patterns, using dates and times and how to cluster your data.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/106-recursive-cte-db-access-patterns-dates-times-cluster/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Recursive CTEs, DB Access Patterns, Dates & Times, Cluster | Scaling Postgres 106]]>
                </itunes:title>
                                    <itunes:episode>106</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to use recursive CTEs, database access patterns, using dates and times and how to cluster your data.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/106-recursive-cte-db-access-patterns-dates-times-cluster/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551325/sp106.mp3" length="14380303"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to use recursive CTEs, database access patterns, using dates and times and how to cluster your data.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/106-recursive-cte-db-access-patterns-dates-times-cluster/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551325/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:58</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[World's Best, Subtransactions, Sharding, Schema Changes | Scaling Postgres 105]]>
                </title>
                <pubDate>Mon, 16 Mar 2020 00:55:39 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    ea38ada5-ffe9-4779-9f96-fed8d910beae</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-105-worlds-best-subtransactions-sharding-schema-changes</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how Postgres is the world's best database, performance ramifications of subtransactions, the current state of sharding and safe schema changes.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/105-worlds-best-subtransactions-sharding-schema-changes/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how Postgres is the world's best database, performance ramifications of subtransactions, the current state of sharding and safe schema changes.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/105-worlds-best-subtransactions-sharding-schema-changes/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[World's Best, Subtransactions, Sharding, Schema Changes | Scaling Postgres 105]]>
                </itunes:title>
                                    <itunes:episode>105</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how Postgres is the world's best database, performance ramifications of subtransactions, the current state of sharding and safe schema changes.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/105-worlds-best-subtransactions-sharding-schema-changes/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551326/sp105.mp3" length="18601691"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how Postgres is the world's best database, performance ramifications of subtransactions, the current state of sharding and safe schema changes.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/105-worlds-best-subtransactions-sharding-schema-changes/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551326/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:19:22</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Reducing WAL, What is Null?, Understanding SQL, TPC-H Benchmarking | Scaling Postgres 104]]>
                </title>
                <pubDate>Mon, 09 Mar 2020 00:21:11 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    dbb1eb35-1972-4bf0-be4c-57e1476080c6</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-104-reducing-wal-what-is-null-understanding-sql-tpc-h-benchmarking</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to reduce the size of your WAL files, what is null, how to better understand SQL and exploring TPC-H benchmarks.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/104-reducing-wal-what-is-null-understanding-sql-tpc-h-benchmarking/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to reduce the size of your WAL files, what is null, how to better understand SQL and exploring TPC-H benchmarks.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/104-reducing-wal-what-is-null-understanding-sql-tpc-h-benchmarking/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Reducing WAL, What is Null?, Understanding SQL, TPC-H Benchmarking | Scaling Postgres 104]]>
                </itunes:title>
                                    <itunes:episode>104</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to reduce the size of your WAL files, what is null, how to better understand SQL and exploring TPC-H benchmarks.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/104-reducing-wal-what-is-null-understanding-sql-tpc-h-benchmarking/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551327/sp104.mp3" length="14735986"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to reduce the size of your WAL files, what is null, how to better understand SQL and exploring TPC-H benchmarks.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/104-reducing-wal-what-is-null-understanding-sql-tpc-h-benchmarking/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551327/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:21</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Scaling Out, Planner Estimation, Create Statistics, Stay Curious | Scaling Postgres 103]]>
                </title>
                <pubDate>Mon, 02 Mar 2020 01:09:05 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    b38706bb-9e2e-48fd-b045-c14d5565885b</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-103-scaling-out-planner-estimation-create-statistics-stay-curious</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to scale out, how the planner estimates, uses of create statistics and investigating PostgreSQL run time environments.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/103-scaling-out-planner-estimation-create-statistics-stay-curious/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to scale out, how the planner estimates, uses of create statistics and investigating PostgreSQL run time environments.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/103-scaling-out-planner-estimation-create-statistics-stay-curious/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Scaling Out, Planner Estimation, Create Statistics, Stay Curious | Scaling Postgres 103]]>
                </itunes:title>
                                    <itunes:episode>103</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss how to scale out, how the planner estimates, uses of create statistics and investigating PostgreSQL run time environments.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/103-scaling-out-planner-estimation-create-statistics-stay-curious/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551328/sp103.mp3" length="13403951"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss how to scale out, how the planner estimates, uses of create statistics and investigating PostgreSQL run time environments.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/103-scaling-out-planner-estimation-create-statistics-stay-curious/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551328/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:13:57</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[UUID Use Cases, pg_settings, Automated Restore, Parallel Future | Scaling Postgres 102]]>
                </title>
                <pubDate>Mon, 24 Feb 2020 01:17:13 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    b0a988cb-48df-4c11-963d-d3214a36c2fc</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-102-uuid-use-cases-pg-settings-automated-restore-parallel-future</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the use cases for UUIDs, using pg_settings, setting up an automated restore and the future of parallelism.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/102-uuid-use-cases-pg-settings-automated-restore-parallel-future/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the use cases for UUIDs, using pg_settings, setting up an automated restore and the future of parallelism.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/102-uuid-use-cases-pg-settings-automated-restore-parallel-future/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[UUID Use Cases, pg_settings, Automated Restore, Parallel Future | Scaling Postgres 102]]>
                </itunes:title>
                                    <itunes:episode>102</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the use cases for UUIDs, using pg_settings, setting up an automated restore and the future of parallelism.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/102-uuid-use-cases-pg-settings-automated-restore-parallel-future/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551329/sp102.mp3" length="12228649"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the use cases for UUIDs, using pg_settings, setting up an automated restore and the future of parallelism.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/102-uuid-use-cases-pg-settings-automated-restore-parallel-future/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551329/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:44</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres Releases, Useless Vacuum, Isolation Differences, WAL Compression | Scaling Postgres 101]]>
                </title>
                <pubDate>Mon, 17 Feb 2020 03:18:48 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    27c2856f-ba3f-466d-bee6-16a4f203fcb5</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-101-postgres-releases-useless-vacuum-isolation-differences-wal-compression</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss new postgres releases, useless vacuuming, isolation differences between databases, and different ways to compress WAL files.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/101-postgres-releases-useless-vacuum-isolation-differences-wal-compression/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss new postgres releases, useless vacuuming, isolation differences between databases, and different ways to compress WAL files.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/101-postgres-releases-useless-vacuum-isolation-differences-wal-compression/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres Releases, Useless Vacuum, Isolation Differences, WAL Compression | Scaling Postgres 101]]>
                </itunes:title>
                                    <itunes:episode>101</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss new postgres releases, useless vacuuming, isolation differences between databases, and different ways to compress WAL files.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/101-postgres-releases-useless-vacuum-isolation-differences-wal-compression/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551330/sp101.mp3" length="17063601"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss new postgres releases, useless vacuuming, isolation differences between databases, and different ways to compress WAL files.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/101-postgres-releases-useless-vacuum-isolation-differences-wal-compression/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551330/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:17:46</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Full Text Search, Query Optimization, Exception Blocks, Procedural Language | Scaling Postgres 100]]>
                </title>
                <pubDate>Mon, 10 Feb 2020 02:02:16 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    9bca7989-5066-4d64-adca-06c53a5109f1</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-100-full-text-search-query-optimization-exception-blocks-procedural-language</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss full text search, a process for query optimization, caution with exception blocks and adding a procedural language.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/100-full-text-search-query-optimization-exception-blocks-procedural-language/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss full text search, a process for query optimization, caution with exception blocks and adding a procedural language.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/100-full-text-search-query-optimization-exception-blocks-procedural-language/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Full Text Search, Query Optimization, Exception Blocks, Procedural Language | Scaling Postgres 100]]>
                </itunes:title>
                                    <itunes:episode>100</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss full text search, a process for query optimization, caution with exception blocks and adding a procedural language.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/100-full-text-search-query-optimization-exception-blocks-procedural-language/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551331/sp100.mp3" length="14607673"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss full text search, a process for query optimization, caution with exception blocks and adding a procedural language.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/100-full-text-search-query-optimization-exception-blocks-procedural-language/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551331/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:12</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Ballad of Bloat, Auditing Options, Configuration Options, Need Vacuum? | Scaling Postgres 99]]>
                </title>
                <pubDate>Mon, 03 Feb 2020 01:54:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    3b72f054-db98-4b2a-ae8e-c6340ca48077</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-99-ballad-of-bloat-auditing-options-configuration-options-need-vacuum</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the "Ballad of Bloat", options for auditing, a configuration help resource and determining when a vacuum is needed.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/99-ballad-of-bloat-auditing-options-configuration-options-need-vacuum/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the "Ballad of Bloat", options for auditing, a configuration help resource and determining when a vacuum is needed.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/99-ballad-of-bloat-auditing-options-configuration-options-need-vacuum/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Ballad of Bloat, Auditing Options, Configuration Options, Need Vacuum? | Scaling Postgres 99]]>
                </itunes:title>
                                    <itunes:episode>99</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the "Ballad of Bloat", options for auditing, a configuration help resource and determining when a vacuum is needed.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/99-ballad-of-bloat-auditing-options-configuration-options-need-vacuum/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551332/sp99.mp3" length="14579252"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the "Ballad of Bloat", options for auditing, a configuration help resource and determining when a vacuum is needed.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/99-ballad-of-bloat-auditing-options-configuration-options-need-vacuum/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551332/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:11</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Non-Relational Data, Contributers, Security Features, High Availability | Scaling Postgres 98]]>
                </title>
                <pubDate>Sun, 26 Jan 2020 22:16:14 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    3f56b031-efeb-4f1a-b61f-ff62f67f6eb3</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-98-non-relational-data-contributers-security-features-high-availability</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss storing non-relational data, recognizing contributors, Postgres security features and implementing high availability.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/98-non-relational-data-contributors-security-features-high-availability/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss storing non-relational data, recognizing contributors, Postgres security features and implementing high availability.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/98-non-relational-data-contributors-security-features-high-availability/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Non-Relational Data, Contributers, Security Features, High Availability | Scaling Postgres 98]]>
                </itunes:title>
                                    <itunes:episode>98</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss storing non-relational data, recognizing contributors, Postgres security features and implementing high availability.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/98-non-relational-data-contributors-security-features-high-availability/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551333/sp98.mp3" length="12491128"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss storing non-relational data, recognizing contributors, Postgres security features and implementing high availability.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/98-non-relational-data-contributors-security-features-high-availability/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551333/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:13:00</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Tips & Tricks, Faster APIs, Full Text Search, pgbouncer_fdw | Scaling Postgres 97]]>
                </title>
                <pubDate>Mon, 20 Jan 2020 02:39:05 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    61d08d3c-99a4-43b6-96e4-990dc0a999d1</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-97-tips-tricks-faster-apis-full-text-search-pgbouncer-fdw</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss tips &amp; tricks, how to get faster APIs, full text search considerations and pgbouncer_fdw.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/97-tips-tricks-faster-apis-full-text-search-pgbouncer-fdw/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss tips & tricks, how to get faster APIs, full text search considerations and pgbouncer_fdw.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/97-tips-tricks-faster-apis-full-text-search-pgbouncer-fdw/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Tips & Tricks, Faster APIs, Full Text Search, pgbouncer_fdw | Scaling Postgres 97]]>
                </itunes:title>
                                    <itunes:episode>97</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss tips &amp; tricks, how to get faster APIs, full text search considerations and pgbouncer_fdw.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/97-tips-tricks-faster-apis-full-text-search-pgbouncer-fdw/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551334/sp97.mp3" length="12660401"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss tips & tricks, how to get faster APIs, full text search considerations and pgbouncer_fdw.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/97-tips-tricks-faster-apis-full-text-search-pgbouncer-fdw/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551334/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:13:11</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Account Configuration, Pricing, System Identifier, HyperLogLog | Scaling Postgres 96]]>
                </title>
                <pubDate>Mon, 13 Jan 2020 02:00:16 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    f814aef1-5304-4e15-b8b0-7e7ceb233eb7</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-96-account-configuration-pricing-system-identifier-hyperloglog</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss user account configuration, pricing, the system identifier and the HyperLogLog extension.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/96-account-configuration-pricing-system-identifier-hyperloglog/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss user account configuration, pricing, the system identifier and the HyperLogLog extension.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/96-account-configuration-pricing-system-identifier-hyperloglog/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Account Configuration, Pricing, System Identifier, HyperLogLog | Scaling Postgres 96]]>
                </itunes:title>
                                    <itunes:episode>96</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss user account configuration, pricing, the system identifier and the HyperLogLog extension.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/96-account-configuration-pricing-system-identifier-hyperloglog/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551335/sp96.mp3" length="11704111"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss user account configuration, pricing, the system identifier and the HyperLogLog extension.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/96-account-configuration-pricing-system-identifier-hyperloglog/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551335/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:11</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[max_locks_per_transaction, Logical Replication, Backup & Recovery, Pgbouncer | Scaling Postgres 95]]>
                </title>
                <pubDate>Mon, 06 Jan 2020 02:17:12 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    c7dcdd13-a524-45b4-a24c-2df9d9f1b9ce</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-95-max-locks-per-transaction-logical-replication-backup-recovery-pgbouncer</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss max_locks_per_transaction, logical replication, managing backup &amp; recovery and pgbouncer connection pooling.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/95-max_locks_per_transaction-logical-replication-backup-recovery-pgbouncer/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss max_locks_per_transaction, logical replication, managing backup & recovery and pgbouncer connection pooling.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/95-max_locks_per_transaction-logical-replication-backup-recovery-pgbouncer/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[max_locks_per_transaction, Logical Replication, Backup & Recovery, Pgbouncer | Scaling Postgres 95]]>
                </itunes:title>
                                    <itunes:episode>95</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss max_locks_per_transaction, logical replication, managing backup &amp; recovery and pgbouncer connection pooling.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/95-max_locks_per_transaction-logical-replication-backup-recovery-pgbouncer/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551336/sp95.mp3" length="11383536"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss max_locks_per_transaction, logical replication, managing backup & recovery and pgbouncer connection pooling.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/95-max_locks_per_transaction-logical-replication-backup-recovery-pgbouncer/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551336/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:11:51</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[State of Postgres, Dumping DBs, Configuration Parameters, Partial WAL | Scaling Postgres 94]]>
                </title>
                <pubDate>Mon, 16 Dec 2019 04:55:58 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    df4cc991-dfba-4e55-8122-a91e57a86722</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-94-state-of-postgres-dumping-dbs-configuration-parameters-partial-wal</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the State of Postgres, how best to dump your database, setting configuration parameters and managing partial WAL files.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/94-state-of-postgres-dumping-dbs-configuration-parameters-partial-wal/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the State of Postgres, how best to dump your database, setting configuration parameters and managing partial WAL files.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/94-state-of-postgres-dumping-dbs-configuration-parameters-partial-wal/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[State of Postgres, Dumping DBs, Configuration Parameters, Partial WAL | Scaling Postgres 94]]>
                </itunes:title>
                                    <itunes:episode>94</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the State of Postgres, how best to dump your database, setting configuration parameters and managing partial WAL files.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/94-state-of-postgres-dumping-dbs-configuration-parameters-partial-wal/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551337/sp94.mp3" length="11991249"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the State of Postgres, how best to dump your database, setting configuration parameters and managing partial WAL files.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/94-state-of-postgres-dumping-dbs-configuration-parameters-partial-wal/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551337/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:29</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Logical Replication, Monitoring Queries, SQL Beautifier, Incomplete Startup Packet | Scaling Postgres 93]]>
                </title>
                <pubDate>Mon, 09 Dec 2019 01:36:01 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    97ace48a-1c5e-404b-9e7f-c0434449d709</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-93-logical-replication-monitoring-queries-sql-beautifier-incomplete-startup-packet</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss logical replication aspects, how to monitor queries, investigating a SQL beautifier and removing incomplete startup packet.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/93-logical-replication-monitoring-queries-sql-beautifier-incomplete-startup-packet/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss logical replication aspects, how to monitor queries, investigating a SQL beautifier and removing incomplete startup packet.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/93-logical-replication-monitoring-queries-sql-beautifier-incomplete-startup-packet/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Logical Replication, Monitoring Queries, SQL Beautifier, Incomplete Startup Packet | Scaling Postgres 93]]>
                </itunes:title>
                                    <itunes:episode>93</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss logical replication aspects, how to monitor queries, investigating a SQL beautifier and removing incomplete startup packet.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/93-logical-replication-monitoring-queries-sql-beautifier-incomplete-startup-packet/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551339/sp93.mp3" length="8715284"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss logical replication aspects, how to monitor queries, investigating a SQL beautifier and removing incomplete startup packet.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/93-logical-replication-monitoring-queries-sql-beautifier-incomplete-startup-packet/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551339/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:09:04</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Book Sales, B-tree Boost, More Postgres 12, Using pgBackRest | Scaling Postgres 92]]>
                </title>
                <pubDate>Mon, 02 Dec 2019 02:41:58 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    2b20199d-bc34-424a-ab06-11e97be39a58</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-92-book-sales-b-tree-boost-more-postgres-12-using-pgbackrest</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss book sales, boosts to b-tree indexes, more Postgres 12 features and how to setup and use pgBackRest.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/92-book-sales-btree-boost-more-postgres-12-using-pgbackrest/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss book sales, boosts to b-tree indexes, more Postgres 12 features and how to setup and use pgBackRest.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/92-book-sales-btree-boost-more-postgres-12-using-pgbackrest/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Book Sales, B-tree Boost, More Postgres 12, Using pgBackRest | Scaling Postgres 92]]>
                </itunes:title>
                                    <itunes:episode>92</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss book sales, boosts to b-tree indexes, more Postgres 12 features and how to setup and use pgBackRest.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/92-book-sales-btree-boost-more-postgres-12-using-pgbackrest/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551338/sp92.mp3" length="12753606"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss book sales, boosts to b-tree indexes, more Postgres 12 features and how to setup and use pgBackRest.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/92-book-sales-btree-boost-more-postgres-12-using-pgbackrest/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551338/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:13:17</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Global Indexes, Caching Aggregates, Vacuum Processing, Effective Cache Size | Scaling Postgres 91]]>
                </title>
                <pubDate>Mon, 25 Nov 2019 01:17:35 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    73023bc6-524d-446f-b3d3-0eaa4888b430</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-91-global-indexes-caching-aggregates-vacuum-processing-effective-cache-size</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss global indexes, ways to cache aggregates, how vacuum processing works and the purpose of effective cache size.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/91-global-indexes-caching-aggregates-vacuum-processing-effective-cache-size/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss global indexes, ways to cache aggregates, how vacuum processing works and the purpose of effective cache size.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/91-global-indexes-caching-aggregates-vacuum-processing-effective-cache-size/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Global Indexes, Caching Aggregates, Vacuum Processing, Effective Cache Size | Scaling Postgres 91]]>
                </itunes:title>
                                    <itunes:episode>91</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss global indexes, ways to cache aggregates, how vacuum processing works and the purpose of effective cache size.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/91-global-indexes-caching-aggregates-vacuum-processing-effective-cache-size/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551340/sp91.mp3" length="12833854"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss global indexes, ways to cache aggregates, how vacuum processing works and the purpose of effective cache size.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/91-global-indexes-caching-aggregates-vacuum-processing-effective-cache-size/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551340/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:13:22</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Chaos Order, Pub Sub, Petabyte Scale, PgBouncer Connections | Scaling Postgres 90]]>
                </title>
                <pubDate>Mon, 18 Nov 2019 01:56:59 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    b68af899-7ebc-4881-8bf1-7b9bc9581e3f</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-90-chaos-order-pub-sub-petabyte-scale-pgbouncer-connections</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss chaos order, pub sub, petabyte scale analytics and PgBouncer connections.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/90-chaos-order-pub-sub-petabyte-scale-pgbouncer-connections/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss chaos order, pub sub, petabyte scale analytics and PgBouncer connections.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/90-chaos-order-pub-sub-petabyte-scale-pgbouncer-connections/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Chaos Order, Pub Sub, Petabyte Scale, PgBouncer Connections | Scaling Postgres 90]]>
                </itunes:title>
                                    <itunes:episode>90</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss chaos order, pub sub, petabyte scale analytics and PgBouncer connections.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/90-chaos-order-pub-sub-petabyte-scale-pgbouncer-connections/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551341/sp90.mp3" length="11542360"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss chaos order, pub sub, petabyte scale analytics and PgBouncer connections.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/90-chaos-order-pub-sub-petabyte-scale-pgbouncer-connections/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551341/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:01</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Performance Impressions, Mystery Solving, GiST Performance, K-Anonymity | Scaling Postgres 89]]>
                </title>
                <pubDate>Mon, 11 Nov 2019 01:50:03 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    60df1844c69a429895124ce264a7844f</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-89-performance-impressions-mystery-solving-gist-performance-k-anonymity</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss Postgres 12 performance impressions, mystery solving, GiST and SP-GiST performance and k-anonymity.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/89-performance-impressions-mystery-solving-gist-performance-k-anonymity/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss Postgres 12 performance impressions, mystery solving, GiST and SP-GiST performance and k-anonymity.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/89-performance-impressions-mystery-solving-gist-performance-k-anonymity/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Performance Impressions, Mystery Solving, GiST Performance, K-Anonymity | Scaling Postgres 89]]>
                </itunes:title>
                                    <itunes:episode>89</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss Postgres 12 performance impressions, mystery solving, GiST and SP-GiST performance and k-anonymity.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/89-performance-impressions-mystery-solving-gist-performance-k-anonymity/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551342/sp89.mp3" length="15072444"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss Postgres 12 performance impressions, mystery solving, GiST and SP-GiST performance and k-anonymity.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/89-performance-impressions-mystery-solving-gist-performance-k-anonymity/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551342/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:42</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Partitioning, Logical Replication Upgrade, Columnar Compression, HAProxy Connections | Scaling Postgres 88]]>
                </title>
                <pubDate>Mon, 04 Nov 2019 00:45:05 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    341c05e8e8634756a39722d751df0a73</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-88-partitioning-logical-replication-upgrade-columnar-compression-haproxy-connections</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss partitioning, logical replication upgrades, columnar compression and HAProxy connections.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/88-partitioning-logical-replication-upgrade-columnar-compression-haproxy-connections/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss partitioning, logical replication upgrades, columnar compression and HAProxy connections.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/88-partitioning-logical-replication-upgrade-columnar-compression-haproxy-connections/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Partitioning, Logical Replication Upgrade, Columnar Compression, HAProxy Connections | Scaling Postgres 88]]>
                </itunes:title>
                                    <itunes:episode>88</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss partitioning, logical replication upgrades, columnar compression and HAProxy connections.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/88-partitioning-logical-replication-upgrade-columnar-compression-haproxy-connections/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551343/sp88.mp3" length="13992437"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss partitioning, logical replication upgrades, columnar compression and HAProxy connections.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/88-partitioning-logical-replication-upgrade-columnar-compression-haproxy-connections/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551343/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:34</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[pg_receivewal, Application Failover, pg_checksums, pgBouncer | Scaling Postgres 87]]>
                </title>
                <pubDate>Mon, 28 Oct 2019 00:17:07 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    570b3eed6d454bc1a5ab5058f4c7d6c0</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-87-pg-receivewal-application-failover-pg-checksums-pgbouncer</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the benefits of pg_receivewal, how to setup simple application failover, new pg_checksums and setting up pgBouncer.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/87-pg_receivewal-application-failover-pg_checksums-pgbouncer/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the benefits of pg_receivewal, how to setup simple application failover, new pg_checksums and setting up pgBouncer.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/87-pg_receivewal-application-failover-pg_checksums-pgbouncer/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[pg_receivewal, Application Failover, pg_checksums, pgBouncer | Scaling Postgres 87]]>
                </itunes:title>
                                    <itunes:episode>87</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the benefits of pg_receivewal, how to setup simple application failover, new pg_checksums and setting up pgBouncer.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/87-pg_receivewal-application-failover-pg_checksums-pgbouncer/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551344/sp87.mp3" length="12152581"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the benefits of pg_receivewal, how to setup simple application failover, new pg_checksums and setting up pgBouncer.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/87-pg_receivewal-application-failover-pg_checksums-pgbouncer/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551344/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:39</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Prewarming, Nondeterministic Collations, Generated Column Performance, Foreign Keys | Scaling Postgres 86]]>
                </title>
                <pubDate>Sun, 20 Oct 2019 23:40:58 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    5781758910ee460eafbfaa9a66f0ca8d</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-86-prewarming-nondeterministic-collations-generated-column-performance-foreign-keys</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss prewarming your cache, working with nondeterministic collations, generated column performance and foreign keys with partitions.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/86-prewarming-nondeterministic-collations-generated-column-performance-foreign-keys/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss prewarming your cache, working with nondeterministic collations, generated column performance and foreign keys with partitions.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/86-prewarming-nondeterministic-collations-generated-column-performance-foreign-keys/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Prewarming, Nondeterministic Collations, Generated Column Performance, Foreign Keys | Scaling Postgres 86]]>
                </itunes:title>
                                    <itunes:episode>86</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss prewarming your cache, working with nondeterministic collations, generated column performance and foreign keys with partitions.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/86-prewarming-nondeterministic-collations-generated-column-performance-foreign-keys/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551345/sp86.mp3" length="14952071"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss prewarming your cache, working with nondeterministic collations, generated column performance and foreign keys with partitions.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/86-prewarming-nondeterministic-collations-generated-column-performance-foreign-keys/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551345/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:34</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Recovery Configuration, Alter System, Transaction Isolation, Temp Table Vacuum | Scaling Postgres 85]]>
                </title>
                <pubDate>Mon, 14 Oct 2019 00:34:53 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    15b849cff0b945a98ce776403cd507d1</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-85-recovery-configuration-alter-system-transaction-isolation-temp-table-vacuum</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss changes to recovery configuration, the alter system command, transaction isolation and vacuum for temp tables.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/85-recovery-configuration-alter-system-transaction-isolation-temp-table-vacuum/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss changes to recovery configuration, the alter system command, transaction isolation and vacuum for temp tables.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/85-recovery-configuration-alter-system-transaction-isolation-temp-table-vacuum/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Recovery Configuration, Alter System, Transaction Isolation, Temp Table Vacuum | Scaling Postgres 85]]>
                </itunes:title>
                                    <itunes:episode>85</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss changes to recovery configuration, the alter system command, transaction isolation and vacuum for temp tables.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/85-recovery-configuration-alter-system-transaction-isolation-temp-table-vacuum/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551346/sp85.mp3" length="14412904"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss changes to recovery configuration, the alter system command, transaction isolation and vacuum for temp tables.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/85-recovery-configuration-alter-system-transaction-isolation-temp-table-vacuum/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551346/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:00</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres 12 Released, Generated Columns, Parallel Estimates, Change Data Capture | Scaling Postgres 84]]>
                </title>
                <pubDate>Mon, 07 Oct 2019 00:11:09 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    894390d4ea034bac920b40f24efc6748</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-84-postgres-12-released-generated-columns-parallel-estimates-change-data-capture</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the release features of Postgres 12, generated columns, parallel estimates and change data capture.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/84-postgres-12-released-generated-columns-parallel-estimates-change-data-capture/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the release features of Postgres 12, generated columns, parallel estimates and change data capture.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/84-postgres-12-released-generated-columns-parallel-estimates-change-data-capture/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres 12 Released, Generated Columns, Parallel Estimates, Change Data Capture | Scaling Postgres 84]]>
                </itunes:title>
                                    <itunes:episode>84</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the release features of Postgres 12, generated columns, parallel estimates and change data capture.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/84-postgres-12-released-generated-columns-parallel-estimates-change-data-capture/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551347/sp84.mp3" length="12118308"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the release features of Postgres 12, generated columns, parallel estimates and change data capture.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/84-postgres-12-released-generated-columns-parallel-estimates-change-data-capture/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551347/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:37</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres 12, Window Frames, Index Types, Synchronous Replication | Scaling Postgres 83]]>
                </title>
                <pubDate>Mon, 30 Sep 2019 00:38:16 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    93a25da11ed34c398779c4f2a86640bb</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-83-postgres-12-window-frames-index-types-synchronous-replication</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the release of Postgres 12, how to use window frames, the different index types, and when to use synchronous replication.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/83-postgres-12-window-frames-index-types-synchronous-replication/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the release of Postgres 12, how to use window frames, the different index types, and when to use synchronous replication.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/83-postgres-12-window-frames-index-types-synchronous-replication/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres 12, Window Frames, Index Types, Synchronous Replication | Scaling Postgres 83]]>
                </itunes:title>
                                    <itunes:episode>83</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the release of Postgres 12, how to use window frames, the different index types, and when to use synchronous replication.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/83-postgres-12-window-frames-index-types-synchronous-replication/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551348/sp83.mp3" length="12718497"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the release of Postgres 12, how to use window frames, the different index types, and when to use synchronous replication.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/83-postgres-12-window-frames-index-types-synchronous-replication/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551348/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:13:14</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Faster Partitions, Count Speed, Extensions, Education | Scaling Postgres 82]]>
                </title>
                <pubDate>Mon, 23 Sep 2019 00:19:37 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    c323d66f700e42e19bc66ebd1760af15</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-82-faster-partitions-count-speed-extensions-education</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss faster partition performance, count speed, extensions and Postgres education.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/82-faster-partitions-count-speed-extensions-education/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss faster partition performance, count speed, extensions and Postgres education.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/82-faster-partitions-count-speed-extensions-education/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Faster Partitions, Count Speed, Extensions, Education | Scaling Postgres 82]]>
                </itunes:title>
                                    <itunes:episode>82</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss faster partition performance, count speed, extensions and Postgres education.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/82-faster-partitions-count-speed-extensions-education/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551349/sp82.mp3" length="12418403"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss faster partition performance, count speed, extensions and Postgres education.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/82-faster-partitions-count-speed-extensions-education/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551349/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:56</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Data Loading Speed, View Dependencies, Users & Roles, H/A Clusters | Scaling Postgres 81]]>
                </title>
                <pubDate>Mon, 16 Sep 2019 00:42:02 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    31123c1923a24d50b30d22afed666c12</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-81-data-loading-speed-view-dependencies-users-roles-ha-clusters</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss data loading speeds, view dependencies, users &amp; roles and high availability clusters.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/81-data-loading-speed-view-dependencies-users-roles-high-availability-clusters/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss data loading speeds, view dependencies, users & roles and high availability clusters.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/81-data-loading-speed-view-dependencies-users-roles-high-availability-clusters/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Data Loading Speed, View Dependencies, Users & Roles, H/A Clusters | Scaling Postgres 81]]>
                </itunes:title>
                                    <itunes:episode>81</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss data loading speeds, view dependencies, users &amp; roles and high availability clusters.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/81-data-loading-speed-view-dependencies-users-roles-high-availability-clusters/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551350/sp81.mp3" length="12239516"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss data loading speeds, view dependencies, users & roles and high availability clusters.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/81-data-loading-speed-view-dependencies-users-roles-high-availability-clusters/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551350/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:44</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Just Upgrade, Vacuum Updates, Connection Strings, Postgres Showcase | Scaling Postgres 80]]>
                </title>
                <pubDate>Mon, 09 Sep 2019 01:53:42 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    6518ff82eaf341b2b3099cceefeef1b7</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-80-just-upgrade-vacuum-updates-connection-strings-postgres-showcase</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss why you should just upgrade, vacuum updates in Postgres 12, psql connection strings and a Postgres showcase.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/80-just-upgrade-vacuum-updates-connection-strings-postgres-showcase/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss why you should just upgrade, vacuum updates in Postgres 12, psql connection strings and a Postgres showcase.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/80-just-upgrade-vacuum-updates-connection-strings-postgres-showcase/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Just Upgrade, Vacuum Updates, Connection Strings, Postgres Showcase | Scaling Postgres 80]]>
                </itunes:title>
                                    <itunes:episode>80</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss why you should just upgrade, vacuum updates in Postgres 12, psql connection strings and a Postgres showcase.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/80-just-upgrade-vacuum-updates-connection-strings-postgres-showcase/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551351/sp80.mp3" length="13245126"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss why you should just upgrade, vacuum updates in Postgres 12, psql connection strings and a Postgres showcase.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/80-just-upgrade-vacuum-updates-connection-strings-postgres-showcase/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551351/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:13:47</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[PgBouncer SCRAM, Art of PostgreSQL, Distributed Time-Series, Window Functions | Scaling Postgres 79]]>
                </title>
                <pubDate>Mon, 02 Sep 2019 14:08:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    2c09df4e235246ab88003e17c173f1d8</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-79-pgbouncer-scram-art-of-postgresql-distributed-time-series-window-functions</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss PgBouncer SCRAM support, The Art of PostgreSQL, making Postgres a distributed time-series DB and window functions.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/79-pgbouncer-scram-art-of-postgresql-distributed-time-series-window-functions/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss PgBouncer SCRAM support, The Art of PostgreSQL, making Postgres a distributed time-series DB and window functions.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/79-pgbouncer-scram-art-of-postgresql-distributed-time-series-window-functions/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[PgBouncer SCRAM, Art of PostgreSQL, Distributed Time-Series, Window Functions | Scaling Postgres 79]]>
                </itunes:title>
                                    <itunes:episode>79</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss PgBouncer SCRAM support, The Art of PostgreSQL, making Postgres a distributed time-series DB and window functions.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/79-pgbouncer-scram-art-of-postgresql-distributed-time-series-window-functions/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551352/sp79.mp3" length="9705012"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss PgBouncer SCRAM support, The Art of PostgreSQL, making Postgres a distributed time-series DB and window functions.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/79-pgbouncer-scram-art-of-postgresql-distributed-time-series-window-functions/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551352/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:10:06</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Efficient Pagination, Rotating Passwords, BRIN, Row Level Security | Scaling Postgres 78]]>
                </title>
                <pubDate>Sun, 25 Aug 2019 23:43:27 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    4ef1d6b01d414bddae2d3fd49502890f</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-78-efficient-pagination-rotating-passwords-brin-row-level-security</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss efficient pagination, how to rotate passwords, BRIN benefits and Row Level Security.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/78-efficient-pagination-rotating-passwords-brin-row-level-security/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss efficient pagination, how to rotate passwords, BRIN benefits and Row Level Security.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/78-efficient-pagination-rotating-passwords-brin-row-level-security/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Efficient Pagination, Rotating Passwords, BRIN, Row Level Security | Scaling Postgres 78]]>
                </itunes:title>
                                    <itunes:episode>78</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss efficient pagination, how to rotate passwords, BRIN benefits and Row Level Security.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/78-efficient-pagination-rotating-passwords-brin-row-level-security/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551353/sp78.mp3" length="16903523"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss efficient pagination, how to rotate passwords, BRIN benefits and Row Level Security.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/78-efficient-pagination-rotating-passwords-brin-row-level-security/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551353/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:17:36</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Timeseries Queries, Arrays, Ranges, C Triggers | Scaling Postgres 77]]>
                </title>
                <pubDate>Mon, 19 Aug 2019 00:20:02 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    445c0e35700f43faadcf5faae497cf59</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-77-timeseries-queries-arrays-ranges-c-triggers</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss timeseries queries, using arrays with queries, range use cases and developing triggers in C.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/77-timeseries-queries-arrays-ranges-c-triggers/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss timeseries queries, using arrays with queries, range use cases and developing triggers in C.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/77-timeseries-queries-arrays-ranges-c-triggers/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Timeseries Queries, Arrays, Ranges, C Triggers | Scaling Postgres 77]]>
                </itunes:title>
                                    <itunes:episode>77</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss timeseries queries, using arrays with queries, range use cases and developing triggers in C.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/77-timeseries-queries-arrays-ranges-c-triggers/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551354/sp77.mp3" length="11758445"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss timeseries queries, using arrays with queries, range use cases and developing triggers in C.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/77-timeseries-queries-arrays-ranges-c-triggers/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551354/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:14</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[New CVEs, Postgres Programming, JSONB, Advisory Locks | Scaling Postgres 76]]>
                </title>
                <pubDate>Mon, 12 Aug 2019 02:09:04 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    5a50617ffa8b4013b2fb902659d14f24</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-76-new-cves-postgres-programming-jsonb-advisory-locks</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss new CVEs, programming Postgres, JSONB comparison and using advisory locks.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/76-new-cves-postgres-programming-jsonb-advisory-locks/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss new CVEs, programming Postgres, JSONB comparison and using advisory locks.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/76-new-cves-postgres-programming-jsonb-advisory-locks/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[New CVEs, Postgres Programming, JSONB, Advisory Locks | Scaling Postgres 76]]>
                </itunes:title>
                                    <itunes:episode>76</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss new CVEs, programming Postgres, JSONB comparison and using advisory locks.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/76-new-cves-postgres-programming-jsonb-advisory-locks/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551355/sp76.mp3" length="12384130"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss new CVEs, programming Postgres, JSONB comparison and using advisory locks.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/76-new-cves-postgres-programming-jsonb-advisory-locks/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551355/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:54</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Combining Indexes, Regular Expressions, Parallelism, PostGIS | Scaling Postgres 75]]>
                </title>
                <pubDate>Mon, 05 Aug 2019 01:02:06 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    4d21d0da464246c3bfb752978f2a6dba</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-75-combining-indexes-regular-expressions-parallelism-postgis</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss combining indexes, regular expressions, parallelism in Postgres and PostGIS content.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/75-combining-indexes-regular-expressions-parallelism-postgis/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss combining indexes, regular expressions, parallelism in Postgres and PostGIS content.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/75-combining-indexes-regular-expressions-parallelism-postgis/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Combining Indexes, Regular Expressions, Parallelism, PostGIS | Scaling Postgres 75]]>
                </itunes:title>
                                    <itunes:episode>75</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss combining indexes, regular expressions, parallelism in Postgres and PostGIS content.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/75-combining-indexes-regular-expressions-parallelism-postgis/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551357/sp75.mp3" length="15051128"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss combining indexes, regular expressions, parallelism in Postgres and PostGIS content.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/75-combining-indexes-regular-expressions-parallelism-postgis/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551357/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:40</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Picturing Vacuum, Recovery Changes, Cert Authentication, Function Replication | Scaling Postgres 74]]>
                </title>
                <pubDate>Mon, 29 Jul 2019 00:35:43 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    d81d1f430cc84f2a9615db0881e6643f</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-74-picturing-vacuum-recovery-changes-cert-authentication-function-replication</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss vacuum through pictures, upcoming recovery changes, certification authentication and how functions get replicated.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/74-picturing-vacuum-recovery-changes-certificate-authentication-function-replication/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss vacuum through pictures, upcoming recovery changes, certification authentication and how functions get replicated.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/74-picturing-vacuum-recovery-changes-certificate-authentication-function-replication/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Picturing Vacuum, Recovery Changes, Cert Authentication, Function Replication | Scaling Postgres 74]]>
                </itunes:title>
                                    <itunes:episode>74</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss vacuum through pictures, upcoming recovery changes, certification authentication and how functions get replicated.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/74-picturing-vacuum-recovery-changes-certificate-authentication-function-replication/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551356/sp74.mp3" length="10736117"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss vacuum through pictures, upcoming recovery changes, certification authentication and how functions get replicated.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/74-picturing-vacuum-recovery-changes-certificate-authentication-function-replication/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551356/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:11:11</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[BRIN Indexes, Partition Enhancements, Tips, Standbys | Scaling Postgres 73]]>
                </title>
                <pubDate>Mon, 22 Jul 2019 00:21:48 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    52ffa46a9339499389bd2ac9109ea9a9</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-73-brin-indexes-partition-enhancements-tips-standbys</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss BRIN indexes, partition enhancements, general tips and standby scaling.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/73-brin-indexes-partition-enhancements-tips-standbys/https://www.scalingpostgres.com/episodes/73-brin-indexes-partition-enhancements-tips-standbys/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss BRIN indexes, partition enhancements, general tips and standby scaling.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/73-brin-indexes-partition-enhancements-tips-standbys/https://www.scalingpostgres.com/episodes/73-brin-indexes-partition-enhancements-tips-standbys/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[BRIN Indexes, Partition Enhancements, Tips, Standbys | Scaling Postgres 73]]>
                </itunes:title>
                                    <itunes:episode>73</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss BRIN indexes, partition enhancements, general tips and standby scaling.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/73-brin-indexes-partition-enhancements-tips-standbys/https://www.scalingpostgres.com/episodes/73-brin-indexes-partition-enhancements-tips-standbys/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551358/sp73.mp3" length="13657652"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss BRIN indexes, partition enhancements, general tips and standby scaling.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/73-brin-indexes-partition-enhancements-tips-standbys/https://www.scalingpostgres.com/episodes/73-brin-indexes-partition-enhancements-tips-standbys/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551358/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:13</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Collation Issues, Fast Loading, Recovery, SCRAM Authentication | Scaling Postgres 72]]>
                </title>
                <pubDate>Mon, 15 Jul 2019 01:02:53 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    511c2664fa28441dbe67efeadaea8b46</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-72-collation-issues-fast-loading-recovery-scram-authentication</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss collation issues, how to load data quickly, recovery changes in Postgres 12 and moving to SCRAM authentication.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/72-collation-issues-fast-loading-recovery-scram-authentication/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss collation issues, how to load data quickly, recovery changes in Postgres 12 and moving to SCRAM authentication.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/72-collation-issues-fast-loading-recovery-scram-authentication/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Collation Issues, Fast Loading, Recovery, SCRAM Authentication | Scaling Postgres 72]]>
                </itunes:title>
                                    <itunes:episode>72</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss collation issues, how to load data quickly, recovery changes in Postgres 12 and moving to SCRAM authentication.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/72-collation-issues-fast-loading-recovery-scram-authentication/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551359/sp72.mp3" length="16485982"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss collation issues, how to load data quickly, recovery changes in Postgres 12 and moving to SCRAM authentication.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/72-collation-issues-fast-loading-recovery-scram-authentication/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551359/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:17:10</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Indexing Documents, GIN Indexes, Data Science, Generated Columns | Scaling Postgres 71]]>
                </title>
                <pubDate>Mon, 08 Jul 2019 00:23:31 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    8dc3a452b7034ddb9cf64c28be368760</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-71-indexing-documents-gin-indexes-data-science-generated-columns</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss indexing documents, how GIN indexes work, using Postgres for Data Science and generated columns.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/71-indexing-documents-gin-indexes-data-science-generated-columns/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss indexing documents, how GIN indexes work, using Postgres for Data Science and generated columns.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/71-indexing-documents-gin-indexes-data-science-generated-columns/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Indexing Documents, GIN Indexes, Data Science, Generated Columns | Scaling Postgres 71]]>
                </itunes:title>
                                    <itunes:episode>71</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss indexing documents, how GIN indexes work, using Postgres for Data Science and generated columns.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/71-indexing-documents-gin-indexes-data-science-generated-columns/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551361/sp71.mp3" length="12845557"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss indexing documents, how GIN indexes work, using Postgres for Data Science and generated columns.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/71-indexing-documents-gin-indexes-data-science-generated-columns/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551361/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:13:22</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Default Security, Max Connections, Progress Reporting, Migration | Scaling Postgres 70]]>
                </title>
                <pubDate>Mon, 01 Jul 2019 00:26:17 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    e8e403cfa7044154ae38889d0fb2fe0f</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-70-default-security-max-connections-progress-reporting-migration</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss the default security, max_connections and pooling, progress reporting and migrating to Postgres.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/70-default-security-max-connections-progress-reporting-migration/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the default security, max_connections and pooling, progress reporting and migrating to Postgres.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/70-default-security-max-connections-progress-reporting-migration/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Default Security, Max Connections, Progress Reporting, Migration | Scaling Postgres 70]]>
                </itunes:title>
                                    <itunes:episode>70</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss the default security, max_connections and pooling, progress reporting and migrating to Postgres.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/70-default-security-max-connections-progress-reporting-migration/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551360/sp70.mp3" length="12446406"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss the default security, max_connections and pooling, progress reporting and migrating to Postgres.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/70-default-security-max-connections-progress-reporting-migration/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551360/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:57</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Performance Training, JSON Path, Hypothetical Indexes, Interpolation | Scaling Postgres 69]]>
                </title>
                <pubDate>Mon, 24 Jun 2019 00:25:19 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    14c97f81a66641628d482478f79da94c</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-69-performance-training-json-path-hypothetical-indexes-interpolation</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss performance training, SQL/JSON path support, hypothetical indexes and linear interpolation of data.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/69-performance-training-json-path-hypothetical-indexes-interpolation/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss performance training, SQL/JSON path support, hypothetical indexes and linear interpolation of data.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/69-performance-training-json-path-hypothetical-indexes-interpolation/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Performance Training, JSON Path, Hypothetical Indexes, Interpolation | Scaling Postgres 69]]>
                </itunes:title>
                                    <itunes:episode>69</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss performance training, SQL/JSON path support, hypothetical indexes and linear interpolation of data.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/69-performance-training-json-path-hypothetical-indexes-interpolation/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551362/sp69.mp3" length="14608927"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss performance training, SQL/JSON path support, hypothetical indexes and linear interpolation of data.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/69-performance-training-json-path-hypothetical-indexes-interpolation/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551362/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:13</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Prepared Plans, Materialization, Recursive CTEs, Safe Migrations | Scaling Postgres 68]]>
                </title>
                <pubDate>Sun, 16 Jun 2019 23:54:25 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    0769134d42ae42e28bdae7e0bf826111</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-68-prepared-plans-materialization-recursive-ctes-safe-migrations</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss prepared plans, materialization, recursive CTEs and how to run safe database migrations.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/68-prepared-plans-materialization-recursive-cte-safe-migrations/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss prepared plans, materialization, recursive CTEs and how to run safe database migrations.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/68-prepared-plans-materialization-recursive-cte-safe-migrations/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Prepared Plans, Materialization, Recursive CTEs, Safe Migrations | Scaling Postgres 68]]>
                </itunes:title>
                                    <itunes:episode>68</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss prepared plans, materialization, recursive CTEs and how to run safe database migrations.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/68-prepared-plans-materialization-recursive-cte-safe-migrations/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551363/sp68.mp3" length="15399706"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss prepared plans, materialization, recursive CTEs and how to run safe database migrations.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/68-prepared-plans-materialization-recursive-cte-safe-migrations/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551363/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:16:02</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[PGCon, Tips, PostGIS, Strings | Scaling Postgres 67]]>
                </title>
                <pubDate>Sun, 09 Jun 2019 22:00:59 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    63b858f7bc14420bbb28f2b18d6f8347</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-67-pgcon-tips-postgis-strings</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss videos from PGCon, Postgres tips &amp; tricks, PostGIS parallel performance and using strings.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/67-pgcon-tips-postgis-strings/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss videos from PGCon, Postgres tips & tricks, PostGIS parallel performance and using strings.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/67-pgcon-tips-postgis-strings/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[PGCon, Tips, PostGIS, Strings | Scaling Postgres 67]]>
                </itunes:title>
                                    <itunes:episode>67</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss videos from PGCon, Postgres tips &amp; tricks, PostGIS parallel performance and using strings.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/67-pgcon-tips-postgis-strings/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551364/sp67.mp3" length="9430413"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss videos from PGCon, Postgres tips & tricks, PostGIS parallel performance and using strings.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/67-pgcon-tips-postgis-strings/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551364/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:09:49</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Query Optimization, Normalization, Visualizing Vacuum, Sharding | Scaling Postgres 66]]>
                </title>
                <pubDate>Mon, 03 Jun 2019 02:12:29 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    040d181987bd4dcf8c16e75ce4c3b6fc</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-66-query-optimization-normalization-visualizing-vacuum-sharding</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss different query optimizations, normalizing to save space, visualizing vacuum and shardings future.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/66-query-optimization-normalization-visualizing-vacuum-sharding/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss different query optimizations, normalizing to save space, visualizing vacuum and shardings future.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/66-query-optimization-normalization-visualizing-vacuum-sharding/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Query Optimization, Normalization, Visualizing Vacuum, Sharding | Scaling Postgres 66]]>
                </itunes:title>
                                    <itunes:episode>66</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss different query optimizations, normalizing to save space, visualizing vacuum and shardings future.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/66-query-optimization-normalization-visualizing-vacuum-sharding/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551365/sp66.mp3" length="16478876"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss different query optimizations, normalizing to save space, visualizing vacuum and shardings future.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/66-query-optimization-normalization-visualizing-vacuum-sharding/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551365/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:17:09</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Multi Column, Multi DB, Dos & Don'ts, RUM Indexes | Scaling Postgres 65]]>
                </title>
                <pubDate>Sun, 26 May 2019 23:43:55 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    828091de6a5f421fadbd94522e79d5a2</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-65-multi-column-multi-db-dos-donts-rum-indexes</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss multi-column indexes, using multiple databases, Postgres dos &amp; don'ts as well as using RUM indexes.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/65-multi-column-multi-db-dos-and-donts-rum-indexes/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss multi-column indexes, using multiple databases, Postgres dos & don'ts as well as using RUM indexes.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/65-multi-column-multi-db-dos-and-donts-rum-indexes/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Multi Column, Multi DB, Dos & Don'ts, RUM Indexes | Scaling Postgres 65]]>
                </itunes:title>
                                    <itunes:episode>65</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss multi-column indexes, using multiple databases, Postgres dos &amp; don'ts as well as using RUM indexes.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/65-multi-column-multi-db-dos-and-donts-rum-indexes/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551366/sp65.mp3" length="13580747"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss multi-column indexes, using multiple databases, Postgres dos & don'ts as well as using RUM indexes.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/65-multi-column-multi-db-dos-and-donts-rum-indexes/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551366/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:08</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Leveraging Indexes, Slugs, Addresses, Security Definer | Scaling Postgres 64]]>
                </title>
                <pubDate>Mon, 20 May 2019 00:05:23 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    a827e95e11da423381c4a527b04aebd5</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-64-leveraging-indexes-slugs-addresses-security-definer</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we discuss leveraging indexes, a slug function, addresses and security definer in functions.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/64-leveraging-indexes-slugs-addresses-security-definer/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we discuss leveraging indexes, a slug function, addresses and security definer in functions.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/64-leveraging-indexes-slugs-addresses-security-definer/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Leveraging Indexes, Slugs, Addresses, Security Definer | Scaling Postgres 64]]>
                </itunes:title>
                                    <itunes:episode>64</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we discuss leveraging indexes, a slug function, addresses and security definer in functions.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/64-leveraging-indexes-slugs-addresses-security-definer/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551367/sp64.mp3" length="12680881"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we discuss leveraging indexes, a slug function, addresses and security definer in functions.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/64-leveraging-indexes-slugs-addresses-security-definer/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551367/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:13:12</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Slow Queries, pg_auto_failover, Roles, Hyperscale | Scaling Postgres 63]]>
                </title>
                <pubDate>Sun, 12 May 2019 22:44:16 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    3829dfb157b24ab9a3d7a8defd633618</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-63-slow-queries-pg-auto-failover-roles-hyperscale</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering how to identify slow queries, the pg_auto_failover utility, working with roles and Hyperscale.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/63-slow-queries-pg_auto_failover-roles-hyperscale/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering how to identify slow queries, the pg_auto_failover utility, working with roles and Hyperscale.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/63-slow-queries-pg_auto_failover-roles-hyperscale/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Slow Queries, pg_auto_failover, Roles, Hyperscale | Scaling Postgres 63]]>
                </itunes:title>
                                    <itunes:episode>63</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering how to identify slow queries, the pg_auto_failover utility, working with roles and Hyperscale.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/63-slow-queries-pg_auto_failover-roles-hyperscale/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551368/sp63.mp3" length="11632640"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering how to identify slow queries, the pg_auto_failover utility, working with roles and Hyperscale.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/63-slow-queries-pg_auto_failover-roles-hyperscale/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551368/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:07</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Index Include Clause, Exporting CSV, JSON, Zedstore | Scaling Postgres 62]]>
                </title>
                <pubDate>Sun, 05 May 2019 22:24:55 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    97be6ab5c57448faab6067b1b422d2f4</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-62-index-include-clause-exporting-csv-json-zedstore</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering the index include clause, exporting data to CSV, using JSON in Postgres and Zedstore.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/62-index-include-clause-exporting-csv-json-zedstore/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering the index include clause, exporting data to CSV, using JSON in Postgres and Zedstore.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/62-index-include-clause-exporting-csv-json-zedstore/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Index Include Clause, Exporting CSV, JSON, Zedstore | Scaling Postgres 62]]>
                </itunes:title>
                                    <itunes:episode>62</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering the index include clause, exporting data to CSV, using JSON in Postgres and Zedstore.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/62-index-include-clause-exporting-csv-json-zedstore/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551369/sp62.mp3" length="15039007"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering the index include clause, exporting data to CSV, using JSON in Postgres and Zedstore.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/62-index-include-clause-exporting-csv-json-zedstore/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551369/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:39</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Constraint Triggers, Simple Shards, Data Streams, OIDs | Scaling Postgres 61]]>
                </title>
                <pubDate>Mon, 29 Apr 2019 00:22:26 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    d907dcdbdcaa43678ff34d1bc7467e11</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-61-constraint-triggers-simple-shards-data-streams-oids</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering constraint triggers, simple shards, data streams and OIDs.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/61-constraint-triggers-simple-shards-data-streams-oids/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering constraint triggers, simple shards, data streams and OIDs.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/61-constraint-triggers-simple-shards-data-streams-oids/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Constraint Triggers, Simple Shards, Data Streams, OIDs | Scaling Postgres 61]]>
                </itunes:title>
                                    <itunes:episode>61</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering constraint triggers, simple shards, data streams and OIDs.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/61-constraint-triggers-simple-shards-data-streams-oids/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551370/sp61.mp3" length="9843356"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering constraint triggers, simple shards, data streams and OIDs.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/61-constraint-triggers-simple-shards-data-streams-oids/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551370/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:10:15</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Pluggable Storage, Developer Gotchas, Cursors, PG12 | Scaling Postgres 60]]>
                </title>
                <pubDate>Sun, 21 Apr 2019 23:47:47 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    484f04ffabd84d84b3ff89d30d93bd54</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-60-pluggable-storage-developer-gotchas-cursors-pg12</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering pluggable storage, gotchas for developers, using cursors and new PG12 features.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/60-pluggable-storage-developer-gotchas-cursors-pg12/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering pluggable storage, gotchas for developers, using cursors and new PG12 features.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/60-pluggable-storage-developer-gotchas-cursors-pg12/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Pluggable Storage, Developer Gotchas, Cursors, PG12 | Scaling Postgres 60]]>
                </itunes:title>
                                    <itunes:episode>60</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering pluggable storage, gotchas for developers, using cursors and new PG12 features.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/60-pluggable-storage-developer-gotchas-cursors-pg12/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551371/sp60.mp3" length="14261185"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering pluggable storage, gotchas for developers, using cursors and new PG12 features.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/60-pluggable-storage-developer-gotchas-cursors-pg12/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551371/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:51</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Popularity, Load Testing, Checksums, pg_hba | Scaling Postgres 59]]>
                </title>
                <pubDate>Sun, 14 Apr 2019 22:05:15 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    9926402c6e1a40728d7cc2c4e1c16c35</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-59-popularity-load-testing-checksums-pg-hba</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering Posgres' popularity, conducting load testing, checksums in PG12 and pg_hba configuration.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/59-popularity-load-testing-checksums-pg_hba/https://www.scalingpostgres.com/episodes/59-popularity-load-testing-checksums-pg_hba/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering Posgres' popularity, conducting load testing, checksums in PG12 and pg_hba configuration.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/59-popularity-load-testing-checksums-pg_hba/https://www.scalingpostgres.com/episodes/59-popularity-load-testing-checksums-pg_hba/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Popularity, Load Testing, Checksums, pg_hba | Scaling Postgres 59]]>
                </itunes:title>
                                    <itunes:episode>59</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering Posgres' popularity, conducting load testing, checksums in PG12 and pg_hba configuration.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/59-popularity-load-testing-checksums-pg_hba/https://www.scalingpostgres.com/episodes/59-popularity-load-testing-checksums-pg_hba/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551373/sp59.mp3" length="11853322"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering Posgres' popularity, conducting load testing, checksums in PG12 and pg_hba configuration.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/59-popularity-load-testing-checksums-pg_hba/https://www.scalingpostgres.com/episodes/59-popularity-load-testing-checksums-pg_hba/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551373/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:20</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Security Concerns, Fast Counting, Indexing, Trends | Scaling Postgres 58]]>
                </title>
                <pubDate>Mon, 08 Apr 2019 00:44:01 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    f5239152ce0b421f8472672982a5366d</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-58-security-concerns-fast-counting-indexing-trends</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering security concerns, fast counting tables, indexing basics and PostgreSQL trends.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/58-security-concerns-fast-counting-indexing-trends/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering security concerns, fast counting tables, indexing basics and PostgreSQL trends.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/58-security-concerns-fast-counting-indexing-trends/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Security Concerns, Fast Counting, Indexing, Trends | Scaling Postgres 58]]>
                </itunes:title>
                                    <itunes:episode>58</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering security concerns, fast counting tables, indexing basics and PostgreSQL trends.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/58-security-concerns-fast-counting-indexing-trends/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551372/sp58.mp3" length="18240574"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering security concerns, fast counting tables, indexing basics and PostgreSQL trends.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/58-security-concerns-fast-counting-indexing-trends/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551372/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:19:00</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Checking Vacuum, Fast Distinct Count, Group By Speed Up, Health Check | Scaling Postgres 57]]>
                </title>
                <pubDate>Sun, 31 Mar 2019 23:53:47 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    75c46c82191149d2a0ada6efadbd163c</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-57-checking-vacuum-fast-distinct-count-group-by-speed-up-health-check</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering checking on vacuum, how to get a fast distinct count and speed up group by and a health check playbook.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/57-checking-vacuum-fast-distinct-count-group-by-speed-up-health-check/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering checking on vacuum, how to get a fast distinct count and speed up group by and a health check playbook.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/57-checking-vacuum-fast-distinct-count-group-by-speed-up-health-check/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Checking Vacuum, Fast Distinct Count, Group By Speed Up, Health Check | Scaling Postgres 57]]>
                </itunes:title>
                                    <itunes:episode>57</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering checking on vacuum, how to get a fast distinct count and speed up group by and a health check playbook.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/57-checking-vacuum-fast-distinct-count-group-by-speed-up-health-check/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551375/sp57.mp3" length="13839046"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering checking on vacuum, how to get a fast distinct count and speed up group by and a health check playbook.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/57-checking-vacuum-fast-distinct-count-group-by-speed-up-health-check/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551375/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:24</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Practical Indexing, Vertical Scaling, Partition Migration, FDW Performance | Scaling Postgres 56]]>
                </title>
                <pubDate>Sun, 24 Mar 2019 22:42:23 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    d352da6cc37943d2858a75113eca4f38</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-56-practical-indexing-vertical-scaling-partition-migration-fdw-performance</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering practical indexing, vertical scalability, migrating to partitions and foreign data wrapper performance.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/56-practical-indexing-vertical-scaling-partition-migration-fdw-performance/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering practical indexing, vertical scalability, migrating to partitions and foreign data wrapper performance.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/56-practical-indexing-vertical-scaling-partition-migration-fdw-performance/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Practical Indexing, Vertical Scaling, Partition Migration, FDW Performance | Scaling Postgres 56]]>
                </itunes:title>
                                    <itunes:episode>56</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering practical indexing, vertical scalability, migrating to partitions and foreign data wrapper performance.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/56-practical-indexing-vertical-scaling-partition-migration-fdw-performance/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551374/sp56.mp3" length="10175216"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering practical indexing, vertical scalability, migrating to partitions and foreign data wrapper performance.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/56-practical-indexing-vertical-scaling-partition-migration-fdw-performance/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551374/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:10:35</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Replicating Data, SQL Functions, High Availability, Locking Issues | Scaling Postgres 55]]>
                </title>
                <pubDate>Mon, 18 Mar 2019 01:32:24 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    750a1207148342e68d0d866af01c8786</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-55-replicating-data-sql-functions-high-availability-locking-issues</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering methods to replicate data, SQL functions, tools for high availability and locking issues.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/55-replicating-data-sql-functions-high-availability-locking-issues/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering methods to replicate data, SQL functions, tools for high availability and locking issues.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/55-replicating-data-sql-functions-high-availability-locking-issues/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Replicating Data, SQL Functions, High Availability, Locking Issues | Scaling Postgres 55]]>
                </itunes:title>
                                    <itunes:episode>55</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering methods to replicate data, SQL functions, tools for high availability and locking issues.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/55-replicating-data-sql-functions-high-availability-locking-issues/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551376/sp55.mp3" length="7058076"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering methods to replicate data, SQL functions, tools for high availability and locking issues.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/55-replicating-data-sql-functions-high-availability-locking-issues/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551376/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:07:21</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Index-Only Scans, Lock Table, Hot Standby Feedback, Large Backups | Scaling Postgres 54]]>
                </title>
                <pubDate>Mon, 11 Mar 2019 01:09:10 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    3f8219be79a34d4a86da626c828a5d0b</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-54-index-only-scans-lock-table-hot-standby-feedback-large-backups</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering index-only scans, locking tables, hot standby feedback and handling very large backups.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/54-index-only-scans-lock-table-hot-standby-feedback-large-backups/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering index-only scans, locking tables, hot standby feedback and handling very large backups.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/54-index-only-scans-lock-table-hot-standby-feedback-large-backups/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Index-Only Scans, Lock Table, Hot Standby Feedback, Large Backups | Scaling Postgres 54]]>
                </itunes:title>
                                    <itunes:episode>54</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering index-only scans, locking tables, hot standby feedback and handling very large backups.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/54-index-only-scans-lock-table-hot-standby-feedback-large-backups/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551377/sp54.mp3" length="14869733"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering index-only scans, locking tables, hot standby feedback and handling very large backups.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/54-index-only-scans-lock-table-hot-standby-feedback-large-backups/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551377/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:29</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Query Planner, BRIN Indexes, Approximate Algorithms, Delayed Replication | Scaling Postgres 53]]>
                </title>
                <pubDate>Mon, 04 Mar 2019 03:58:02 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    142bfa72507940e1a268aa8cd9b1d44b</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-53-query-planner-brin-indexes-approximate-algorithms-delayed-replication</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering the Postgres query planner, BRIN indexes, approximate algorithms, and the uses of delayed replication.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/53-query-planner-brin-indexes-approximate-algorithms-delayed-replication/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering the Postgres query planner, BRIN indexes, approximate algorithms, and the uses of delayed replication.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/53-query-planner-brin-indexes-approximate-algorithms-delayed-replication/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Query Planner, BRIN Indexes, Approximate Algorithms, Delayed Replication | Scaling Postgres 53]]>
                </itunes:title>
                                    <itunes:episode>53</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering the Postgres query planner, BRIN indexes, approximate algorithms, and the uses of delayed replication.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/53-query-planner-brin-indexes-approximate-algorithms-delayed-replication/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551379/sp53.mp3" length="18430328"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering the Postgres query planner, BRIN indexes, approximate algorithms, and the uses of delayed replication.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/53-query-planner-brin-indexes-approximate-algorithms-delayed-replication/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551379/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:19:11</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[fsync Stopgap, CTE Changes, autovacuum_naptime, Postgres Community | Scaling Postgres 52]]>
                </title>
                <pubDate>Mon, 25 Feb 2019 00:43:21 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    8f565b7fc7fe4d29ad9a4e52feacac7a</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-52-fsync-stopgap-cte-changes-autovacuum-naptime-postgres-community</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering a fsync stopgap, tuning autovacuum_naptime, upcoming CTE / WITH clause changes and the Postgres community.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/52-fsync-stopgap-autovacuum_naptime-cte-changes-postgres-community/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering a fsync stopgap, tuning autovacuum_naptime, upcoming CTE / WITH clause changes and the Postgres community.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/52-fsync-stopgap-autovacuum_naptime-cte-changes-postgres-community/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[fsync Stopgap, CTE Changes, autovacuum_naptime, Postgres Community | Scaling Postgres 52]]>
                </itunes:title>
                                    <itunes:episode>52</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering a fsync stopgap, tuning autovacuum_naptime, upcoming CTE / WITH clause changes and the Postgres community.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/52-fsync-stopgap-autovacuum_naptime-cte-changes-postgres-community/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551378/sp52.mp3" length="9412022"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering a fsync stopgap, tuning autovacuum_naptime, upcoming CTE / WITH clause changes and the Postgres community.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/52-fsync-stopgap-autovacuum_naptime-cte-changes-postgres-community/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551378/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:09:48</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Value of SQL, Window Functions, DB Migrations, Data Storage | Scaling Postgres 51]]>
                </title>
                <pubDate>Mon, 18 Feb 2019 02:10:36 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    cfd2fd0cfe514303a7a7b4f2f9379f3e</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-51-value-of-sql-window-functions-db-migrations-data-storage</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering the value of SQL, window functions, scaling database migrations and efficient data storage.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/51-sql-value-window-functions-db-migrations-data-storage/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering the value of SQL, window functions, scaling database migrations and efficient data storage.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/51-sql-value-window-functions-db-migrations-data-storage/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Value of SQL, Window Functions, DB Migrations, Data Storage | Scaling Postgres 51]]>
                </itunes:title>
                                    <itunes:episode>51</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering the value of SQL, window functions, scaling database migrations and efficient data storage.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/51-sql-value-window-functions-db-migrations-data-storage/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551380/sp51.mp3" length="15337848"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering the value of SQL, window functions, scaling database migrations and efficient data storage.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/51-sql-value-window-functions-db-migrations-data-storage/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551380/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:58</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Outage from TXIDs, Breaking Scale, fsync Gate, pg_stat_statements | Scaling Postgres 50]]>
                </title>
                <pubDate>Mon, 11 Feb 2019 00:13:40 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    bcdde6c41301489aaf19b589b904d2d2</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-50-outage-from-txids-breaking-scale-fsync-gate-pg-stat-statements</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering an outage from running out of TXIDs, breaking scale, that PG fsync issue and pg_stat_statements.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/50-outage-txids-breaking-scale-fsync-gate-pg_stat_statements/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering an outage from running out of TXIDs, breaking scale, that PG fsync issue and pg_stat_statements.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/50-outage-txids-breaking-scale-fsync-gate-pg_stat_statements/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Outage from TXIDs, Breaking Scale, fsync Gate, pg_stat_statements | Scaling Postgres 50]]>
                </itunes:title>
                                    <itunes:episode>50</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering an outage from running out of TXIDs, breaking scale, that PG fsync issue and pg_stat_statements.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/50-outage-txids-breaking-scale-fsync-gate-pg_stat_statements/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551381/sp50.mp3" length="13813133"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering an outage from running out of TXIDs, breaking scale, that PG fsync issue and pg_stat_statements.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/50-outage-txids-breaking-scale-fsync-gate-pg_stat_statements/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551381/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:23</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Over One Billion, No Downtime, SQL Life, Throughput | Scaling Postgres 49]]>
                </title>
                <pubDate>Mon, 04 Feb 2019 02:05:56 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    d6abd23460cf4899a40cc89c8fd00d19</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-49-over-one-billion-no-downtime-sql-life-throughput</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering over one billion records per month, schema changes with no downtime, the life of a SQL query and throughput tracking.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/49-over-one-billion-monthly-records-no-downtime-schema-changes-sql-life-throughput-tracking/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering over one billion records per month, schema changes with no downtime, the life of a SQL query and throughput tracking.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/49-over-one-billion-monthly-records-no-downtime-schema-changes-sql-life-throughput-tracking/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Over One Billion, No Downtime, SQL Life, Throughput | Scaling Postgres 49]]>
                </itunes:title>
                                    <itunes:episode>49</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering over one billion records per month, schema changes with no downtime, the life of a SQL query and throughput tracking.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/49-over-one-billion-monthly-records-no-downtime-schema-changes-sql-life-throughput-tracking/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551383/sp49.mp3" length="13766739"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering over one billion records per month, schema changes with no downtime, the life of a SQL query and throughput tracking.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/49-over-one-billion-monthly-records-no-downtime-schema-changes-sql-life-throughput-tracking/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551383/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:20</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Microsoft Acquires Citus Data, Split WAL, Maintenance Work Mem | Scaling Postgres 48]]>
                </title>
                <pubDate>Sun, 27 Jan 2019 23:16:33 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    b17b481c0dce4a248a64ebeceaf73068</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-48-microsoft-acquires-citus-data-split-wal-maintenance-work-mem</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering Microsoft acquiring Citus Data, split WAL files, maintenance_work_mem and logical replication.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/48-microsoft-acquires-citus-data-split-wal-maintenance-work-memory-logical-replication/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering Microsoft acquiring Citus Data, split WAL files, maintenance_work_mem and logical replication.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/48-microsoft-acquires-citus-data-split-wal-maintenance-work-memory-logical-replication/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Microsoft Acquires Citus Data, Split WAL, Maintenance Work Mem | Scaling Postgres 48]]>
                </itunes:title>
                                    <itunes:episode>48</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering Microsoft acquiring Citus Data, split WAL files, maintenance_work_mem and logical replication.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/48-microsoft-acquires-citus-data-split-wal-maintenance-work-memory-logical-replication/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551384/sp48.mp3" length="14111555"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering Microsoft acquiring Citus Data, split WAL files, maintenance_work_mem and logical replication.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/48-microsoft-acquires-citus-data-split-wal-maintenance-work-memory-logical-replication/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551384/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:41</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[pgBouncer, Postgres 11 Gems, DocumentDB, JSON | Scaling Postgres 47]]>
                </title>
                <pubDate>Sun, 20 Jan 2019 23:11:52 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    e1fbc50629b64d3199514433a67a9f0d</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-47-pgbouncer-postgres-11-gems-documentdb-json</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering pgBouncer, Postgres 11 gems, DocumentDB similarities and JSON capabilities.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/47-pgbouncer-postgres-11-gems-documentdb-json/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering pgBouncer, Postgres 11 gems, DocumentDB similarities and JSON capabilities.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/47-pgbouncer-postgres-11-gems-documentdb-json/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[pgBouncer, Postgres 11 Gems, DocumentDB, JSON | Scaling Postgres 47]]>
                </itunes:title>
                                    <itunes:episode>47</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering pgBouncer, Postgres 11 gems, DocumentDB similarities and JSON capabilities.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/47-pgbouncer-postgres-11-gems-documentdb-json/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551382/sp47.mp3" length="10818873"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering pgBouncer, Postgres 11 gems, DocumentDB similarities and JSON capabilities.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/47-pgbouncer-postgres-11-gems-documentdb-json/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551382/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:11:16</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Stuck Transaction IDs, pgBouncer Auth, UUIDs, Monitoring | Scaling Postgres 46]]>
                </title>
                <pubDate>Sun, 13 Jan 2019 23:25:01 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    6e06bcc0cd0443fa8dee731ba3fbd73d</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-46-stuck-transaction-ids-pgbouncer-auth-uuids-monitoring</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering stuck transaction ids, pgBouncer authentication, sequential UUIDs, and monitoring.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/46-stuck-transaction-ids-pgbouncer-authentication-uuids-monitoring/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering stuck transaction ids, pgBouncer authentication, sequential UUIDs, and monitoring.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/46-stuck-transaction-ids-pgbouncer-authentication-uuids-monitoring/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Stuck Transaction IDs, pgBouncer Auth, UUIDs, Monitoring | Scaling Postgres 46]]>
                </itunes:title>
                                    <itunes:episode>46</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering stuck transaction ids, pgBouncer authentication, sequential UUIDs, and monitoring.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/46-stuck-transaction-ids-pgbouncer-authentication-uuids-monitoring/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551385/sp46.mp3" length="11219696"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering stuck transaction ids, pgBouncer authentication, sequential UUIDs, and monitoring.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/46-stuck-transaction-ids-pgbouncer-authentication-uuids-monitoring/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551385/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:11:41</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[DBMS of 2018, Data Anonymization, JIT, Reserved Keywords | Scaling Postgres 45]]>
                </title>
                <pubDate>Mon, 07 Jan 2019 04:38:10 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    837b21d2a9544f229f87feb07fa47654</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-45-dbms-of-2018-data-anonymization-jit-reserved-keywords</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering Postgres as DBMS of 2018, data anonymization, implementing JIT and reserved keywords.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/45-dmbs-2018-data-anonymization-jit-reserved-keywords/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering Postgres as DBMS of 2018, data anonymization, implementing JIT and reserved keywords.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/45-dmbs-2018-data-anonymization-jit-reserved-keywords/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[DBMS of 2018, Data Anonymization, JIT, Reserved Keywords | Scaling Postgres 45]]>
                </itunes:title>
                                    <itunes:episode>45</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering Postgres as DBMS of 2018, data anonymization, implementing JIT and reserved keywords.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/45-dmbs-2018-data-anonymization-jit-reserved-keywords/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551386/sp45.mp3" length="6751294"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering Postgres as DBMS of 2018, data anonymization, implementing JIT and reserved keywords.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/45-dmbs-2018-data-anonymization-jit-reserved-keywords/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551386/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:07:01</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres Rise, Row Count Estimates, Nulls, Linux Config | Scaling Postgres 44]]>
                </title>
                <pubDate>Mon, 31 Dec 2018 00:45:31 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    6b95d599baa54ca78fa6a2f3bbd421a6</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-44-postgres-rise-row-count-estimates-nulls-linux-config</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering the rise of Postgres, row count estimates, nulls and linux configuration.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/44-postgres-rise-row-count-estimates-nulls-linux-config/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering the rise of Postgres, row count estimates, nulls and linux configuration.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/44-postgres-rise-row-count-estimates-nulls-linux-config/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres Rise, Row Count Estimates, Nulls, Linux Config | Scaling Postgres 44]]>
                </itunes:title>
                                    <itunes:episode>44</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering the rise of Postgres, row count estimates, nulls and linux configuration.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/44-postgres-rise-row-count-estimates-nulls-linux-config/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551387/sp44.mp3" length="7926595"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering the rise of Postgres, row count estimates, nulls and linux configuration.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/44-postgres-rise-row-count-estimates-nulls-linux-config/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551387/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:08:15</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Logical Replication, Prepared Transactions, Ansible, Partitions | Scaling Postgres 43]]>
                </title>
                <pubDate>Mon, 17 Dec 2018 00:43:47 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    cdc511d0812a4331b1b9a68b28855ce9</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-43-logical-replication-prepared-transactions-ansible-partitions</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering logical replication, prepared transactions, Ansible Postgres deployment Ansible and tidy partitions.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/43-logical-replication-prepared-transactions-ansible-tidy-partitions/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering logical replication, prepared transactions, Ansible Postgres deployment Ansible and tidy partitions.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/43-logical-replication-prepared-transactions-ansible-tidy-partitions/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Logical Replication, Prepared Transactions, Ansible, Partitions | Scaling Postgres 43]]>
                </itunes:title>
                                    <itunes:episode>43</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering logical replication, prepared transactions, Ansible Postgres deployment Ansible and tidy partitions.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/43-logical-replication-prepared-transactions-ansible-tidy-partitions/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551388/sp43.mp3" length="9429577"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering logical replication, prepared transactions, Ansible Postgres deployment Ansible and tidy partitions.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/43-logical-replication-prepared-transactions-ansible-tidy-partitions/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551388/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:09:49</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Multi-Terabyte Scaling, Kubernetes DBaaS, Encryption, High Availability | Scaling Postgres 42]]>
                </title>
                <pubDate>Sun, 09 Dec 2018 23:12:42 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    a27933c7edd34dff963668c2bff81401</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-42-multi-terabyte-scaling-kubernetes-dbaas-encryption-high-availability</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering multi-terabyte scaling, building a kubernetes DBaaS, encryption and building high availability.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/42-multi-terabyte-scaling-kubernetes-dbaas-encryption-high-availability/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering multi-terabyte scaling, building a kubernetes DBaaS, encryption and building high availability.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/42-multi-terabyte-scaling-kubernetes-dbaas-encryption-high-availability/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Multi-Terabyte Scaling, Kubernetes DBaaS, Encryption, High Availability | Scaling Postgres 42]]>
                </itunes:title>
                                    <itunes:episode>42</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering multi-terabyte scaling, building a kubernetes DBaaS, encryption and building high availability.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/42-multi-terabyte-scaling-kubernetes-dbaas-encryption-high-availability/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551389/sp42.mp3" length="11751340"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering multi-terabyte scaling, building a kubernetes DBaaS, encryption and building high availability.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/42-multi-terabyte-scaling-kubernetes-dbaas-encryption-high-availability/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551389/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:14</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Sequential UUIDs, Runnning Totals, Read Committed, TOAST | Scaling Postgres 41]]>
                </title>
                <pubDate>Mon, 03 Dec 2018 01:19:10 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    62ef472c55de409d879c76ed4742275e</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-41-sequential-uuids-runnning-totals-read-committed-toast</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering sequential UUIDs, running totals with window functions, read committed vs repeatable read and TOAST.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/41-sequential-uuids-running-totals-read-commmitted-toast/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering sequential UUIDs, running totals with window functions, read committed vs repeatable read and TOAST.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/41-sequential-uuids-running-totals-read-commmitted-toast/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Sequential UUIDs, Runnning Totals, Read Committed, TOAST | Scaling Postgres 41]]>
                </itunes:title>
                                    <itunes:episode>41</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering sequential UUIDs, running totals with window functions, read committed vs repeatable read and TOAST.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/41-sequential-uuids-running-totals-read-commmitted-toast/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551391/sp41.mp3" length="13864542"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering sequential UUIDs, running totals with window functions, read committed vs repeatable read and TOAST.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/41-sequential-uuids-running-totals-read-commmitted-toast/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551391/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:26</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Materialized, PgBouncer Auth, Implicit vs Explicit, JIT | Scaling Postgres 40]]>
                </title>
                <pubDate>Sun, 25 Nov 2018 23:07:47 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    8b6994dce17e4f838fe8e08785390396</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-40-materialized-pgbouncer-auth-implicit-vs-explicit-jit</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering materialized views in Rails, pgbouncer auth_user, implicit vs explicit joins and JIT.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/40-materialized-pgbouncer-auth-implicit-explicit-jit/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering materialized views in Rails, pgbouncer auth_user, implicit vs explicit joins and JIT.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/40-materialized-pgbouncer-auth-implicit-explicit-jit/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Materialized, PgBouncer Auth, Implicit vs Explicit, JIT | Scaling Postgres 40]]>
                </itunes:title>
                                    <itunes:episode>40</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering materialized views in Rails, pgbouncer auth_user, implicit vs explicit joins and JIT.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/40-materialized-pgbouncer-auth-implicit-explicit-jit/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551390/sp40.mp3" length="8273502"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering materialized views in Rails, pgbouncer auth_user, implicit vs explicit joins and JIT.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/40-materialized-pgbouncer-auth-implicit-explicit-jit/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551390/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:08:37</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Bloat vs zHeap, Composite Indexes, Unsafe Operations | Scaling Postgres 39]]>
                </title>
                <pubDate>Mon, 19 Nov 2018 03:40:19 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    f40003da6ed34bf488d0e19c7c322a61</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-39-bloat-vs-zheap-composite-indexes-unsafe-operations</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering bloat vs. zheap, composite indexes, unsafe operations, and being a better developer.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/39-bloat-vs-zheap-composite-indexes-unsafe-operations-better-developers/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering bloat vs. zheap, composite indexes, unsafe operations, and being a better developer.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/39-bloat-vs-zheap-composite-indexes-unsafe-operations-better-developers/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Bloat vs zHeap, Composite Indexes, Unsafe Operations | Scaling Postgres 39]]>
                </itunes:title>
                                    <itunes:episode>39</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering bloat vs. zheap, composite indexes, unsafe operations, and being a better developer.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/39-bloat-vs-zheap-composite-indexes-unsafe-operations-better-developers/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551392/sp39.mp3" length="17042285"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering bloat vs. zheap, composite indexes, unsafe operations, and being a better developer.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/39-bloat-vs-zheap-composite-indexes-unsafe-operations-better-developers/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551392/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:17:45</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Parallel Query, Real Time Analytics, Killed Index Tuples | Scaling Postgres 38]]>
                </title>
                <pubDate>Mon, 12 Nov 2018 01:10:49 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    615a27abed014b88b4601e6ffca27f70</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-38-parallel-query-real-time-analytics-killed-index-tuples</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering parallel queries, real time analytics, killed index tuples and unexpected downtime.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/38-parallel-query-real-time-analytics-killed-index-tuples-downtime/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering parallel queries, real time analytics, killed index tuples and unexpected downtime.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/38-parallel-query-real-time-analytics-killed-index-tuples-downtime/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Parallel Query, Real Time Analytics, Killed Index Tuples | Scaling Postgres 38]]>
                </itunes:title>
                                    <itunes:episode>38</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering parallel queries, real time analytics, killed index tuples and unexpected downtime.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/38-parallel-query-real-time-analytics-killed-index-tuples-downtime/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551393/sp38.mp3" length="9501884"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering parallel queries, real time analytics, killed index tuples and unexpected downtime.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/38-parallel-query-real-time-analytics-killed-index-tuples-downtime/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551393/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:09:53</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres Goodies, Materialized vs Rollup, Column Oriented | Scaling Postgres 37]]>
                </title>
                <pubDate>Mon, 05 Nov 2018 01:33:45 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    63f992aea3ab4b3eabd12df696576678</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-37-postgres-goodies-materialized-vs-rollup-column-oriented</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering Postgres goodies, materialized vs. rollup, column oriented data and parallel scans.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/37-postgres-goodies-materialized-vs-rollup-column-oriented-parallel-scan/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering Postgres goodies, materialized vs. rollup, column oriented data and parallel scans.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/37-postgres-goodies-materialized-vs-rollup-column-oriented-parallel-scan/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres Goodies, Materialized vs Rollup, Column Oriented | Scaling Postgres 37]]>
                </itunes:title>
                                    <itunes:episode>37</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering Postgres goodies, materialized vs. rollup, column oriented data and parallel scans.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/37-postgres-goodies-materialized-vs-rollup-column-oriented-parallel-scan/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551394/sp37.mp3" length="16885551"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering Postgres goodies, materialized vs. rollup, column oriented data and parallel scans.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/37-postgres-goodies-materialized-vs-rollup-column-oriented-parallel-scan/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551394/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:17:35</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Sharding, Giving Back, SCRAM, Partitioning Evolution | Scaling Postgres 36]]>
                </title>
                <pubDate>Mon, 29 Oct 2018 02:49:33 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    a6222497ae1e41f6bff86ed2c4ae728a</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-36-sharding-giving-back-scram-partitioning-evolution</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering PG11 sharding, giving back, SCRAM authentication and the evolution of partitioning.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/36-sharding-giving-back-scram-partitioning-evolution/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering PG11 sharding, giving back, SCRAM authentication and the evolution of partitioning.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/36-sharding-giving-back-scram-partitioning-evolution/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Sharding, Giving Back, SCRAM, Partitioning Evolution | Scaling Postgres 36]]>
                </itunes:title>
                                    <itunes:episode>36</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering PG11 sharding, giving back, SCRAM authentication and the evolution of partitioning.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/36-sharding-giving-back-scram-partitioning-evolution/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551395/sp36.mp3" length="10424737"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering PG11 sharding, giving back, SCRAM authentication and the evolution of partitioning.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/36-sharding-giving-back-scram-partitioning-evolution/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551395/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:10:51</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Terabyte Scaling, Postgres 11, Connections, Backup | Scaling Postgres 35]]>
                </title>
                <pubDate>Mon, 22 Oct 2018 00:19:02 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    0a749af2a7374923ba7b3241163039ec</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-35-terabyte-scaling-postgres-11-connections-backup</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering terabyte scaling, PostgreSQL 11, managing connections and backup of terabyte databases.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/35-terabyte-scaling-postgres-11-connections-backup/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering terabyte scaling, PostgreSQL 11, managing connections and backup of terabyte databases.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/35-terabyte-scaling-postgres-11-connections-backup/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Terabyte Scaling, Postgres 11, Connections, Backup | Scaling Postgres 35]]>
                </itunes:title>
                                    <itunes:episode>35</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering terabyte scaling, PostgreSQL 11, managing connections and backup of terabyte databases.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/35-terabyte-scaling-postgres-11-connections-backup/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551396/sp35.mp3" length="16444186"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering terabyte scaling, PostgreSQL 11, managing connections and backup of terabyte databases.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/35-terabyte-scaling-postgres-11-connections-backup/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551396/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:17:07</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Inserts, Nearest Neighbor, Freezing, Comment | Scaling Postgres 34]]>
                </title>
                <pubDate>Mon, 15 Oct 2018 02:54:43 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    f3357e2177d14f22a5feefbf91dbb8b3</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-34-inserts-nearest-neighbor-freezing-comment</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering all about inserts, how to handle nearest neighbor, freezing confirmation and Comment.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/34-inserts-nearest-neighbor-freezing-comment/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering all about inserts, how to handle nearest neighbor, freezing confirmation and Comment.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/34-inserts-nearest-neighbor-freezing-comment/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Inserts, Nearest Neighbor, Freezing, Comment | Scaling Postgres 34]]>
                </itunes:title>
                                    <itunes:episode>34</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering all about inserts, how to handle nearest neighbor, freezing confirmation and Comment.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/34-inserts-nearest-neighbor-freezing-comment/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551397/sp34.mp3" length="11302870"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering all about inserts, how to handle nearest neighbor, freezing confirmation and Comment.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/34-inserts-nearest-neighbor-freezing-comment/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551397/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:11:46</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Per-Table Autovacuum, FDW Synchronization, Distinct On | Scaling Postgres 33]]>
                </title>
                <pubDate>Mon, 08 Oct 2018 14:21:24 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    cc29ace254a842b58403aaeaeb55f960</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-33-per-table-autovacuum-fdw-synchronization-distinct-on</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering per-table autovacuum, FDW for data synchronization, distinct on and Postgres Open.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/33-per-table-autovacuum-fdw-synchronization-distinct-on-postgres-open/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering per-table autovacuum, FDW for data synchronization, distinct on and Postgres Open.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/33-per-table-autovacuum-fdw-synchronization-distinct-on-postgres-open/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Per-Table Autovacuum, FDW Synchronization, Distinct On | Scaling Postgres 33]]>
                </itunes:title>
                                    <itunes:episode>33</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering per-table autovacuum, FDW for data synchronization, distinct on and Postgres Open.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/33-per-table-autovacuum-fdw-synchronization-distinct-on-postgres-open/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551398/sp33.mp3" length="8837746"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering per-table autovacuum, FDW for data synchronization, distinct on and Postgres Open.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/33-per-table-autovacuum-fdw-synchronization-distinct-on-postgres-open/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551398/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:09:12</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Sysadmin Concerns, Power of Indexing, pgbouncer Monitoring | Scaling Postgres 32]]>
                </title>
                <pubDate>Mon, 01 Oct 2018 03:29:10 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    e0e6ed6365014fdda385762ffb2df948</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-32-sysadmin-concerns-power-of-indexing-pgbouncer-monitoring</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering sysadmin concerns, the power of indexing, pgbouncer monitoring and pg_prewarm.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/32-sysadmin-concerns-power-of-indexing-pgbouncer-monitoring/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering sysadmin concerns, the power of indexing, pgbouncer monitoring and pg_prewarm.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/32-sysadmin-concerns-power-of-indexing-pgbouncer-monitoring/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Sysadmin Concerns, Power of Indexing, pgbouncer Monitoring | Scaling Postgres 32]]>
                </itunes:title>
                                    <itunes:episode>32</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering sysadmin concerns, the power of indexing, pgbouncer monitoring and pg_prewarm.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/32-sysadmin-concerns-power-of-indexing-pgbouncer-monitoring/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551399/sp32.mp3" length="11490533"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering sysadmin concerns, the power of indexing, pgbouncer monitoring and pg_prewarm.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/32-sysadmin-concerns-power-of-indexing-pgbouncer-monitoring/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551399/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:11:58</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[CTE Warning, PG 11 Features, Death by DB, Correlation | Scaling Postgres 31]]>
                </title>
                <pubDate>Mon, 24 Sep 2018 03:13:31 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    7e2541c328614277a322ca3a631bcecd</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-31-cte-warning-pg-11-features-death-by-db-correlation</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering a CTE warning, Postgres 11 new features, death by database and column correlation.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/31-cte-warning-pg11-features-death-by-db-column-correlation/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering a CTE warning, Postgres 11 new features, death by database and column correlation.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/31-cte-warning-pg11-features-death-by-db-column-correlation/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[CTE Warning, PG 11 Features, Death by DB, Correlation | Scaling Postgres 31]]>
                </itunes:title>
                                    <itunes:episode>31</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering a CTE warning, Postgres 11 new features, death by database and column correlation.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/31-cte-warning-pg11-features-death-by-db-column-correlation/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551402/sp31.mp3" length="15129704"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering a CTE warning, Postgres 11 new features, death by database and column correlation.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/31-cte-warning-pg11-features-death-by-db-column-correlation/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551402/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:45</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Parallelism, JIT Compiling, Indexes, Administration | Scaling Postgres 30]]>
                </title>
                <pubDate>Mon, 17 Sep 2018 03:08:47 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    2ad0e9e64f794ebab877bd9bd0ea180f</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-30-parallelism-jit-compiling-indexes-administration</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering parallellism in Postgres 11, JIT compiling, indexes in depth and administration.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/30-parallelism-jit-compiling-indexes-administration/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering parallellism in Postgres 11, JIT compiling, indexes in depth and administration.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/30-parallelism-jit-compiling-indexes-administration/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Parallelism, JIT Compiling, Indexes, Administration | Scaling Postgres 30]]>
                </itunes:title>
                                    <itunes:episode>30</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering parallellism in Postgres 11, JIT compiling, indexes in depth and administration.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/30-parallelism-jit-compiling-indexes-administration/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551400/sp30.mp3" length="9367301"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering parallellism in Postgres 11, JIT compiling, indexes in depth and administration.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/30-parallelism-jit-compiling-indexes-administration/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551400/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:09:45</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Parallel Indexing, SQL vs. ORM, Logical Replication Upgrades | Scaling Postgres 29]]>
                </title>
                <pubDate>Mon, 10 Sep 2018 03:04:52 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    5b9446dcbe5244c982f43c2c6213be3c</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-29-parallel-indexing-sql-vs-orm-logical-replication-upgrades</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering parallel indexing, SQL vs. ORM, logical replication upgrades and development DBs.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/29-parallel-indexing-sql-vs-orm-logical-replication-upgrades/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering parallel indexing, SQL vs. ORM, logical replication upgrades and development DBs.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/29-parallel-indexing-sql-vs-orm-logical-replication-upgrades/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Parallel Indexing, SQL vs. ORM, Logical Replication Upgrades | Scaling Postgres 29]]>
                </itunes:title>
                                    <itunes:episode>29</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering parallel indexing, SQL vs. ORM, logical replication upgrades and development DBs.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/29-parallel-indexing-sql-vs-orm-logical-replication-upgrades/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551401/sp29.mp3" length="12920372"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering parallel indexing, SQL vs. ORM, logical replication upgrades and development DBs.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/29-parallel-indexing-sql-vs-orm-logical-replication-upgrades/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551401/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:13:27</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Watch, Fast Text Search, Column Defaults, Import CSVs | Scaling Postgres 28]]>
                </title>
                <pubDate>Mon, 03 Sep 2018 03:12:06 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    897607f5db3e402381a2ff62ff108e9e</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-28-watch-fast-text-search-column-defaults-import-csvs</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering watching Star Wars, fast text search, column defaults and importing large CSVs.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/28-watch-fast-text-search-column-defaults-import-csv/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering watching Star Wars, fast text search, column defaults and importing large CSVs.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/28-watch-fast-text-search-column-defaults-import-csv/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Watch, Fast Text Search, Column Defaults, Import CSVs | Scaling Postgres 28]]>
                </itunes:title>
                                    <itunes:episode>28</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering watching Star Wars, fast text search, column defaults and importing large CSVs.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/28-watch-fast-text-search-column-defaults-import-csv/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551403/sp28.mp3" length="16410331"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering watching Star Wars, fast text search, column defaults and importing large CSVs.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/28-watch-fast-text-search-column-defaults-import-csv/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551403/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:17:05</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Multiple Databases, Slow Queries, Sorting Performance | Scaling Postgres 27]]>
                </title>
                <pubDate>Mon, 27 Aug 2018 02:54:37 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    f2c041316edc482fa0e8791d1f45423e</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-27-multiple-databases-slow-queries-sorting-performance</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering scaling with multiple databases, detecting slow queries, and sorting performance.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/27-multiple-databases-slow-queries-sorting-performance/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering scaling with multiple databases, detecting slow queries, and sorting performance.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/27-multiple-databases-slow-queries-sorting-performance/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Multiple Databases, Slow Queries, Sorting Performance | Scaling Postgres 27]]>
                </itunes:title>
                                    <itunes:episode>27</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering scaling with multiple databases, detecting slow queries, and sorting performance.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/27-multiple-databases-slow-queries-sorting-performance/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551404/sp27.mp3" length="17348649"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering scaling with multiple databases, detecting slow queries, and sorting performance.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/27-multiple-databases-slow-queries-sorting-performance/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551404/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:18:04</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Join Costs, zHeap, Autovacuum Tuning | Scaling Postgres 26]]>
                </title>
                <pubDate>Mon, 20 Aug 2018 03:06:25 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    79894b4c5c0942a4a7c2196efc3da5a1</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-26-join-costs-zheap-autovacuum-tuning</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering join costs, zHeap, autovacuum tuning and Postgres configuration for humans.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/26-join-costs-zheap-autovacuum-tuning/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering join costs, zHeap, autovacuum tuning and Postgres configuration for humans.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/26-join-costs-zheap-autovacuum-tuning/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Join Costs, zHeap, Autovacuum Tuning | Scaling Postgres 26]]>
                </itunes:title>
                                    <itunes:episode>26</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering join costs, zHeap, autovacuum tuning and Postgres configuration for humans.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/26-join-costs-zheap-autovacuum-tuning/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551405/sp26.mp3" length="9275768"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering join costs, zHeap, autovacuum tuning and Postgres configuration for humans.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/26-join-costs-zheap-autovacuum-tuning/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551405/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:09:39</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[generate_series, PG11 Partitioning, GPU Queries | Scaling Postgres 25]]>
                </title>
                <pubDate>Mon, 13 Aug 2018 03:11:31 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    79901e9841ac4305b99cfbbff99a234e</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-25-generate-series-pg11-partitioning-gpu-queries</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering graphing with generate_series, partitioning in Postgres 11 and GPUs for queries.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/25-generate_series-pg11-partitioning-gpu-queries/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering graphing with generate_series, partitioning in Postgres 11 and GPUs for queries.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/25-generate_series-pg11-partitioning-gpu-queries/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[generate_series, PG11 Partitioning, GPU Queries | Scaling Postgres 25]]>
                </itunes:title>
                                    <itunes:episode>25</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering graphing with generate_series, partitioning in Postgres 11 and GPUs for queries.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/25-generate_series-pg11-partitioning-gpu-queries/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551406/sp25.mp3" length="12714736"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering graphing with generate_series, partitioning in Postgres 11 and GPUs for queries.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/25-generate_series-pg11-partitioning-gpu-queries/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551406/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:13:14</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Full Text Search, JSONB_AGG, Upgrades, CIS | Scaling Postgres 24]]>
                </title>
                <pubDate>Mon, 06 Aug 2018 03:04:12 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    520fb64329004f649e9fc778b297d176</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-24-full-text-search-jsonb-agg-upgrades-cis</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering full text search, aggregating JSON with jsonb_agg, upgrades and CIS benchmarks.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/24-full-text-search-jsonb_agg-upgrades-cis/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering full text search, aggregating JSON with jsonb_agg, upgrades and CIS benchmarks.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/24-full-text-search-jsonb_agg-upgrades-cis/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Full Text Search, JSONB_AGG, Upgrades, CIS | Scaling Postgres 24]]>
                </itunes:title>
                                    <itunes:episode>24</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering full text search, aggregating JSON with jsonb_agg, upgrades and CIS benchmarks.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/24-full-text-search-jsonb_agg-upgrades-cis/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551408/sp24.mp3" length="12023013"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering full text search, aggregating JSON with jsonb_agg, upgrades and CIS benchmarks.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/24-full-text-search-jsonb_agg-upgrades-cis/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551408/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:31</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[UUIDs, Write Spikes, Distinct, SQL Standard | Scaling Postgres 23]]>
                </title>
                <pubDate>Mon, 30 Jul 2018 03:31:09 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    e983754ff8c54518bf72012bea631344</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-23-uuids-write-spikes-distinct-sql-standard</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering UUIDs, the source of write spikes, uses of distinct and SQL standards support.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/23-uuids-write-spikes-distinct-sql-standard/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering UUIDs, the source of write spikes, uses of distinct and SQL standards support.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/23-uuids-write-spikes-distinct-sql-standard/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[UUIDs, Write Spikes, Distinct, SQL Standard | Scaling Postgres 23]]>
                </itunes:title>
                                    <itunes:episode>23</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering UUIDs, the source of write spikes, uses of distinct and SQL standards support.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/23-uuids-write-spikes-distinct-sql-standard/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551407/sp23.mp3" length="14081462"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering UUIDs, the source of write spikes, uses of distinct and SQL standards support.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/23-uuids-write-spikes-distinct-sql-standard/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551407/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:40</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Concurrency, Listen & Notify, ZFS, pg_rewind | Scaling Postgres 22]]>
                </title>
                <pubDate>Mon, 23 Jul 2018 02:57:07 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    0e67c8bffd404a4f96e13f229f145b44</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-22-concurrency-listen-notify-zfs-pg-rewind</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering concurrency, how to use listen &amp; notify, zfs, caution regarding pg_rewind.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/22-concurrency-listen-notify-zfs-pg_rewind/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering concurrency, how to use listen & notify, zfs, caution regarding pg_rewind.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/22-concurrency-listen-notify-zfs-pg_rewind/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Concurrency, Listen & Notify, ZFS, pg_rewind | Scaling Postgres 22]]>
                </itunes:title>
                                    <itunes:episode>22</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering concurrency, how to use listen &amp; notify, zfs, caution regarding pg_rewind.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/22-concurrency-listen-notify-zfs-pg_rewind/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551409/sp22.mp3" length="11251461"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering concurrency, how to use listen & notify, zfs, caution regarding pg_rewind.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/22-concurrency-listen-notify-zfs-pg_rewind/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551409/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:11:43</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Using JSON, Procedures, Concurrency, Kubernetes | Scaling Postgres 21]]>
                </title>
                <pubDate>Mon, 16 Jul 2018 02:44:42 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    3f3fb2e61a8e48f985d849a10fe58186</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-21-using-json-procedures-concurrency-kubernetes</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering how to use JSON &amp; JSONB, procedures, deal with concurrency issues and Kubernetes.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/21-using-json-procedures-concurrency-kubernetes/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering how to use JSON & JSONB, procedures, deal with concurrency issues and Kubernetes.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/21-using-json-procedures-concurrency-kubernetes/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Using JSON, Procedures, Concurrency, Kubernetes | Scaling Postgres 21]]>
                </itunes:title>
                                    <itunes:episode>21</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering how to use JSON &amp; JSONB, procedures, deal with concurrency issues and Kubernetes.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/21-using-json-procedures-concurrency-kubernetes/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551410/sp21.mp3" length="18910981"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering how to use JSON & JSONB, procedures, deal with concurrency issues and Kubernetes.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/21-using-json-procedures-concurrency-kubernetes/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551410/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:19:41</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Declarative Partitioning, Permissions, Trigger Speed | Scaling Postgres 20]]>
                </title>
                <pubDate>Mon, 09 Jul 2018 03:22:55 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    4c843e52c87146cd846b480b4003f8d2</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-20-declarative-partitioning-permissions-trigger-speed</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering declarative partitioning, handling permissions to view data, and the speed of triggers.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/20-declarative-partitioning-permissions-trigger-speed/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering declarative partitioning, handling permissions to view data, and the speed of triggers.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/20-declarative-partitioning-permissions-trigger-speed/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Declarative Partitioning, Permissions, Trigger Speed | Scaling Postgres 20]]>
                </itunes:title>
                                    <itunes:episode>20</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering declarative partitioning, handling permissions to view data, and the speed of triggers.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/20-declarative-partitioning-permissions-trigger-speed/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551411/sp20.mp3" length="14083134"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering declarative partitioning, handling permissions to view data, and the speed of triggers.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/20-declarative-partitioning-permissions-trigger-speed/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551411/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:40</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[100K Tenants, Extensions, Query Planning, Crosstabs | Scaling Postgres 19]]>
                </title>
                <pubDate>Mon, 02 Jul 2018 05:11:48 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    8b93fdc735764500bb9d2a29706d851b</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-19-100k-tenants-extensions-query-planning-crosstabs</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering 100,000 tenants, Postgres Extensions, query planning and how to create crosstabs.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/19-100k-tenants-extensions-query-planning-crosstabs/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering 100,000 tenants, Postgres Extensions, query planning and how to create crosstabs.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/19-100k-tenants-extensions-query-planning-crosstabs/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[100K Tenants, Extensions, Query Planning, Crosstabs | Scaling Postgres 19]]>
                </itunes:title>
                                    <itunes:episode>19</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering 100,000 tenants, Postgres Extensions, query planning and how to create crosstabs.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/19-100k-tenants-extensions-query-planning-crosstabs/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551412/sp19.mp3" length="16999235"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering 100,000 tenants, Postgres Extensions, query planning and how to create crosstabs.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/19-100k-tenants-extensions-query-planning-crosstabs/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551412/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:17:42</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Impact of Virtualization, Compressing Data, Parallelism | Scaling Postgres 18]]>
                </title>
                <pubDate>Mon, 25 Jun 2018 02:49:34 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    e1f15d04ac7d4afebf229afb3013ec15</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-18-impact-of-virtualization-compressing-data-parallelism</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering the impact of virtualization on databases, techniques to compress your data and parallelism.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/18-impact-virtualization-compressing-data-parallelism/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering the impact of virtualization on databases, techniques to compress your data and parallelism.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/18-impact-virtualization-compressing-data-parallelism/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Impact of Virtualization, Compressing Data, Parallelism | Scaling Postgres 18]]>
                </itunes:title>
                                    <itunes:episode>18</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering the impact of virtualization on databases, techniques to compress your data and parallelism.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/18-impact-virtualization-compressing-data-parallelism/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551413/sp18.mp3" length="16831634"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering the impact of virtualization on databases, techniques to compress your data and parallelism.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/18-impact-virtualization-compressing-data-parallelism/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551413/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:17:31</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Real Time Analytics, Index Decrease Performance, work_mem | Scaling Postgres 17]]>
                </title>
                <pubDate>Mon, 18 Jun 2018 02:10:15 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    264388ece4294bba80b4c3b6a16fe728</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-17-real-time-analytics-index-decrease-performance-work-mem</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering using Postgres for real-time analytics, how indexes can decrease performance and how to configure work_mem.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/17-real-time-analytics-index-decrease-performance-work_mem/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering using Postgres for real-time analytics, how indexes can decrease performance and how to configure work_mem.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/17-real-time-analytics-index-decrease-performance-work_mem/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Real Time Analytics, Index Decrease Performance, work_mem | Scaling Postgres 17]]>
                </itunes:title>
                                    <itunes:episode>17</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering using Postgres for real-time analytics, how indexes can decrease performance and how to configure work_mem.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/17-real-time-analytics-index-decrease-performance-work_mem/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551414/sp17.mp3" length="18892591"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering using Postgres for real-time analytics, how indexes can decrease performance and how to configure work_mem.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/17-real-time-analytics-index-decrease-performance-work_mem/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551414/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:19:40</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Storing Bits, Autovacuum, Assertions, Logical Recovery | Scaling Postgres 16]]>
                </title>
                <pubDate>Mon, 11 Jun 2018 03:48:39 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    f0789d8a5e924fa8bac3231f19c897ad</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-16-storing-bits-autovacuum-assertions-logical-recovery</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering efficiently storing bits, autovacuum, setting up assertions and logical replication recovery.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/16-storing-bits-autovacuum-assertions-logical-recovery/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering efficiently storing bits, autovacuum, setting up assertions and logical replication recovery.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/16-storing-bits-autovacuum-assertions-logical-recovery/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Storing Bits, Autovacuum, Assertions, Logical Recovery | Scaling Postgres 16]]>
                </itunes:title>
                                    <itunes:episode>16</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering efficiently storing bits, autovacuum, setting up assertions and logical replication recovery.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/16-storing-bits-autovacuum-assertions-logical-recovery/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551415/sp16.mp3" length="11474651"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering efficiently storing bits, autovacuum, setting up assertions and logical replication recovery.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/16-storing-bits-autovacuum-assertions-logical-recovery/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551415/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:11:57</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Leveraging Postgres, Tuning Autovacuum, Slow Queries | Scaling Postgres 15]]>
                </title>
                <pubDate>Mon, 04 Jun 2018 03:10:16 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    7105aa0e971f4e2b8cd62eda1390280c</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-15-leveraging-postgres-tuning-autovacuum-slow-queries</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles on how to better leverage postgres, tuning autovacuum, handling slow queries and using window functions.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/15-leveraging-postgres-tuning-autovacuum-slow-queries/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles on how to better leverage postgres, tuning autovacuum, handling slow queries and using window functions.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/15-leveraging-postgres-tuning-autovacuum-slow-queries/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Leveraging Postgres, Tuning Autovacuum, Slow Queries | Scaling Postgres 15]]>
                </itunes:title>
                                    <itunes:episode>15</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles on how to better leverage postgres, tuning autovacuum, handling slow queries and using window functions.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/15-leveraging-postgres-tuning-autovacuum-slow-queries/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551416/sp15.mp3" length="11564094"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles on how to better leverage postgres, tuning autovacuum, handling slow queries and using window functions.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/15-leveraging-postgres-tuning-autovacuum-slow-queries/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551416/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:02</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Postgres 11, Multi-tenant Scale, Trigger Speed, Full Text Search | Scaling Postgres 14]]>
                </title>
                <pubDate>Mon, 28 May 2018 03:12:18 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    fc08de0df6d8467781c514773e4fd76a</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-14-postgres-11-multi-tenant-scale-trigger-speed-full-text-search</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering the upcoming PostgreSQL 11, scaling for multi-tenant apps, the speed of triggers and full text search.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/14-pg11-multi-tenant-scale-trigger-speed-full-text-search/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering the upcoming PostgreSQL 11, scaling for multi-tenant apps, the speed of triggers and full text search.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/14-pg11-multi-tenant-scale-trigger-speed-full-text-search/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Postgres 11, Multi-tenant Scale, Trigger Speed, Full Text Search | Scaling Postgres 14]]>
                </itunes:title>
                                    <itunes:episode>14</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering the upcoming PostgreSQL 11, scaling for multi-tenant apps, the speed of triggers and full text search.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/14-pg11-multi-tenant-scale-trigger-speed-full-text-search/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551417/sp14.mp3" length="12549642"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering the upcoming PostgreSQL 11, scaling for multi-tenant apps, the speed of triggers and full text search.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/14-pg11-multi-tenant-scale-trigger-speed-full-text-search/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551417/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:13:04</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Sharding Future, Query Optimization, Replication Read Performance, PostGIS | Scaling Postgres 13]]>
                </title>
                <pubDate>Mon, 21 May 2018 03:26:53 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    408127569a144e48ab374a20bb055a38</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-13-sharding-future-query-optimization-replication-read-performance-postgis</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering the future of sharding PostgreSQL databases, query optimization, replication read performance and PostGIS.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/13-shardings-future-query-optimization-replication-read-performance-postgis/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering the future of sharding PostgreSQL databases, query optimization, replication read performance and PostGIS.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/13-shardings-future-query-optimization-replication-read-performance-postgis/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Sharding Future, Query Optimization, Replication Read Performance, PostGIS | Scaling Postgres 13]]>
                </itunes:title>
                                    <itunes:episode>13</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering the future of sharding PostgreSQL databases, query optimization, replication read performance and PostGIS.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/13-shardings-future-query-optimization-replication-read-performance-postgis/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551418/sp13.mp3" length="15371702"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering the future of sharding PostgreSQL databases, query optimization, replication read performance and PostGIS.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/13-shardings-future-query-optimization-replication-read-performance-postgis/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551418/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:16:00</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[The Future, Slow Counts, Avoid Or, Replication | Scaling Postgres 12]]>
                </title>
                <pubDate>Mon, 14 May 2018 03:22:53 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    c1d5267c43a4cb4e2aa818835202173b</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-12-the-future-slow-counts-avoid-or-replication</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering the future of databases, why counting is slow, the best ways to avoid ORs, and all about replication.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/12-future-slow-counts-avoid-or-replication/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering the future of databases, why counting is slow, the best ways to avoid ORs, and all about replication.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/12-future-slow-counts-avoid-or-replication/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[The Future, Slow Counts, Avoid Or, Replication | Scaling Postgres 12]]>
                </itunes:title>
                                    <itunes:episode>12</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering the future of databases, why counting is slow, the best ways to avoid ORs, and all about replication.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/12-future-slow-counts-avoid-or-replication/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551420/sp12.mp3" length="10756597"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering the future of databases, why counting is slow, the best ways to avoid ORs, and all about replication.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/12-future-slow-counts-avoid-or-replication/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551420/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:11:12</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Serializable, JSON & JSONB, Fast Data Loading, PG11 Features | Scaling Postgres 11]]>
                </title>
                <pubDate>Mon, 07 May 2018 03:55:51 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    ae182fafab704e388b671e3f4129988b</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-11-serializable-json-jsonb-fast-data-loading-pg11-features</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering serializable, JSON &amp; JSONB data types, fast data loading with Ruby and Postgres 11 new features.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/11-serializable-json-jsonb-fast-data-loading-pg11-features/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering serializable, JSON & JSONB data types, fast data loading with Ruby and Postgres 11 new features.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/11-serializable-json-jsonb-fast-data-loading-pg11-features/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Serializable, JSON & JSONB, Fast Data Loading, PG11 Features | Scaling Postgres 11]]>
                </itunes:title>
                                    <itunes:episode>11</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering serializable, JSON &amp; JSONB data types, fast data loading with Ruby and Postgres 11 new features.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/11-serializable-json-jsonb-fast-data-loading-pg11-features/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551419/sp11.mp3" length="11740055"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering serializable, JSON & JSONB data types, fast data loading with Ruby and Postgres 11 new features.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/11-serializable-json-jsonb-fast-data-loading-pg11-features/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551419/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:13</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[ANSI Schmansi, Split-Brain, Performance Scenarios, Parallelism | Scaling Postgres 10]]>
                </title>
                <pubDate>Mon, 30 Apr 2018 03:24:58 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    cf8c55a7ecf86d27e8ea9c61a4579cfc</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-10-ansi-schmansi-split-brain-performance-scenarios-parallelism</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering ANSI Schmansi, split-brain replication issues, performance solutions to business scenarios and paralellism.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/10-ansi-schmansi-split-brain-performance-scenarios-parallelism/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering ANSI Schmansi, split-brain replication issues, performance solutions to business scenarios and paralellism.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/10-ansi-schmansi-split-brain-performance-scenarios-parallelism/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[ANSI Schmansi, Split-Brain, Performance Scenarios, Parallelism | Scaling Postgres 10]]>
                </itunes:title>
                                    <itunes:episode>10</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering ANSI Schmansi, split-brain replication issues, performance solutions to business scenarios and paralellism.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/10-ansi-schmansi-split-brain-performance-scenarios-parallelism/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551421/sp10.mp3" length="11722919"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering ANSI Schmansi, split-brain replication issues, performance solutions to business scenarios and paralellism.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/10-ansi-schmansi-split-brain-performance-scenarios-parallelism/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551421/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:12</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[High Volume Processing, pg_wal Issues, Restore with pg_receivewal | Scaling Postgres 9]]>
                </title>
                <pubDate>Mon, 23 Apr 2018 03:41:48 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    07c3fc564e98605267f2fefa396550e5</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/scaling-postgres-episode-9-high-volume-processing-pg-wal-issues-restore-with-pg-receivewal</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering high volume processing, indexing, pg_wal issues, Postgres data types and restoring when using pg_receivewal.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/9-high-volume-processing-pg_wal-issues-restore-pg_receivewal/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering high volume processing, indexing, pg_wal issues, Postgres data types and restoring when using pg_receivewal.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/9-high-volume-processing-pg_wal-issues-restore-pg_receivewal/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[High Volume Processing, pg_wal Issues, Restore with pg_receivewal | Scaling Postgres 9]]>
                </itunes:title>
                                    <itunes:episode>9</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering high volume processing, indexing, pg_wal issues, Postgres data types and restoring when using pg_receivewal.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/9-high-volume-processing-pg_wal-issues-restore-pg_receivewal/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551423/sp9.mp3" length="10581472"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering high volume processing, indexing, pg_wal issues, Postgres data types and restoring when using pg_receivewal.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/9-high-volume-processing-pg_wal-issues-restore-pg_receivewal/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551423/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:11:01</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Scaling Real-Time Analytics, Covering Indexes, 1,500 Upgrades | Scaling Postgres 8]]>
                </title>
                <pubDate>Mon, 16 Apr 2018 03:27:26 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    c1c45cf1879f19b843202a722f640bb4</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-8-scaling-real-time-analytics-covering-indexes-1500-upgrades</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering real-time analytics at scale, covering indexes in Postgres 11, 1,500 Postgres upgrades and PostgreSQL vs. MySQL.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/8-scaling-analytics-covering-indexes-1500-upgrades/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering real-time analytics at scale, covering indexes in Postgres 11, 1,500 Postgres upgrades and PostgreSQL vs. MySQL.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/8-scaling-analytics-covering-indexes-1500-upgrades/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Scaling Real-Time Analytics, Covering Indexes, 1,500 Upgrades | Scaling Postgres 8]]>
                </itunes:title>
                                    <itunes:episode>8</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering real-time analytics at scale, covering indexes in Postgres 11, 1,500 Postgres upgrades and PostgreSQL vs. MySQL.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/8-scaling-analytics-covering-indexes-1500-upgrades/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551422/sp8.mp3" length="14500257"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering real-time analytics at scale, covering indexes in Postgres 11, 1,500 Postgres upgrades and PostgreSQL vs. MySQL.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/8-scaling-analytics-covering-indexes-1500-upgrades/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551422/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:15:06</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Any Scale, Monitoring Vacuum, Copy, Annotated Config | Scaling Postgres 7]]>
                </title>
                <pubDate>Mon, 09 Apr 2018 03:10:10 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    5b97be95b552c8321e68db1486ae1b67</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-7-any-scale-monitoring-vacuum-copy-annotated-config</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering Postgres at any scale, monitoring vacuum, using copy, annotated config files, and how to do easy replication failback to an old primary database.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/7-any-scale-monitor-vacuum-copy-annotated-config/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering Postgres at any scale, monitoring vacuum, using copy, annotated config files, and how to do easy replication failback to an old primary database.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/7-any-scale-monitor-vacuum-copy-annotated-config/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Any Scale, Monitoring Vacuum, Copy, Annotated Config | Scaling Postgres 7]]>
                </itunes:title>
                                    <itunes:episode>7</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering Postgres at any scale, monitoring vacuum, using copy, annotated config files, and how to do easy replication failback to an old primary database.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/7-any-scale-monitor-vacuum-copy-annotated-config/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551424/sp7.mp3" length="10707696"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering Postgres at any scale, monitoring vacuum, using copy, annotated config files, and how to do easy replication failback to an old primary database.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/7-any-scale-monitor-vacuum-copy-annotated-config/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551424/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:11:09</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Terabyte Scale, Permissions, Fast Column Adds, pgBouncer | Scaling Postgres 6]]>
                </title>
                <pubDate>Mon, 02 Apr 2018 06:30:58 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    cb2dee2b70fe093dd16f7d8072f5f4eb</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-6-terabyte-scale-permissions-fast-column-adds-pgbouncer</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering terabyte scale &amp; analytics, database permissions, fast column adding coming to PosgreSQL 11 and pgBouncer.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/6-terabyte-scale-permissions-fast-column-add-pgbouncer/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering terabyte scale & analytics, database permissions, fast column adding coming to PosgreSQL 11 and pgBouncer.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/6-terabyte-scale-permissions-fast-column-add-pgbouncer/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Terabyte Scale, Permissions, Fast Column Adds, pgBouncer | Scaling Postgres 6]]>
                </itunes:title>
                                    <itunes:episode>6</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering terabyte scale &amp; analytics, database permissions, fast column adding coming to PosgreSQL 11 and pgBouncer.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/6-terabyte-scale-permissions-fast-column-add-pgbouncer/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551425/sp6.mp3" length="10283885"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering terabyte scale & analytics, database permissions, fast column adding coming to PosgreSQL 11 and pgBouncer.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/6-terabyte-scale-permissions-fast-column-add-pgbouncer/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551425/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:10:42</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Constraints, User Order, PG Terrible, Logical Upgrades | Scaling Postgres 5]]>
                </title>
                <pubDate>Mon, 26 Mar 2018 02:49:23 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    cf9af73281727c30d632ed58480bf4a0</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-5-constraints-user-order-pg-terrible-logical-upgrades</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering database constraints, user defined ordering, how PostgreSQL is terrible, TimeScaleDB and using logical replication for upgrades.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/5-constraints-user-order-pg-terrible-logical-upgrades/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering database constraints, user defined ordering, how PostgreSQL is terrible, TimeScaleDB and using logical replication for upgrades.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/5-constraints-user-order-pg-terrible-logical-upgrades/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Constraints, User Order, PG Terrible, Logical Upgrades | Scaling Postgres 5]]>
                </itunes:title>
                                    <itunes:episode>5</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering database constraints, user defined ordering, how PostgreSQL is terrible, TimeScaleDB and using logical replication for upgrades.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/5-constraints-user-order-pg-terrible-logical-upgrades/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551426/sp5.mp3" length="14145828"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering database constraints, user defined ordering, how PostgreSQL is terrible, TimeScaleDB and using logical replication for upgrades.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/5-constraints-user-order-pg-terrible-logical-upgrades/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551426/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:14:44</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[50TB Upgrade, Vacuum, DB Security | Scaling Postgres 4]]>
                </title>
                <pubDate>Mon, 19 Mar 2018 02:30:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    75661a5a8e305137bb88117c12dfe84c</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-4-50tb-upgrade-vacuum-db-security</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering developers loving PostgreSQL, a 50TB database upgrade, information on vacuums, patches for parallel PostGIS plans, database security concerns, DB normalization and primary keys and generate series.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/4-50TB-upgrade-vacuum-db-security/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering developers loving PostgreSQL, a 50TB database upgrade, information on vacuums, patches for parallel PostGIS plans, database security concerns, DB normalization and primary keys and generate series.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/4-50TB-upgrade-vacuum-db-security/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[50TB Upgrade, Vacuum, DB Security | Scaling Postgres 4]]>
                </itunes:title>
                                    <itunes:episode>4</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering developers loving PostgreSQL, a 50TB database upgrade, information on vacuums, patches for parallel PostGIS plans, database security concerns, DB normalization and primary keys and generate series.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/4-50TB-upgrade-vacuum-db-security/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551427/sp4.mp3" length="11952378"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering developers loving PostgreSQL, a 50TB database upgrade, information on vacuums, patches for parallel PostGIS plans, database security concerns, DB normalization and primary keys and generate series.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/4-50TB-upgrade-vacuum-db-security/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551427/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:12:27</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Modeling, Query Performance, Statistics, pgmetrics | Scaling Postgres 3]]>
                </title>
                <pubDate>Mon, 12 Mar 2018 00:30:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    b656382732985682f6800a3ba5b82a5a</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-3-modeling-query-performance-statistics-pgmetrics</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering modeling, checking for long queries using pg_stat_statements, statistics in PosgreSQL 10 and pgmetrics.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/3-modeling-query-performance-statistics-pgmetrics/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering modeling, checking for long queries using pg_stat_statements, statistics in PosgreSQL 10 and pgmetrics.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/3-modeling-query-performance-statistics-pgmetrics/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Modeling, Query Performance, Statistics, pgmetrics | Scaling Postgres 3]]>
                </itunes:title>
                                    <itunes:episode>3</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering modeling, checking for long queries using pg_stat_statements, statistics in PosgreSQL 10 and pgmetrics.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/3-modeling-query-performance-statistics-pgmetrics/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551428/sp3.mp3" length="8678504"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering modeling, checking for long queries using pg_stat_statements, statistics in PosgreSQL 10 and pgmetrics.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/3-modeling-query-performance-statistics-pgmetrics/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551428/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:09:02</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Analytical DBs, Recursive Queries, Replication | Scaling Postgres 2]]>
                </title>
                <pubDate>Mon, 05 Mar 2018 02:00:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    cbeff2f60e34a6902d78151f757dc963</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-2-analytical-dbs-recursive-queries-replication</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering analytical DBs (potentially using GPUs), recursive queries and different forms of replication.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/2-analytical-db-recursive-queries-replication/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering analytical DBs (potentially using GPUs), recursive queries and different forms of replication.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/2-analytical-db-recursive-queries-replication/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Analytical DBs, Recursive Queries, Replication | Scaling Postgres 2]]>
                </itunes:title>
                                    <itunes:episode>2</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering analytical DBs (potentially using GPUs), recursive queries and different forms of replication.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/2-analytical-db-recursive-queries-replication/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551429/sp2.mp3" length="16940721"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering analytical DBs (potentially using GPUs), recursive queries and different forms of replication.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/2-analytical-db-recursive-queries-replication/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551429/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:17:38</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
                    <item>
                <title>
                    <![CDATA[Petabyte Scale and Locking | Scaling Postgres 1]]>
                </title>
                <pubDate>Tue, 27 Feb 2018 15:30:00 +0000</pubDate>
                <dc:creator>Creston Jamison</dc:creator>
                <guid isPermaLink="false">
                    08e93ab00d9c7991579b93174f421bfb</guid>
                                    <link>https://scaling-postgres-1.castos.com/episodes/episode-1-petabyte-scale-and-locking</link>
                                <description>
                                            <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering petabyte scale techniques as well as various articles on locking.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/1-petabyte-scale-and-locking/</p>]]>
                                    </description>
                <itunes:subtitle>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering petabyte scale techniques as well as various articles on locking.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/1-petabyte-scale-and-locking/]]>
                </itunes:subtitle>
                                    <itunes:episodeType>full</itunes:episodeType>
                                <itunes:title>
                    <![CDATA[Petabyte Scale and Locking | Scaling Postgres 1]]>
                </itunes:title>
                                    <itunes:episode>1</itunes:episode>
                                                <itunes:explicit>false</itunes:explicit>
                <content:encoded>
                    <![CDATA[<p>In this episode of Scaling Postgres, we review articles covering petabyte scale techniques as well as various articles on locking.</p>
<p>To get the show notes as well as get notified of new episodes, visit: </p>
<p>https://www.scalingpostgres.com/episodes/1-petabyte-scale-and-locking/</p>]]>
                </content:encoded>
                                    <enclosure url="https://episodes.castos.com/64f928bed21987-09216453/1551430/sp1.mp3" length="17036852"
                        type="audio/mpeg">
                    </enclosure>
                                <itunes:summary>
                    <![CDATA[In this episode of Scaling Postgres, we review articles covering petabyte scale techniques as well as various articles on locking.
To get the show notes as well as get notified of new episodes, visit: 
https://www.scalingpostgres.com/episodes/1-petabyte-scale-and-locking/]]>
                </itunes:summary>
                                    <itunes:image href="https://episodes.castos.com/64f928bed21987-09216453/images/1551430/itunes.jpg"></itunes:image>
                                                                            <itunes:duration>00:17:44</itunes:duration>
                                                    <itunes:author>
                    <![CDATA[Creston Jamison]]>
                </itunes:author>
                            </item>
            </channel>
</rss>
